import testdata from './data.module.scss'
import { Testtype, Testlist } from "../../model"
import React, { useRef } from 'react';
import { useParams } from 'react-router-dom';
export default function Datainner (){
    const { data } = useParams();
    console.log(data,'data')
   
    const testjspwork : Testtype[] = [
        {
            q : "웹 또는 웹서비스와 직접적인 관련이 없는 것은?",
            q1 : "",
            a : ["인터넷","HTML","HTTP","클래스"],
            r : 4,
            img:'',
            summary:'웹은 정보 공유를 목적으로 하이퍼 텍스트가 서로 연결되어 있는 시스템을 말함, 하이퍼 텍스트를 작성하는데 사용되는 언어가 html이며, 웹서비스는 http프로토콜을 이용하여 클라이언트가 html문서를 요청하고 웹서버가 html 문서를 제공하는 것이다.'
        },
        {
            q : "웹에 관한 다음 설명중 잘못된 것은?",
            q1 : "",
            a : ["웹서버란 웹 클라이언트의 요청을 서비스하는 기능을 담당한다.","웹서버의 기능을 구조적으로 분리하여 처리하려는 목적으로 웹 애플리케이션 서버 was가 등장하였다.","웹서버와 클라이언트는 html이라는 프로토콜을 기반으로 통신한다.","웹 브라우저란 웹 서비스를 요청하고 결과를 제공받는 클라이언트다."],
            r : 3,
            img:'',
            summary:'웹 서버와 클라이언트 사이에 이용되는 프로토콜은 http이다.'
        },
        {
            q : "동적 웹 문서를 작성하는 기술과 직접적인 관련이 없는 것은?",
            q1 : "",
            a : ["javascript","JDBC","JSP","CGI"],
            r : 2,
            img:'',
            summary:'CGI는 초기에 사용되었던 기술이다. javascript는 클라이언트 측, jsp는 웹서버측에서 실행되는 스크립트 언어로 html 부분과 프로그램 부분이 분리된 프로그램을 작성한다. jdbc는 데이터베이스와 연결과 sql처리를 위한 java api이다.'
        },
        {
            q : "다음 설명에서 이것에 해당하는 용어는?",
            q1 : "",
            a : ["웹 애플리케이션 서버 (was)","http 프로토콜","java EE","웹브라우저"],
            r : 1,
            img:'jsp워크북.JPG',
            summary:'클라이언트로부터 요청을 받는 일과 처리 결과를 클라이언트로 전송하는 일은 웹서버가 담당한다.'
        },
        {
            q : "다음이 설명하는 용어는 정확히 무엇인가?",
            q1 : "jsp 소스 페이지로부터 서블릿 소스 및 서블릿 클래스를 생성해주는 서버 모듈",
            a : ["이클립스","JDK","웹서버","jsp 컨테이너 또는 jsp엔진"],
            r : 4,
            img:'',
            summary:'jsp 컨테이너는 과거에 jsp엔진이라고 불렸다'
        },
        {
            q : "jsp언어에 관한 설명으로 잘못된 것은?",
            q1 : "",
            a : ["스크립트 방식으로 프로그램을 작성할 수 있다.","자바 언어의 특성을 활용할 수 있다","서블릿 기술에 기초한다","웹 애플리케이션 서버의 하나이다."],
            r : 4,
            img:'',
            summary:'jsp페이지에 대한 요청을 처리하기 위한 것이 웹 에플리케이션 서버이며 웹서버와 연동된다. 이것은 서블릿 컨테이너 또는 jsp 컨테이너를 포함하고 있으며, 추가적ㅇ르ㅗ 비즈니스 로직을 처리하는 컨테이너도 포함된다.'
        },
        {
            q : "jsp에 관한 설명 중 잘못된 것은?",
            q1 : "",
            a : ["jsp언어는 자바에 기반을 둔 웹 프로그래밍언어이다","jsp기술은 플랫폼에 종속적인 면이 강하다","jsp페이지는 서버에서 실행된다","jsp기술을 이용하여 동적 웹문서를만들 수 있다."],
            r : 2,
            img:'',
            summary:'jsp 기술은 플랫폼에 독립적이다.'
        },
        {
            q : "jsp 기술에 관한 설명으로 적당하지 않은 것은?",
            q1 : "",
            a : ["문서의 구조, 내용 및 스타일을 분리하기 위한 방법","플랫폼에 독립적인 개발 기술","서블릿 코드를 작성하는 편리한 방법을 제공","요청에 동적으로 응답하기 위한 페이지의 작성"],
            r : 1,
            img:'',
            summary:'1에 해당하는 것은 xml과 관련된 기술이다'
        },
        {
            q : "http와 관련이 있는 내용으로 볼 수 없는 것은?",
            q1 : "",
            a : ["요청에 대한 응답후에는 클라이언트의 상태를 유지하지 않음","요청 메시지와 응답 메시지","웹 클라이언트와 웹 서버 간의 통신 규약","웹 서버의 기능을 구조적으로 분리한 서버 측 모듈"],
            r : 4,
            img:'',
            summary:'4는 웹 애플리케이션 서버 또는 웹 컨테이너에 관한 설명이다.'
        },
        {
            q : "http프로토콜에서 클라이언트의 요청에 서버가 응답하면 접속이 해제된다 이것을 무엇이라 하는가?",
            q1 : "",
            a : ["connectedness","server-push","client-pull","connection-orient & stateless"],
            r : 4,
            img:'',
            summary:'http프로토콜은 하나의 요청에 하나의 응답으로 끝나며 이후에는 클라이언트의 접속이 유지되지 않는다. 이것을 무상태(stateless)라고 하며 상태가 유지되지 않는다는 의미이다.'
        },
        {
            q : "다음이 설명하는 http 요청 방식 (request method)은 무엇인가?",
            q1 : "원하는 방식으로 인코딩된 데이터를 메시지 몸체에 포함하여 전송하면서 파일을 요청하고자 하는 경우 사용된다.",
            a : ["GET","HEAD","POST","OPTIONS"],
            r : 3,
            img:'',
            summary:'post 요청방식은 대개 html 폼을 이용하여 데이터를 전송할 때 사용된다. 사용자 데이터는 요청 메시지의 몸체에 포함되어 서버에 전달된다.'
        },
        {
            q : "http요청 메시지에 포함되는 내용이 아닌 것은?",
            q1 : "",
            a : ["클라이언트가 접근하고자 하는 웹서버의 자원 (URL)","웹 브라우저가 받을 콘텐츠의 유형 (content-type)과 길이(content-length)","http 요청 방식 (get or post 등)","클라이언트가 보내는 폼 데이터 "],
            r : 2,
            img:'',
            summary:'웹 브라우저가 받아 처리할 콘텐츠의 content-type 과 content-length 는 응답메시지의 헤더 부분에 포함된다.'
        },
        {
            q : "http 요청에 응답하기 위해 웹서버가 html 페이지를 만들었다. http 응답과 html 페이지의 관계는 무엇인가?",
            q1 : "",
            a : ["html 페이지는 http응답에서 몸체에 포함된다","html 페이지는 http응답에서 상태코드에 포함된다","html 페이지는 http응답에서 content-type 헤더에 포함된다","http 응답과 html페이지는 같은 것이다."],
            r : 1,
            img:'',
            summary:'웹서버가 만든 문서는 응답메시지 몸체에 포함된다.'
        },
        { //2장
            q : "JSP 기술을 사용하여 웹 애플리케이션을 개발하고자 할때 설치해야 하는 것이 아닌 것은?",
            q1 : "",
            a : ["JDK","이클립스","톰캣","ASP.NET Framework"],
            r : 4,
            img:'',
            summary:`asp.net은 .net언어로 웹 애플리케이션을 만들기 위한 마이크로소프트의 기술이다.`
        },
        {
            q : "war파일에 대한 설명으로 잘못된 것은?",
            q1 : "",
            a : ["jsp 페이지 html페이지, 자바 클래스 파일 등을 묶은 것이다.","확장자는 .jar이다","이클립스를 사용하면 쉽게 war파일을 만들 수 있다,","웹 애플리케이션을 웹 컨테이너에 배포할때 사용되는 파일 형식이다."],
            r : 2,
            img:'',
            summary:`war파일은 java압축 파일인 jar 파일과 같다고 할 수 있으나 확장자는 .war이다`
        },
        {
            q : "톱캣에 대한 설명으로 정확한 것은?",
            q1 : "",
            a : ["Apache Software Foundation에서 개발한 서블릿/JSP 컨테이너","C언어로 구현된 HTTP 웹서버","오픈소스의 통합 개발 환경","자바 플랫폼"],
            r : 1,
            img:'',
            summary:`톰캣도 웹서버의 기능을 가지고 있으나 자바로 구현된 것이다.
            참고로 apache 소프트웨어 재단의 지원하에 개발된 웹서버용 오픈소스 소프트웨어인 apache http server가 있다. 이것은 c언어로 구현되었고 웹의 성장에 큰 기여를 하였다.`
        },
        {
            q : "톰캣에 관한 설명이다. 올바른 것은?",
            q1 : "",
            a : ["마이크로소프트에서 개발한 jsp컨테이너다","기본적으로 포트번호 80으로 들어오는 요청을 처리한다.","jsp프로그래밍을 위한 오픈소스의 통합 개발 환겅이다. ","기본적인 웹서버 기능을 포함하고 있다."],
            r : 4,
            img:'',
            summary:`톰캣은 기본적으로 8080 포트를 담당한다.`
        },
        {
            q : "이클립스에 관한 설명으로 적당한 것은?",
            q1 : "",
            a : ["http 웹서버이다","커스텀 태그 라이브러리이다","윈도우에서 사용되는 자바 플랫폼의 일종이다","다양한 언어를 지원하는 통합 개발 환경이다."],
            r : 4,
            img:'',
            summary:`이클립스는 통합 개발 환경으로 jsp페이지를 개발할 때는 톰캣과 연동된다.`
        },
        {
            q : "이클립스를 이용해 개발한 웹프로젝트를 배포하고자 한다. 이것과 관련이 없는 설명은 무엇인가?",
            q1 : "",
            a : ["war 파일은 웹 프로젝트를 압축한 파일이다","웹 프로젝트를 웹 컨테이너에 내보내는 것이다","톰캣을 이클립스에 서버로 등록시키는 것이다","수작업으로 배포를 하려면 톰캣의 폴더구조를 이해해야 한다."],
            r : 3,
            img:'',
            summary:`웹 프로그래밍을 위해 이클립스에 톰캣을 서버로 등록하는 것은 필요하나 이것이 배포를 의미하는 것은 아니다./`
        },
        {
            q : "이클립스를 사용하여 hello_jsp .jsp를 만들고 실행시키려 한다. 필요한 작업이 아닌것은?",
            q1 : "",
            a : ["웹 컨테이너를 서버로 등록한다.","dynamic web project를 만든다.","jsp 내장객체를 등록한다","hello.jsp 소스파일을 편집한다"],
            r : 3,
            img:'',
            summary:`3은 불필요한 작업으로 이클립스에 톰캣을 서버로 등록하는 것으로 족하다`
        },
        {
            q : "개발이 끝난 웹 프로젝트를 war 파일로 만들어 톰캣에 배포할때 어떤 폴더에 위치시켜야 하는가?",
            q1 : "",
            a : ["톰캣설치폴더","톰캣설치폴더/webapps","톰캣설치폴더/webapps/build","톰캣설치폴더/webapps/WEB-INF/classes"],
            r : 2,
            img:'',
            summary:`웹 프로젝트는 톰캣 설치폴더에 war 파일이나 서브 폴더로 존재해야 한다.`
        },
        {
            q : "다음 중 웹 컨테이너라고 할 수 없는 것은",
            q1 : "",
            a : ["apache http server","tomcat","weblogic","jeus"],
            r : 1,
            img:'',
            summary:`apache http server 는 http 서비스를 제공하는 오픈소스 웹서버이다.`
        },
        {
            q : "서블릿 규약에서 웹 프로젝트의 폴더 구성에 관한 설명이다 올바른 것은?",
            q1 : "",
            a : ["프로젝트폴더/META-INF웹 애플리케이션의 설정 정보를 담은 web.xml이 위치한다","프로젝트폴더/WEB-INF/classes에 웹 애플리케이션에서 사용하는 클래스 파일이 위치한다.","프로젝트 폴더/WEB-INF/lib에는 웹 애플리케이션에서 사용하는 .jsp 파일이 위치힌다.","웹 컨테이너로 톰캣을 사용하는 경우, Webcontent 폴더에 웹 애플리케이션 폴더가 위치한다."],
            r : 2,
            img:'',
            summary:`web.xml 파일은 웹 설정 파일로 WEB-INF 에 위치하며 WEB-INF/lib에는 .jar 파일이 위치한다.`
        },
        {//3장
            q : "JSP에서 사용되는 기본 태그의 종류와 형태가 잘못 짝지어진 것은?",
            q1 : "",
            a : ["지시어 <%@...%>","표현식 <%!...%>","스크립트릿 <% ...%>","주석  <%--.... %>"],
            r : 2,
            img:'',
            summary:`표현식의 형태는 <%= ...%>이다.  <%!...%> 는 메서드 선언이나 변수 선언을 위한 형태이다.`
        },
        {
            q : "JSP페이지에서 자바 언어로 프로그램을 작성하여 실행하고자 할 때 사용되는 요소를 무엇이라 하는가?",
            q1 : "",
            a : ["지시어","템플릿 데이터","스크립트릿","Javascript"],
            r : 3,
            img:'',
            summary:`스크립트릿은 jsp페이지에 존재하는 자바 프로그램 조각으로 볼 수 있다.`
        },
        {
            q : "page 지시어에서 사용되는 속성 contentType에 관한 설명은 무엇인가?",
            q1 : "",
            a : ["버퍼가 찼을때 내용을 클라이언트로 전송하고 버퍼를 비울지 정함","session 객체를 사용할지 여부를 지정","응답 문서의 종류(mime 타입)과 사용되는 문자 인코딩 정보를 설정","사용할 자바 클래스 지정"],
            r : 3,
            img:'',
            summary:`1번은 autoFlush속성, 2번은 session속성 4번은 import속성을 사용해야 한다.`
        },
        {
            q : "다음 문장이 의미하는 것은 무엇인가?",
            q1 : "<% page import='java.sql.* %>",
            a : ["jsp 페이지의 특정 영역에 다른 문서를 포함하는 것이다.","jsp 페이지에서 사용할 외부 클래스를 지정하는 것이다.","jsp 페이지에서 사용할 태그 라이브러리를 지정한 것이다.","jsp 페이지에서 사용할 내장 객체를 선언한 것이다."],
            r : 2,
            img:'',
            summary:`자바 프로그램에서의 import 구문과 같다.`
        },
        {
            q : "jsp페이지에서 특별한 기능을 수행하는 표준액션 태그의 형태는 다음중 무엇인가?",
            q1 : "",
            a : ["<%@ ...%>","<jsp:tagName .../>","${expr}","<%...%>"],
            r : 2,
            img:'',
            summary:`액션태는 xml형식의 태그로 <jsp로 시작된다.`
        },
        {
            q : "다음이 의미하는 것은 무엇일까?",
            q1 : "<%@ taglib prefix=\"c\" url=\"://java.com/jsp/jstl/core\" %>",
            a : ["jsp페이지의 특정 영역에 다른 문서를 포함하는 것이다","jsp가 생성하는 문서의 타입이나 출력버퍼의 크기를 정하는 것이다.","jsp페이지에서 사용할 태그 라이브러리를 지정한 것이다.","jsp페이지에서 사용할 내장 객체를 선언한 것이다."],
            r : 3,
            img:'',
            summary:`태그 이름에 접두어 'c'를 사용하며, uri 속성의 값으로 지정되어 있는 태그 라이브러리를 사용하겠다는 의미이다.`
        },
        {//8
            q : "다음은 스크립트릿을 사용하지 않고 변수나 수식의 값을 표현하는 것이다. 무엇이라 하는가?",
            q1 : "<%= expr %>",
            a : ["표현식","표현언어","태그 속성","탬플릿 데이터"],
            r : 1,
            img:'',
            summary:`표현언어는 \$\{expr\}의 형식을 가진다. 탬플릿 데이터는 jsp페이지에서 정적인 html데이터를 말한다.`
        },
        {
            q : "변수 str의 jsp 페이지의 실행 결과에 포함시키려면 밑줄 부분을 어떻게 채워야 하는가?",
            q1 : "",
            a : ["out.print(str);","<%= str %>","<%= str ; %>","<%!= str; %>"],
            r : 2,
            img:'jsp워크북01.JPG',
            summary:`표현식에는 세미콜론을 사용하지 않는다.`
        },
        {
            q : "액션은 요청을 처리할때 특정기능을 수행하는 것이다. 모든 jsp컨테이너가 구현해야 하는 표준 액션을 표현할 때, 액션 태그의 접두어로 사용되는 단어는 무엇인가?",
            q1 : "",
            a : ["function","servlet","action","jsp"],
            r : 4,
            img:'',
            summary:`표준 액션을 표현하는 태그는 <jsp:액션태그이름 .../>의 형태이다. 표준액션을 확장하기 위해 커스텀 액션태그를 만들 수 있다.`
        },
        {
            q : "jsp 기반 웹애플리케이션의 구성요소로 보기 힘든 것은?",
            q1 : "",
            a : ["jsp 페이지","서블릿","서버 측 자바빈 컴포넌트","클라이언트 측 액션 스크립트"],
            r : 4,
            img:'',
            summary:`서버 측의 자바 실행환경, jsp 페이지와 서블릿, 자바빈 컴포넌트, 정적 html 그리고 클라이언트 측의 애플릿과 자바 실행환경을 모두 웹 애플리케이션의 구성요소로 볼 수 있다.`
        },
        {//4장
            q : "jsp 페이지에 대한 클라이언트 요청의 처리 과정을 설명한 것이다. 잘못된 것은?",
            q1 : "",
            a : ["jsp페이지에 상응하는 서블릿이 존재하는지 확인한다.","필요한 경우 jsp 페이지를 서블릿 프로그램으로 변환하고 컴파일 한다","클라이언트 요청이 있을때마다 서블릿 코드로의 변환/ 컴파일/ 실행과정이 매번 요구된다","상응하는 서블릿을 실행하여 클라이언트의 요청을 처리한다."],
            r : 3,
            img:'',
            summary:`기본적으로 jsp 컨테이너는 jsp페이지를 구현한 서블릿 클래스(.class)가 있는지 확인한다. 상응하는 서블릿이 없거나 jsp페이지가 서블릿 클래스보다 새것인 경우에 변환과 컴파일 작업을 수행한다.`
        },
        {
            q : "jsp페이지에 대한 요청을 처리할때 상응하는 서블릿 클래스가 있는지 먼저 확인해야한다. 만약 서블릿 클래스가 jsp 페이지보다 이전에 만들어진 것이라면 어떤 처리가 일어나는가?",
            q1 : "",
            a : ["jsp 페이지를 이전 버전으로 되돌린다","다른 처리과정을 생략하고 바로 서블릿을 실행시킨다","jsp페이지를 서블릿 소스로 변환한 후 컴파일하고 실행한다","서블릿 클래스의 작성 시간을 현재 시간으로 변경한다."],
            r : 3,
            img:'',
            summary:`서블릿 클래스가 jsp페이지보다 이전에 만들어졌다는 것은 jsp페이지가 최근에 수정되었다는 의미이다.`
        },
        {
            q : "page 지시어에서 autoflush 속성이 true인 경우 의미하는 것은?",
            q1 : "",
            a : ["버퍼가 차면 내용을 클라이언트로 전송하고 버퍼를 비우라는 것","버퍼가 차면 예외를 발생시키라는 것","응답을 만들 때 버퍼링을 사용하라는 것","버퍼의 크기가 자동으로 확장된다는 것"],
            r : 1,
            img:'',
            summary:`autoflush 속성이 true인 경우 버퍼가 차면 버퍼를 비우고 작업을 수행한다. autoflush속성이 false인 경우 버퍼가 차면 예외가 발생한다`
        },
        {
            q : "다음 코드에 대한 설명으로 잘못된 것은?",
            q1 : "<%@ page buffer='4kb' autuFlush='flase' %>",
            a : ["출력버퍼의 크기를 지정하였다","출력버퍼가 다 찼을 경우 예외를 발생시킨다","출력버퍼를 사용한다","출력버퍼가 다 차면 자동으로 플러시한다"],
            r : 4,
            img:'',
            summary:`autoFlush속성이 false이므로 자동으로 플러시 되지 않고 예외가 발생한다.`
        },
        {
            q : "http요청을 처리하기 위한 서블릿 프로그램의 작성에 관한 설명이다 잘못된 것은?",
            q1 : "",
            a : ["GET 방식의 요청을 처리하려면 서블릿 클래스에서 doGet()을 작성한다.","POST 방식의 요청을 처리하려면 서블릿 클래스에서 doPost() 를 작성한다.","요청방식에 따른 선별적 작업을 처리하기 위해 service() 메서드를 재정의해야한다","추상클래스 HttpServlet을 상속받는 서블릿 클래스를 작성한다."],
            r : 3,
            img:'',
            summary:`service() 메서드는 http요청 방식이 무엇이냐에 따라 적당한 메서드를 호출해 주는 기능을 하며 httpservlet에 이미 정의되어 있다. 이것을 재정의할 이유는 거의 없다.`
        },
        {
            q : "jsp 페이지로부터 생성되는 출력 내용은 웹 브라우저로 곧바로 전송되지 않고 버퍼링한다. 버퍼링과 관련된 설명으로 잘못된 것은?",
            q1 : "",
            a : ["버퍼링을 사용하면 데이터 전송 효율을 향상시킬 수 있다.","버퍼링을 사용하면 실행도중에 에러가 발생했을 때 버퍼를 다른 내용으로 바꿀 수 있다."," 버퍼링을 사용하면 응답 몸체를 전송한 후에도 응답 헤더를 전송할 수 있다.","에러 페이지를 사용하는 jsp 페이지의 출력 과정에 버퍼링이 필요하다"],
            r : 3,
            img:'',
            summary:`헤더 정보는 응답몸체를 전송하기 전에 전송되어야 한다.`
        },
        {
            q : "jsp 페이지 실행결과의 버퍼링에 관한 설명이다 잘못된 것은?",
            q1 : "",
            a : ["버퍼링은 클라이언트로 보낼 응답을 먼저 출력버퍼에 기록해두는 것이다.","버퍼링을 사용하면 데이터 전송 효율을 높일 수 있다.","버퍼링 중에 버퍼의 내용을 다른 내용으로 변경시킬 수 있다.","용량이 큰 버퍼가 작은 버퍼보다 항상 유리하다"],
            r : 4,
            img:'',
            summary:`버퍼의 용량은 적당해야 하며 너무 크면 자원이 낭비된다.`
        },
        {
            q : "서블릿 프로그램을 작성할때 post 방식의 요청을 처리하기 위해 구현해야하는 서비스 메서드는 무엇일까?",
            q1 : "",
            a : ["doGet()","doPost()","main()","print()"],
            r : 2,
            img:'',
            summary:`Post요청을 처리하기 위해 doPost() 를 get요청은 doGet() 을 구현해야 한다.`
        },
        {
            q : "서블릿을 이용하여 아래의 폼을 처리하고자 할때 HelloServlet 클래스에서 구현해야 하는 메서드는 무엇인가?",
            q1 : "",
            a : ["HelloServlet()","doService()","doGet()","doPost()"],
            r : 4,
            img:'',
            summary:`Post요청을 처리해야 하므로 doPost()를 구현해야함`
        },
        {
            q : "Http요청방식중 post방식에 관한 설명이 아닌 것은?",
            q1 : "",
            a : ["url에 쿼리문자열을 붙여 요청한다","html 폼을 사용할때 자주 사용된다","많은 양의 데이터를 보낼때 적당하다","Get방식에 비해 보안에 유리하다"],
            r : 1,
            img:'',
            summary:`1은 get방식의 요청을 하는 경우이다.`
        },
        {// 5장
            q : "request 내장 객체에 대한 설명이다. 잘못된 것은?",
            q1 : "",
            a : ["jsp 페이지에서 선언하지 않고 사용할 수 있는 내장객체이다","서블릿 컨테이너가 doGet()이나 doPost() 와 같은 서비스 메서드에 인자로 제고앟는 객체이다.","클라이언트에 보낼 응답을 만들때 사용하는 객체이다","Http 요청의 경우에 HttpSerletRequest 인터페이스를 구현한 객체이다."],
            r : 3,
            img:'',
            summary:`request 내장객체는 서비스 메서드에 인자로 전달되며 유형은 httpservletrequest 이다. 응답을 만들때 사용되는 내장객체는 response이다.`
        },
        {
            q : "jsp내장객체 request를 가지고 할수 없는 작업은 무엇일까?",
            q1 : "",
            a : ["클라이언트가 보낸 데이터를 읽는다","요청 헤더에 포함된 정보를 읽는다","다른 페이지로 강제 이동시킨다","연결에 사용된 포토 번호를 알아낸다"],
            r : 3,
            img:'',
            summary:`다른 페이지로 강제 이동할때는 response.sendRedirect()를 이용한다.`
        },
        {
            q : "http요청 방식중 get과 post에 관한 설명이다. 잘못된 것은?",
            q1 : "",
            a : ["get 은 url에 지정된 문서의 정보를 가져올때 사용된다.","많은 양의 사용자 데이터를 보내면 post방식을 사용해야 한다.","get방식은 단순한 질의나 검색을 할때 사용된다,","html 폼을 사용하여 데이터를 전달할 때는 post방식만 가능하다"],
            r : 4,
            img:'',
            summary:`html폼을 사용해도 get방식의 전송이 가능하다. 방법은 다음과 같다 
            <FORM ACTION = 'form_process.jsp' METHOD = 'GET'> 이때 폼에 입력된 데이터는 url 뒤에 붙어서 전달된다. `
        },
        {
            q : "캐시를 사용하여 http 요청을 처리하면 여러 장점이 있다. 잘못된 것은?",
            q1 : "",
            a : ["자주 변경되는 사이트에서 정확한 응답이 보장된다.","클라이언트에 빠른 응답을 보낼 수 있다.","서버의 부하가 줄어든다","네트워크 사용량이 감소된다"],
            r : 1,
            img:'',
            summary:`내용 변경이 빈버난 웹페이지 요청에 캐시를 사용하면 잘못된 응답이 클라이언트에 전달될 수 있다.`
        },
        {
            q : "다음과 같은 기능을 할 수 있는 내장 객체는 무엇인가?",
            q1 : "클라이언트 관련 정보 읽기, 클라이언트가 전송한 데이터 읽기, 서버 관련 정보 읽기, 속성의 처리",
            a : ["request","response","application","pageContext"],
            r : 1,
            img:'',
            summary:`pageContext와 application은 각각 페이지 영역, 애플리케이션 영역을 표현하는 내장 객체이다.`
        },
        {
            q : "response 내장 객체에 대한 설명이다. 잘못된 것은?",
            q1 : "",
            a : ["jsp페이지에서 선언 없이 사용할 수 있는 내장 객체이다.","클라이언트가 전송한 데이터를 읽을 때 사용하는 객체이다.","클라이언트에 보낼 응답을 만들때 사용하는 객체이다","http요청의 경우에 httpservletResponse 인터페이스를 구현한 객체이다."],
            r : 2,
            img:'',
            summary:`2에 해당하는 것은 request 내장객체다`
        },
        {
            q : "다음과 같은 기능을 할 수 있는 내장객체는 무엇인가?",
            q1 : "응답해더의 설정, 상태코드의 설정, 다른페이지로의 포워딩",
            a : ["request","response","application","page"],
            r : 2,
            img:'',
            summary:`application은 웹 애플리케이션에 대한 정보 관리 기능을 하는 내장 객체이며, page 내장객체는 jsp페이지를 구현한 클래스의 인스턴스이다.`
        },
        {
            q : "어떤 페이지에 대한 요청을 다른페이지로 이동시킬 수 있다. 이것에 대한 잘못된 설명은?",
            q1 : "",
            a : ["request.sendRedirect(string)을 사용한다.","이동 전에 응답헤더가 클라이언트로 이미 전송되었다면 예외가 발생한다.","표준 액션태그 <jsp:forward>를 사용한다.","sendRedirect(string)은 클라이언트에게 이동하라는 응답을 보낸다."],
            r : 1,
            img:'',
            summary:`다른 페이지로 이동시킬때는 <jsp:forward>나 response.sendRedirect(string)을 사용한다. 이동전에 이미 버퍼의 내용을 클라이언트로 전송한 적이 있다면 예외가 발생한다.`
        },
        {
            q : "밑줄 부분에 들어갈 적당한 단어를 보기에서 고르면?",
            q1 : "서블릿 컨테이너는 클라이언트의 요청 정보를 서블릿에 제공하기 위해서 _______ 객체를 만들어 서블릿 클래스의 서비스 메서드에 인자로 제공한다.",
            a : ["request","response","out","application"],
            r : 1,
            img:'',
            summary:`요청 정보를 제공하기 위한 것이므로 request 내장 객체이다. 서블릿 클래스의 서비스 메서드에 request 내장객체와 response 내장객체가 인자로 전달된다.`
        },
        {
            q : "아래 메서드와 관련이 있는 jsp 내장객체는 무엇인가?",
            q1 : "addCookie()  setStatus()   addHeader()   setContentType()   getWriter()   sendRedirect()",
            a : ["request","response","out","application"],
            r : 2,
            img:'',
            summary:`response 내장객체를 통해 위 메서드를 수행할 수 있다.`
        },
        {// 6장
            q : "jsp 내장객체에 대한 설명이다 잘못된 것은?",
            q1 : "",
            a : ["jsp페이지에서 묵시적으로 선언되어 있는 객체이다."],
            r : 0,
            img:'',
            summary:``
        },
        {
            q : "jsp내장객체에 대한 설명이다 잘못된 것은?",
            q1 : "",
            a : ["jsp페이지에서 선언하지 않고 사용할 수 있는 객체이다","스크립트릿이나 표현식에서 사용할 수 있다","pageScope, cookie, header등이 jsp 표준 내장객체에 해당한다","모든 내장객체는 사용범위(scope)가 정해져있다"],
            r : 3,
            img:'',
            summary:`cookie와 header는 jsp내장객체가 아니고 표현언어 EL 의 내장객체다`
        },
        {
            q : "하나의 웹 애플리케이션에 포함된 여러 jsp페이지 사이에 공유되는 내장 객체로 ServletContext 유형의 객체는 무엇인가?",
            q1 : "",
            a : ["pageContext","request","session","application"],
            r : 4,
            img:'',
            summary:`application 내장객체는 웹 애ㅡㄹ리케이션 전반에 걸쳐 사용되는 정보를 관리하기 위한 객체이다. web.xml 파일에 저장된 초기 설정, 웹 컨테이너에 대한 정보, 웹 애플리케이션의 폴더 정보를 읽거나 로그 메시지를 기록할때 사용한다.`
        },
        {
            q : "이 영역에 속하는 객체들은 같은 요청을 처리하는 페이지에서 사용이 가능하다. 이 영역의 객체들은 내장 객체 request에 객체 참조값이 저장되며 , 요청의 처리가 끝나면 사라진다 이것은 어떤 영역인가?",
            q1 : "",
            a : ["page 영역","request 영역","session 영역","application 영역"],
            r : 2,
            img:'',
            summary:`요청이 포워딩 되는 경우, 포워딩을 보내고 받는 두 페이지는 하나의 request 영역에 속한다.`
        },
        {
            q : "JspWriter 유형의 내장객체로 웹 브라우저에 데이터를 출력하기 위한 출력 스트링은 무엇인가?",
            q1 : "",
            a : ["response","our","config","exception"],
            r : 2,
            img:'',
            summary:`out객체를 통해 html태그, 텍스트 및 표현식의 결과를 출력할 수 있다. 또 버퍼 정보를 리턴하거나 버퍼 를 제어하는 메서드를 제공한다.`
        },
        {
            q : "그림에서 밑줄부분에 공통으로 들어가야할 jsp 내장객체는 무엇인가?",
            q1 : "",
            a : ["request","response","out","application"],
            r : 3,
            img:'jsp워크북02.JPG',
            summary:`버퍼를 다루는 메서드를 호출하는 것으로 보아 출력 스트링으로 사용되는 out객체라는걸 알수 있다.`
        },
        {
            q : "영역을 나타내는 내장객체에는 속성을 저장할 수 있다. 이것에 관한 설명으로 잘못된 것은?",
            q1 : "",
            a : ["같은 영역에 속하는 페이지 사이에서 데이터를 공유하기 위해 속성을 사용한다.","속성은 <속성이름,값>의 형태를 가진다","속성을 저장하기 위해 setAttribute(string, object) 메서드를 사용한다","서블릿 컨테이너가 속성을 지정하며 프로그램상에서는 속성을 추가할 수 없다."],
            r : 4,
            img:'',
            summary:`서블릿 컨테이너가 지정한 속성이 존재하나. 프로그램상에서도 <속성이름, 값>을 추가할 수 있다.`
        },
        {
            q : "하나의jsp 페이지에서 다른 페이지로 요청이 이동되었다고 하자, 두 페이지 간에 공유되지 않는  영역은 무엇인가?",
            q1 : "",
            a : ["page영역","request영역","session 영역","application 영역"],
            r : 1,
            img:'',
            summary:`page 영역은 하나의jsp 페이지로 국한된다.`
        },
        {
            q : "다음은 jsp 내장객체를 설명한 것이다. 잘못된 것은?",
            q1 : "",
            a : ["page: JSP페이지를 구현한 자바 클래스의 인스턴스","sesstion : HTTP 세션","application : 웹 애플리케이션을 표현(서블릿 컨텍스트)","out :요청정보를 읽이위한 입력 스트림"],
            r : 4,
            img:'',
            summary:`out은 결과를 출력하기 위한 출력 스트림이다.`
        },
        {
            q : "같은 영역안에 있는 jsp페이지들은 데이터를 공유할 수 있다. 이때 영역을 표현하는 내장객체를 사용한다. 설명이 잘못된 것은?",
            q1 : "",
            a : ["pageContext : 하나의 jsp 페이지에서 공유되는 데이터를 저장","request 한번의 요청을 처리하기 위해 사용되는 jsp페이지들에서 공유되는 데이터를 저장","session 웹 컨테이너에 존재하는 모든 jsp 페이지에서 공유할 데이터를 저장","application 하나의 웹 애플리케이션 내에서 데이터를 공유할때 사용"],
            r : 4,
            img:'',
            summary:`session 객체는 같은 세션에 포함된 페이지들 사이에서 공유된다.`
        },
        {
            q : "jsp페이지 a에서 <jsp:include> 액션을 이용해 jsp페이지 b를 포함시킨 후 요청이 처리되었다. 페이지 a와 페이지 b사이에서 공유될 수 없는 내장객체는 무엇인가",
            q1 : "",
            a : ["pageContext","request","session","application"],
            r : 1,
            img:'',
            summary:`a 페이지와 b페이지는 다른 페이지다. pageContex는 page 영역을 표현하는 내장객체로 페이지별로 각각 존재한다. 그러나 두 페이지에서 사용하는 request 내장 객체는 동일한 객체이다.`
        },
        {
            q : "다음 설명에서 이것에 해당하는 영역은 무엇인가?",
            q1 : "",
            a : ["page 영역","request 영역","session 영역","application 영역"],
            r : 3,
            img:'jsp워크북03.JPG',
            summary:`세션 영역에 속하는 객체들의 참조값은 내장 객체 session에 저장되며, 이 객체들은 세션이 종료되면 사라진다. `
        },
        {// 7장
            q : "include 지시어와 <jsp:include> 액션 태그를 설명한 것이다. 잘못된 것은?",
            q1 : "",
            a : ["include 지시어는 파일의 소스나 텍스트를 포함시킨다","<jsp:include> 는 페이지의 실행결과를 포함시킨다.","jsp 페이지의 콘텐츠를 재사용하기 위한 방법이다","둘은 동알한 효과를 가진다."],
            r : 4,
            img:'',
            summary:`include 지시어는 서블릿 코드로 번역되기 전에 수행되며, <jsp:include>는 실행시점에서 수행된다. include 지시어를 정적 include, <jsp:include>를 동적 include 라고 한다. `
        },
        {
            q : "<jsp:include> 액션태그에 관한 설명으로 잘못된 것은?",
            q1 : "",
            a : ["jsp 페이지의 맨 앞 또는 맨 뒤에만 지정된 페이지를 포함시킬 수 있다","<jsp:param> 태그를 서브 요소로 사용하면 included 페이지를 요청할 때 파라미터를 제공할 수 있다.","속성 flush의 값이 true이면 included페이지를 포함시키기 전에 출력 버퍼의 내용을 클라이언트로 전송한다. ","including 페이지와 included 페이지는 같은 request 객체를 공유한다."],
            r : 1,
            img:'',
            summary:`web.xml에서  <include-prelude>와  <include-coda>를 이용하면 jsp페이지의 앞이나 뒤에 코드를 자동으로 삽입할 수 있다.`
        },
        {
            q : "<%@ include ...%> 에 관한 설명이다. 잘못된 것은?",
            q1 : "",
            a : ["해당 위치에 텍스트나 코드를 포함시키는 것이다.","파일의 지정을 위해 file 속성을 가진다.","요청을 할 때 필요한 파라미터를 넘겨주기 위한 것이다","모듈화된 jsp 페이지를 만들 수 있게 한다."],
            r : 3,
            img:'',
            summary:`3은 <jsp:param>태그에 해당한다. 참고로 includedortusdms page속성을 사용한다.`
        },
        {
            q : "<jsp:param> 태그에 관한 설명이다. 잘못된 것은?",
            q1 : "",
            a : ["<jsp:include>나 <jsp:forward> 액션의 서브 요소로 사용된다.","요청을 할 때 추가적으로 데이터를 넘겨주기 위한 것이다",'태그에서 지정한 파라미터는 URL 뒤에 쿼리 문자열로 추가되어 전달된다.',"기존에 같은 이름의 파라미터가 존재한다면 <jsp:param> 태그에 지정된 파라미터는 무시된다."],
            r : 4,
            img:'',
            summary:`<jsp:param> 태그에 지정된 파라미터는 기존의 파라미터보다 우선시 된다.`
        },
        {
            q : "<jsp:forward> 액션에 관한 설명이다 잘못된 것은?",
            q1 : "",
            a : ["현재 페이지의 실행은 종료되고 새로운 페이지로 이동이 일어난다","<jsp:forward>액션을 사용하려면 버퍼링을 사용해야 한다","포워딩이 일어나기 전에 버퍼의 내용이 클라이언트로 전송된다","<jsp:param> 태그를 사용하여 새로운 페이지에 데이터를 전달할 수 있다."],
            r : 3,
            img:'',
            summary:`<jsp:forward> 액션을 사용하려면 버퍼링을 사용해야 한다. 포워딩이 일어나기 전에 버퍼에 있던 내용은 삭제되며 . 만약 포워딩전에 클라이언트로 전송된 응답이 있었다면 예외가 발생한다`
        },
        {
            q : "많은 jsp 페이지에서 자주 사용되는 메서드를 정의한 별도의 페이지가 존재한다. 이것을 사용하려면 무엇을 이용해야 하는가",
            q1 : "",
            a : ["include지시어","prelude와 coda","<jsp:include> 액션","<jsp:forward> 액션"],
            r : 1,
            img:'',
            summary:`소스를 포함하면 되므로 include 지시어를 사용한다. prelude와 coda 방법은 include 지시어와 같은 'static include' 방법이나 web.xml 파일에 설정된 내용을 이용해 자동으로 처리되므로 'implicit include' 라고도 한다.`
        },
        {
            q : "jsp 페이지 실행결과의 버퍼링에 관한 설명이다. 잘못된 것은?",
            q1 : "",
            a : ["출력 결과를 클라이언트에 보내기 전에 버퍼에 기록하는 것이다."," 버퍼링을 사용하지 않으려면 page 지시어에서 autoFlush 속성을 'false'로 한다","<jsp:forward> 기능을 사용하는 경우 버퍼링을 해야한다","오류 페이지를 사용하는 경우 버퍼링이 필요하다"],
            r : 2,
            img:'',
            summary:`버퍼링을 사용하지 않으려면 page지시어에서 buffer속성을 'none'로 한다.`
        },
        {
            q : "아래 소스를 보면 from.jsp에서 to.jsp로 포워딩이 일어난다. from.jsp를 요청했을때 최종실행결과를 보기에서 고르시오",
            q1 : "",
            a : ["여기는 from.jsp페이지 앞 , 여기는 to.jsp 페이지","여기는 from.jsp 페이지의 앞 , 여기는 to.jsp페이지, 여기는 from.jsp 페이지의 뒤","여기는 to.jsp 페이지","여기는 to.jsp페이지, 여기는 from.jsp 페이지의 뒤"],
            r : 3,
            img:'jsp워크북04.JPG',
            summary:`<jsp:forward> 액션 태그를 만나면 그때까지 출력 버퍼에 저장된 내용은 지워지며 from.jsp는 종료되고 to.jsp로 이동된다 따라서  to.jsp의 결과만 출력된다. 만약 포워딩전에 from.jsp의 출력이 이미 클라이언트로 전송되었다면 (버퍼링을 하지 않고 결과가 만들어진 경우 또는 버퍼가 플러시 된 적이 있는 경우) 예외가 발생한다.`
        },
        {//8장
            q : "쿠키에 대한 설명으로 잘못된 것은?",
            q1 : "",
            a : ["서버가 만들어 클라이언트로 보내는 데이터다","클라이언트에서 서버로 보내는 일련의 요청에서 사용자의 상태를 관리하기 위한 것이다","http 프로토콜의 stateless 특성을 보완하기 위한 방법이다.","서버컴퓨터에 저장되는 데이터이다."],
            r : 4,
            img:'',
            summary:`쿠키는 클라이언트 컴퓨터에 저장되었다가. 클라이언트가 같은 서버에 추가요청을 보낼 때 쿠키를 함께 전송한다.`
        },
        {
            q : "쿠키에 대한 일반적 설명이다. 잘못된 것은?",
            q1 : "",
            a : ["웹 서버가 클라이언트로 보내는 작은 크기의 텍스트 데이터이다.","웹 사이트를 다시 방문할때 웹 브라우저는 저장해두었던 쿠키를 전송한다","쿠키는 http 요청 헤더 또는 응답헤더에 담겨 전송된다","웹 브라우저가 저장할 수 있는 쿠키의 개수와 크기는 제한이 없다"],
            r : 4,
            img:'',
            summary:`보통 웹 브라우저 웹서버당 20개의 쿠키, 총 500개의 쿠키를 지원하며 , 쿠키의 크기를 4kb  이하로 제한한다.`
        },
        {
            q : "다음 코드에 관한 설명으로 잘못된 것은?",
            q1 : "",
            a : ["쿠키 객체를 생성한다","쿠키를 클라이언트로 보낸다","같은 이름의 쿠키가 존재한다면 쿠키의 값을 변경하는 것이다","쿠키의 유효시간을 0으로 지정한다"],
            r : 4,
            img:'jsp워크북05.JPG',
            summary:`쿠키의 유효시간을 지정하라면 cookie.setMaxAge(3600) 과 같이 한다. 명시적으로 유효시간이 지정되지 않았다면 쿠키의 유효시간은 -1이다`
        },
        {
            q : "jsp 페이지에서 클라이언트가 보낸 쿠키를 읽고자 한다 올바른 것은?",
            q1 : "",
            a : ["request.getCookies()","request.getCookie()","response.addCookies()","response.addCookie()"],
            r : 1,
            img:'',
            summary:`서버에서 클라이언트가 쿠키를 읽을때는 request.getCookies()를 이용한다. 이때 cookie의 객체들로 구성된 배열이 리턴된다. 서버가 클라이언트로 쿠키를 보낼때는 response.addCookies()를 사용한다.`
        },
        {
            q : "쿠키의 유효시간에 관한 설명이다. 잘못된 것은>",
            q1 : "",
            a : ["클라이언트 컴퓨터에서 쿠키가 유지되는 기간을 말한다","쿠키에 유효시간을 지정하지 않으면 웹브라우저가 종료될때 삭제된다.","쿠키의 유효시간을 0으로 하는 것은 기존 쿠키의 삭제를 의미한다.","쿠키이 유효시간이 음수라면 영구적으로 보관된다/"],
            r : 4,
            img:'',
            summary:`쿠키의 유효시간이 음수인 것은 유효시간을 지정하지 않은 것과 같다. 따라서 웹 브라우저가 종료될때까지만 유지된다.`
        },
        {
            q : "쿠키를 사용하여 로그인을 처리하는 jsp페이지를 구현했다. 필요한 작업이 아닌것은?",
            q1 : "",
            a : ["클라이언트가 보낸 아이디와 암호를 읽는다.","데이터베이스를 이용해 회원 여부를 확인한다.","session 객체에 로그인 속성을 추가한다","회원인 경우 로그인 정보를 가진 쿠키를 만들어 클라이언트로 보낸다"],
            r :3,
            img:'',
            summary:`쿠키를 사용하지 않고 세션을 사용하는 방법도 있다. 이때 session 객체를 이용한다.`
        },
        {//9장
            q : "세션에 대한 일반적 설명이다. 잘못된 것은?",
            q1 : "",
            a : ["하나의 웹 브라우저에서 들어오는 연관된 일련의 요청을 처리하기 위해 세션을 사용한다.","웹 브라우저당 1개의 세션이 유지된다.","세션의 기본 유효시간은 설정에 따라 달라질 수 있다.","웹 브라우저를 종료하더라도 세션은 유효시간 동안 유지된다."],
            r : 4,
            img:'',
            summary:`기본적으로 사용자가 브라우저를 종료하면 세션이 종료된다.`
        },
        {
            q : "session 객체의 속성을 추가하기 위한 메서드는 무엇인가?",
            q1 : "",
            a : ["getAtrribute(string, name)","getAttributeNames()","setAttribute(string name, object value)","setMaxInactiveInterval(int interval)"],
            r : 3,
            img:'',
            summary:`다른 내장객체와 마찬가지고 setAttribute(string name, object value)를 사용한다. 첫번째 인자는 속성의 이름이고 문자열 유형이며, 두번째 인자는 속성의 값으로 object 유형이다.`
        },
        {
            q : "jsp 내장객체 session이 제공하는 메서드에 관한 설명이다. 잘못된 것은?",
            q1 : "",
            a : ["getCreationTime() : 세션이 생성된 시간을 리턴","getAttribute(string) : 세션에 저장된 1개 속성의 값을 객체로 리턴","setMaxinactiveInterval(int)세선에 저장된 속성을 삭제","invalidate() : 세션을 삭제"],
            r : 3,
            img:'',
            summary:`setMaxinactiveInterval(int) 는 세션의 유효시간(초단위)를 설정하기 위한 메서드이다.`
        },
        {
            q : "세션의 유효시간이란 무엇인가?",
            q1 : "",
            a : ["세션이 처음 생성되어 삭제될때까지의 기간이다.","클라이언트의 마지막 요청 후에 추가 요청이 없어도 세션이 유지될 수 있는 기간이다.","세션이 생성된 시간이다","세션이 삭제된 후 다시 만들어질 때까지의 기간이다"],
            r : 2,
            img:'',
            summary:`세션의 유효시간이 1분이라면 마지막 요청 후 1분 이내에 추가요청이 있어야 세션이 유지된다.`
        },
        {
            q : "세션이 만들어지는 시점은 클라이언트가 서버에 최초로 접속할 때이다. 그러면세션이 삭제되는 경우에 해당하지 않은 것은?",
            q1 : "",
            a : ["클라이언트가 웹 브라우저를 종료한다","세션의 유효시간동안 클라이언트의 추가 요청이 없었다","서버 측 jsp 페이지에서 session.invalidate() 를 실행하였다","서버 측 jsp 페이지에서 session 객체에  저장된 모든 속성을 삭제하였다."],
            r : 4,
            img:'',
            summary:`웹 브라우저를 종료하지 않더라도 2번이나 3번의 경우 가 생기면 세션이 종료될 수 있다.`
        },
        {
            q : "세션을 관리하기 위해 jsp 페이지에서 사용되는 내장 객체 seesion 의 유형은 무엇인가?",
            q1 : "",
            a : ["session","javax.servlet.http","httprequest","httpsession"],
            r : 4,
            img:'',
            summary:`세션은 http 프로토콜을 사용할 때 필요한 것이며, 세션의 관리를 위해 사용되는 jsp 내장객체 session의 유형은 httpsession이다. httpsession 인터페이스는 javax servlet.http페키지에 포함되어 있다.`
        },
        {
            q : "세션을 사용하여 로그인을 처리하는 jsp 페이지를 구현하였다. 필요한 작업이 아닌 것은?",
            q1 : "",
            a : ["클라이언트가 보낸 아이디와 암호를 읽는다","데이터베이스를 이용해 회원 여부를 확인한다","session 객체에 사용자를 확인할 수 있도록 속성을 추가한다","회원인 경우 로그인 정보를 가진 쿠키를 만들어 클라이언트로 보낸다"],
            r : 4,
            img:'',
            summary:`세션을 사용하여 로그인을 처리할때는 사용자 정보를 session 객체에 저장하여 쿠키를 만들 필요는 없다.`
        },
        {
            q : "쿠키와 세션을 비교할때 잘못된 설명은?",
            q1 : "",
            a : ["쿠키를 사용하는 것이 보안에 좋다","쿠키 데이터는 클라이언트 컴퓨터에 저장된다","내장객체 session에 여러 개의 객체를 저장할 수 있다","쿠키를 사용하면 저장할 수 있는 데이터의 크기에 제한이 있다"],
            r : 1,
            img:'',
            summary:`상대적으로 세션을 사용하는것이 보안에 유리하다.`
        },
        {//10강
            q : "자바빈에 관한 설명으로 잘못된 것은?",
            q1 : "",
            a : ["사용자가 정의한 자바 클래스로 jsp페이지에서 사용될 수 있다.","별도의 클래스 파일로 존재한다","프레젠테이션 로직을 구현한 것이다","재사용 가능한 컴포넌트이다"],
            r : 3,
            img:'',
            summary:`자바빈은 비즈니스 로직을 구현하기 위한 것이다. 자바빈을 사용하면 jsp페이지에서 자바 코드의 사용을 줄일 수 있고 프레젠테이션 로직과 비즈니스 로직의 분리가 분명해진다.`
        },
        {
            q : "자바빈 클래스에 String 유형의 name 속성이 존재한다고 할때, 이것의 getter 메서드로 적당한 것은?",
            q1 : "",
            a : ["public void getName(string name) {this.name = name;}","public String getName(string name) {this.name = name; return this.name;}","public String getName() {return name;}","public void setNanme(String name) {this.name =name;}"],
            r : 3,
            img:'',
            summary:`getter 메서드는 속성 값을 리턴하는 메서드로 파라미터가 없고 해당 속성의 데이터 타입과 일치하는 리턴타입을 가져야 한다.`
        },
        {
            q : "다음 액션에 관한 설명으로 적당하지 않은 것은?",
            q1 : "<jsp:useBean id=\"memberinfo\" class=\"member.MemberInfo\" scope=\"page\" \/>",
            a : ["member.MemberInfo 는 클래스의 이름에 해당한다.","memberinfo라는 이름의 객체가 page 영역에 존재하지 않으면 자바빈 객체를 생성한다","객체가 가지고 있는 memberinfo 속성에 scope 를 지정하는 것이다","지정된 범위가 page 이므로 해당 페이지에서만 사용할 수 있다."],
            r : 3,
            img:'',
            summary:`member.Memberinfo 유형으로 memberinfo라는 이름의 자바빈 객체를 생성하고 그것의 사용 범위를 해당 페이지로 국한하는 액션이다.`
        },
        {
            q : "다음 액션에 관한 설명으로 잘못된 것은?",
            q1 : "<jsp : useBean id=\"meminfo\" class=\"member.Customer\" scope=\"request\" \/>",
            a : ["이름이 meminfo인 자바빈 객체를 사용하겠다는 선언이다","객체의 유형은 member패키지에 있는 Customer 클래스이다.","이 객체는 해당 페이지와 같은 request 영역에 있는 페이지들에서 접근 가능하다","웹 컨테이너가 종료될 때까지 이 객체는 내장객체처럼 사용될 수 있다."],
            r : 4,
            img:'',
            summary:`자바빈 객체의 사용범위가 request 영역이므로 요청의 처리가 끝나면 객체도 사라진다`
        },
        {
            q : "<jsp: setProperty> 와 <jsp:getProperty>에 관한 정확한 설명은 무엇인가?",
            q1 : "",
            a : ["요청을 보낼때 필요한 파라미터 값을 저장하거나 읽기 위한 것이다","세션에 정보를 저장하거나 읽기 위한 것이다","자바빈 객체의 속성값을 설정하거나 읽어오기 이한 액션 태그이다","클라이언트의 상태 관리를 위한 태그이다"],
            r : 3,
            img:'',
            summary:`<jsp : setProperty> 와 <jsp:getProperty> 액션태그는 <jsp:useBean> 액션태그와 함께 사용된다`
        },
        {
            q : "다음 코드와 동일한 의미를 가지는 것은 무엇인가?",
            q1 : "<% out.print(memberinfo.getName()); %>",
            a : ["<jsp:getProperty id=\"memberinfo\" property=\"name\" \/>","<jsp:getProperty name=\"memberinfo\" property=\"name\" \/>","<jsp:setProperty id=\"memberinfo\" property=\"name\" \/>","<jsp:setProperty name=\"memberinfo\" property=\"name\" \/>"],
            r : 2,
            img:'',
            summary:`자바빈 객체의 속성 값을 읽어 출력하는 코드이다 <jsp:getProperty name=\"자바빈이름\" property=\"속성이름 \" \/> 액션태그를 사용할 수도 있다. <jsp:getProperty> 액션태그는 속성값을 읽어 String으로 변환한 후 out 객체에 전달하여 출력시키는 기능을 한다`
        },
        {
            q : "다음 액션과 같은 의미를 가지는 스크립트 요소는 보기에서 무엇인가?",
            q1 : "<jsp:setProperty name=\"meminfo\" property=\"age\" value=\"10\" \/>",
            a : ["<% memberinfo.setName(\"age\")\; %>","<% meminfo.setAge(10)\; %>","<% out.printin(meminfo.getName())\; %>","<%= meminfo.getName()\;%>"],
            r : 2,
            img:'',
            summary:`이름이 meminfo인 객체의 age속성을 10으로 변경하는 것이다.`
        },
        {
            q : "다음 코드와 동일한 의미를 가지는 것은 무엇인가?",
            q1 : "",
            a : ["1","2","3","4"],
            r : 4,
            img:'jsp워크북06.JPG',
            summary:`이름이 title 인 파라미터의 값을 읽어서 그것을 자바빈 객체가 가지는 title 속성의 값으로 설정하는 코드이다 . 4번은 <jsp:setProperty name=\"boardData\" property=\"title\" param=\"title\" \/>과 같은 의미이다.`
        },
        {//11장
            q : "아래는 테이블 생성을 위한 SQL 명령을 보여준다 이때 id 필드는 레코드를 유일하게 식별하기 위한 필드로 테이블에서 유일하다 빈칸에 들어가야할 내용은?",
            q1 : "",
            a : ["default","not null","key","primary key"],
            r : 4,
            img:'jsp워크북07.JPG',
            summary:`테이블에서 primary key는 하나만 존재하며 레코드마다 구별되는 다른 값을 가져야 한다. not null은 값을 가져야 한다는 의미이다   not null 이 주어지지 않으면 레코드를 삽입하거나 변경할때 해당 필드에 값을 지정하지 않아도 된다.`
        },
        {
            q : "memberxpdlqmfdptj addressrk Seoul인 회원을 검색하는 MariaDB명령은 무엇인가?",
            q1 : "",
            a : ["select * from member where address=\"Seoul\"\;","select into member values('Seoul')\;","update member set address='Seoul'\;","delete from member where address='Seoul'\;"],
            r : 1,
            img:'',
            summary:`3번은 모든 레코드의 address 필드를 Seoul로 변경하는 것이다 . 4번은 address가 Seoul인 모든 레코드를 삭제하는것이다  2번은 잘못된 명령이다.`
        },
        {
            q : "JSP 페이지에서 DBMS와 연동하여 SQL 질의를 실행하는 프로그램을 작성하려고 한다 올바른 절차는?",
            q1 : "",
            a : ["ㄱ->ㄴ->ㄷ->ㄹ->ㅁ->ㅂ","ㄱ->ㄷ->ㄴ->ㅁ->ㄹ->ㅂ","ㄴ->ㄱ->ㄷ->ㄹ->ㅂ->ㅁ","ㄱ->ㄷ->ㄴ->ㄹ->ㅁ->ㅂ"],
            r : 2,
            img:'jsp워크북08.JPG',
            summary:`DBMS와 연결되고 Connection 객체가 생성되면, connection 객체를 이용하여 statement 객체 생성, statement 객체를 이용하여 SQL  질의를 실행, (ResultSet) 객체 반화느 ResultSet객체를 가지고 결과를 처리한다`
        },
        {
            q : "SQL 구문 가운데 insert, delete와 update를 실행하려고 한다. Statement 인터페이스에서 어떤 메서드를 사용해야 하는가?",
            q1 : "",
            a : ["ResultSet executeQuery(String sql)","ResultSet getResultSet()","int executeUpdate()","int executeUpdate(string sql)"],
            r : 4,
            img:'',
            summary:`int executeUpdate(string sql)을 사용하여 sql구문에 의해 영향을 받는 레코드의 개수가 리턴된다 .  preparedstatement를 사용한다면 3번 메서드를 호출한다.`
        },
        {
            q : "JDBC를 이용한 데이터베이스 프로그래밍에서 Select  구문을 실행하려고 한다. Statement 인터페이스에서 어떤 메서드를 사용해야 하는가",
            q1 : "",
            a : ["ResultSet executeQuery()","ResultSet executeQuery(string sql)","ResultSet getResultSet()","int executeUpdate(string sql)"],
            r : 2,
            img:'',
            summary:`ResultSet executeQuery(string sql)로 selectㅜ 구문을 실행하면 검색 결과가 리턴되며 ResultSet유형의 객체에 저장된다. PreparedStatement를 사용한다면 1번 메서드를 호출한다.`
        },
        {
            q : "Statement나 PreparedStatement 인터페이스의 executeQuery() 메서드로 SQL 구문을 실행시킬때 리턴되는 것은 무엇인가?",
            q1 : "",
            a : ["Connection 객체 ","ResultSet객체","Statement객체","PreparedStatement 객체"],
            r : 2,
            img:'',
            summary:`executeQuery() 메서드는 select구문을 실행시킬때 사용된다. 리턴되는 결과는 하나의 테이블로 간주될 수 있으며 ResultSet객체로 다루어진다.`
        },
        {
            q : "다음은 ResultSet 객체인 rs가 표현하는 테이블이다. 여기서 id 필드는 int 형이고 name과 phone필드는 String형이다. 커서가 가리키는 레코드에서 첫번째 필드의 값을 리턴하는 것은 무엇인가>",
            q1 : "",
            a : ["rs.getInt(0)","rs.getInt(1)","rs.getString('id')","rs.select('id')"],
            r : 2,
            img:'jsp워크북09.JPG',
            summary:`첫 필드는 id이며 int값을 가지므로 rs.getInt(1) 또는 rs.getint('id')를 호출하면 된다. 0이 아니고 1임에 유의한다.`
        },
        {
            q : "데이터베이스 사용이 끝나고 리소스를 해체할때 어떤 순서로 리소스를 해체하는 것이 좋은가?",
            q1 : "",
            a : ["Connection -> Statement -> ResultSet","ResultSet->Connection","ResultSet->Statement->Connection","Statement->ResultSet->Connection"],
            r : 3,
            img:'',
            summary:`해체 순서는 생성된 순서와 반대로 한다.  실제로 statement 객체의 메서드 실행이 성공하지 못하면 resultset 객체가 생성될 수 없으며, connection 객체가 만들어지지 못하면 statement 객체도 생성될 수 없다.`
        },
        {//12강
            q : "다음 클래스 정의에서 멤버 변수 id의 getter메서드를 추가한다면 어떻게 작성해야 하는가?",
            q1 : "",
            a : ["1","2","3","4"],
            r : 1,
            img:'jsp워크북10.JPG',
            summary:`getter는 멤버 변수에 저장되어 있는 값을 리턴하는 메서드이다.`
        },
        {
            q : "앞 문제에서 나온 클래스에서 맴버 변수 name의 setter 메서드를 추가한다면 어떻게 작성해야 한느가?",
            q1 : "",
            a : ["public int getName(){return id;}","public void getName(int id){this.id = id}","public int setName(int id){return id;}","public void setName(int id){this.id = id;}"],
            r : 4,
            img:'',
            summary:`setter는 멤버 변수의 값을 변경하는 메서드로서 멤버 변수의 자료형으로 인자가 필요하며 값을 리턴할 필요가 없다.`
        },
        {
            q : "",
            q1 : "",
            a : [""],
            r : 0,
            img:'jsp워크북11.JPG',
            summary:``
        },
        {
            q : "다음 selectOne() 메서드의 정의이다. selectOne() 메서드는 int형 매개변수로 id를 받아 member 테이블에서 id 필드의 값이 매개변수의 값과 같은 레코드를 찾아서 리턴하는 기능을 수행한다 밑줄친 ㄱ 부분에 알맞은 내용은?",
            q1 : "",
            a : ["rs.close()","rs.isFirst()","rs.previous();","rs.next();"],
            r : 4,
            img:'jsp워크북12.JPG',
            summary:`next() 를 처음 호출하면 ResultSet객체의 커서가 첫번째 레코드를 가리킨다. first()를 호출할 수도 있다.`
        },
        {
            q : "위 문제에서 밑줄친 ㄴ 부분에 들어갈수 없는 내용은?",
            q1 : "",
            a : ["id","\"id\"","rs.getInt(1)","rs.getInt(\"id\")"],
            r : 2,
            img:'',
            summary:`member테이블에 있는 레코드 중에서 id필드의 값과 매개변수 id의 값이 같은 레코드가 ResultSet객체에 들어간다. 그리고 memberDTO 객체의 속성을 레코드에서 상용하는 필드의 값으로 설정한다. rs.getint(1)과 rs.getint('id')의 값은 같으며 이것은 매개변수 id의 값이기도 하다.`
        },
        {
            q : "다음은 member테이블에서 한 개의 레코드를 삭제하는 기능을 하는 jsp페이지의 일부이다.  이때 삭제할 레코드의 id 필드의 값은 요청 파라미터로 넘겨받아 사용한다. 밑줄친 부분에 들어가야 할 내용은?",
            q1 : "",
            a : ["1","2","3","4"],
            r : 1,
            img:'jsp워크북13.JPG',
            summary:`try-with-resources 구문을 사용하면 예외발생 여부와 상관없이 사용된 데이터베이스 자원을 자동으로 해제해준다. 밑줄친 부분에는 순서대로 onnection 객체와 statement 객체를 생성하는 문장이 필요하다`
        },
        {
            q : "위 문제의 기능을 MemberDao클래스가 제공하는 기능을 사용하여 다시 작성하려고 한다. 밑줄 부분에 들어갈 내용은?",
            q1 : "",
            a : ["1","2","3","4"],
            r : 3,
            img:'jsp워크북14.JPG',
            summary:`deleteOne(int)의 인자로 int 값, 즉 삭제할 레코드의 id 필드값이 주어져야 한다. 따라서 id란 이름의 파라미터로 넘어오는 문자열 값을 읽은 후 int값으로 형변환을 해야한다.`
        },
        {//13-1장
            q : "표현언어의 사용에 관한 설명이다. 잘못된 것은?",
            q1 : "",
            a : ["간결한 형태로 수식을 표현할 수 있게 한다","태그의 속성 값을 지정할 때 표현 언어 수식을 사용한다.","표현식을 대신하여 자주 사용된다","스크립트릿 내부에 표현언어 수식을 사용할 수 있다."],
            r : 4,
            img:'',
            summary:`표현언어로 작성된 수식은 스크립트 요소 밖에서 사용해야 한다. 표현언어 수식은 태그의 속성 값을 지정할 때 사용할 수 있으며 , 또한 템플릿 데이터가 위치하는 곳에서 사용할 수 있다.`
        },
        {
            q : "표현언어에 관한 설명으로 잘못된 것은?",
            q1 : "",
            a : ["스크립트릿, 표현식, 선언부에서는 사용할 수 없다.","표현언어 수식을 사용하여 태그의 속성값을 지정할 수 있다.","${수식}과 같은 형태이다","표현언어의 내장 객체와 jsp 의 내장 객체는 동일하다"],
            r : 4,
            img:'',
            summary:`표현언어의 내장 객체는 jsp 내장객체와 별도로 존재한다./`
        },
        {
            q : "표현언어에서 제공하는 내장객체 param 을 이용하여 다음과 같은 수식을 작성하였다. 이것과 의미가 다르게 잘못 작성된 것을 고르시오",
            q1 : "${param.code}",
            a : ["${param[code]","${param['code']}","${param[\"code\"}","<%= request.getParameter(\"code\") %>"],
            r : 1,
            img:'',
            summary:`2번과 3번은 같은 의미의 표현이다. 4번은 표현식을 이용하여 작성된 것이다 param 내장 객체는 map유형이며 \$\{param.속성이름 \}의 결과는 param이 가지고 있는 해당 속성의 값이 된다.`
        },
        {
            q : "다음과 같이 쿠키가 생성되어 클라이언트로 전송된 후 , 이 쿠키가 다시 서버로 전송되었다고 하자. 템플릿 데이터가 위치하는 곳에 보기 1~4의 수식이 위치했을 때 결과가 Jimmy 가 되는것은 무엇인가?",
            q1 : "",
            a : ["<%= cookie.firstname.value %>","${cookie.name}","${cookie.firstname}","${cookie.firstname.value}"],
            r : 4,
            img:'jsp워크북15.JPG',
            summary:`3번을 정답이라 생각할수 있으나 3번의 결과는 문자열이 아니라 cookie 객체가 된다.   cookie 객체는 name속성과 value 속성을 가지고 있다.  따라서 4번이 정답이다     \$\{cookie.firstname.name\}의 결과는 firstname 이다`
        },
        {
            q : "보기 1~4 의 수식이 아래 프로그램의 밑줄친 부분에 들어갈때 결과가 다른 하나는?",
            q1 : "",
            a : ["${score1.kor}","${pageScope.score1.kor}","<%= score1.getKor() %>","<% score1.getKor() %>"],
            r : 4,
            img:'jsp워크북16.JPG',
            summary:`2번 라인에서 자바빈 객체 score1의 범위가 page 임으로 1번과 2번은 같은것이고, 4번에서 출력되는 것은 없으며 3번은 <% out.print(score1.getKor*());%> 과 같다`
        },
        {
            q : "아래 페이지를 실행하면 폼을 이용해 name 파라미터 값을 post 방식으로 자기 자신에게 전송한다. 표현언어를 사용할 때마다 밑줄 친 부분에 들어갈 적당한 내용은?",
            q1 : "",
            a : ["${name}","${param.name}","${requestScope.name}","<%= request.getParameter(\"name\") %>"],
            r : 2,
            img:'jsp워크북17.JPG',
            summary:`표현언어의 내장객체인 param을 이용하면 된다. 4번을 사용할수도 있으나 표현언어 수식이 아니고 jsp의 표현식이다.`
        },
        {//13-2
            q : "JSTL에 관한 설명으로 잘못된 것은?",
            q1 : "",
            a : ["표준화된 커스텀 태그들의 집합이다.","많은 JSP 프로그램에서 자주 사용되는 기능들을 태그로 구현하였다","JSP페이지에서 사용하려면 taglib 지시어를 사용해야한다","JSTL이 제공하는 태그를 사용하려면 접두어로 jsp를 사용해야 한다"],
            r : 4,
            img:'',
            summary:`<jsp:include,....> 와 같이 접두어가 jsp인 태그는 표준 태그이다. JSTL에서 제공되는 커스텀 태그의 접두어는 taglib 지시어에 나타난다.`
        },
        {
            q : "<c:forEach> 태그를 다음과 같이 사용하였다. 이것에 대한 설명으로 잘못된 것은?",
            q1 : "<c:forEach var=\"m\" items=\"${map}\">......</c:forEach>",
            a : ["Map이나 List 객체가 가지고 있는 원소들을 반복적으로 처리할 수 있다.","배열이 가지고 있는 원소들을 반복적으로 처리할 수 있다","<c:forEach>태그에 delims 속성을 추가하면 문자열도 분리하여 처리할 수 있다.","루프를 한번 돌때마다 원소를 하나씩 가져와 변수 m에 저장한다,"],
            r : 3,
            img:'',
            summary:`<c:forEach> 태그에는 delims 속성을 사용할 수 없다  <c:forEach> 태그의 items 속성에 문자열이 주어지면 콤마(,)로 원소들을 구분하여 처리한다.`
        },
        {
            q : "아래 코드에서 prop은 Map 유형의 객체이다. 밑줄 부분에 나와야 하는 것은 무엇인가?",
            q1 : "",
            a : ["\"prop\"","${prop}","${\"prop\"}","\"<%= prop %>\""],
            r : 4,
            img:'jsp워크북18.JPG',
            summary:`속성의 값은 항상 따옴표로 묶어야 한다. 또 target 속성값으로 객체의 레퍼런스가 주어져야 한다. 따라서 4번이 정답이다. 표현언어 수식을 사용한다면 \"\$\{prop\}\"도 답이 될 수 있다.`
        },
        { 
            q : "prop이 map 유형의 객체일때 prop이 가지고 있는., 이름이 host 인 속성의 값을 출력하는 문장은 무엇인가?",
            q1 : "",
            a : ["${prop}","${prop.host}","<%= prop.getHost(\"host\") %>","<%= prop.getHost() %>"],
            r : 2,
            img:'',
            summary:`map 유형 또는 자바빈 객체인 경우 속성의 값을 출력하려면 \$\{ 변수.속성이름 \}을 사용하면 된다. 표현식을 사용한다면 map유형인지 자바빈 객체인지에 따라 차이가 난다  map유형의경우는 get(\"속성이름\")을 사용하면 된다. 즉 <%=prop.get(\"host\")%> 도 답이 가능하다.`
        },
        { 
            q : "다음 태그의 의미를 정확히 설명한 것은 무엇인가?",
            q1 : "<c:import url=\"http://www.daum.net\" var=\"result\"></c:import>",
            a : ["http://www.daum.net 의 내용이 브라우저에 출력된다","http://www.daum.net으로 강제이동된다","변수 result에 http://www.daum.net의 내용이 문자열로 저장된다","변수 result 에 문자열 \"http://www.daum.net\"이 저장된다."],
            r : 3,
            img:'',
            summary:`속성 var 이 없다면 1번이 정답이나 var 이 존재하면 해당 변수에 지정된 페이지의 내용이 저장된다.`
        },
        { 
            q : "다음을 실행시켰을때 ㄱ과 ㄴ에 들어가는 결과를 각각 무엇일까?",
            q1 : "",
            a : ["jimmy, jimmy","jimmy, james","james, jimmy","james, jimmy"],
            r : 2,
            img:'jsp워크북19.JPG',
            summary:`<c:set var=\"bestMember\" value=\"#{member.name}\" /} 과 같이 표현언어 변수의 값을 설정하면. 값이 즉시 계산되지 않고 \$\{bestMember\}가 사용될때 member.name의, 값이 계산된다.`
        },
        { 
            q : "JSTL을 이용하면 표현언어에서 함수를 사용할 수 있다. 이때 다음과 같은 taglib 지시어를 추가해야 한다. ㄱ 과 ㄴ 에 들어갈 내용은 각각 무엇인가?",
            q1 : "<%@ taglib prefix=\"( ㄱ ) \" uri=\"( ㄴ )\" %>",
            a : ["fmt, http://java.sun.com/jsp/jstl/fmt","sql, http://java.sun.com/jsp/jstl/sql","c, http://java.sun.com/jsp/core","fn, http://java.sun.com/jsp/jstl/functions"],
            r : 4,
            img:'',
            summary:`1,2,3번은 각각 순서대로 국제화, 데이터베이스, 코어 영역의 라이브러리이다.`
        },
      
    ]
    const test2018jsp : Testtype[] = [
        {
            q : "jsp 기술에 관한 설명으로 적당하지 않은 것은?",
            q1 : "",
            a : ["jsp 페이지에 대한 요청의 처리는 서버에서 수행된다.","jsp페이지는 서블릿 클래스로 변환되어 처리된다","jsp는 동적 컨텐츠 생성을 위한 c언어 기반의 스크립트 언어이다","jsp는 플랫폼에 독립적인 웹 응용 개발기술이다."],
            r : 3,
            img:'',
            summary:'java 기반임'
        },
        {
            q : "eclpise를 이용하여 개발한 동적 웹 프로젝트를 war 파일로 만들어 톰캣에 배포할때 어느 위치에 배포하는가?",
            q1 : "",
            a : ["[톰캣설치폴더]\\webapps","[톰캣설치폴더]\\WdbContent","[톰캣설치폴더]\\WebContent/webapps","[톰캣설치폴더]\\webapps/ROOT"],
            r : 1,
            img:'',
            summary:''
        },
        {
            q : "클라이언트 요청을 처리하기 위해 톰캣이 doGet() 또는 doPost()메서드에 전달해주는 인자를 모두 나열하면 무었인가?",
            q1 : "",
            a : ["request 객체","request와 response 객체","request, response, out 객체","page, requesst, session, application 객체"],
            r : 2,
            img:'',
            summary:''
        },
        {
            q : "클라이언트로부터 받은 요청 헤더 중 User-Agent헤더의 값을 읽기 위한 방법은 무엇인가?",
            q1 : "",
            a : ["String value = request.getAttribute(\"User-Agent\");","String value = request.getHeader(\"User-Agent\");","String value = request.getParameter(\"User-agent\");","String value = application.getInitParameter(\"User-Agent\");"],
            r : 2,
            img:'',
            summary:''
        },
        {
            q : "사용할 클래스를 지정하기 위해 밑줄 친 ㄱ 에 들어갈 내용은?",
            q1 : "",
            a : ["import java.util.*;","<%! import class=\"java.util.Date\" %>","<%@ include file=\"java.util.*\" %>","<%@ page import=\"java.util.Date\" %>"],
            r : 4,
            img:'jsp201912.JPG',
            summary:''
        },
        { //41
            q : "밑줄 친 ㄴ에 들어갈 적당한 내용을 모두 고르시오",
            q1 : "",
            a : ["<%=","<%","<%!","<% 또는 <%!"],
            r : 4,
            img:'',
            summary:''
        },
        {
            q : "위 페이지에서 나타나 있지 않은 요소는 무엇인가?",
            q1 : "",
            a : ["지시어","표현식","스크립트릿","템플릿 텍스트"],
            r : 2,
            img:'',
            summary:''
        },
        {//43
            q : "메서드 호출을 통한 내장 객체의 활용 예를 보인것이다. 잘못된 것은?",
            q1 : "",
            a : ["request.setHeader()","response.sendRedirect()","session.setAttribute()","out.flush()"],
            r : 1,
            img:'',
            summary:''
        },
        {
            q : "태그가 위치한 부분에 지정된 페이지의 실행 결과를 포함시키기 위한 동적 인클루드 방법으로 올바른 것은?",
            q1 : "",
            a : ["<%@ include file=\"/template/included.jsp\"%>","<jsp:include file=\"/template/included.jsp\" %>","<jsp:include page=\"/template/included.jsp\" %>","<jsp:forward page=\"/template/included.jsp\" %>"],
            r : 3,
            img:'',
            summary:''
        },
        {//45
            q : "다음 중 <jsp:forward.../> 액션의 처리를 잘못 설명한 것은?",
            q1 : "",
            a : ["현재 페이지의 실행이 종료되고 새로운 페이지로의 이동이 일어난다","포워디잉 일어나기 직전에 버퍼의 내용이 지워진다.","포워딩 전에 결과가 전송된 적이 있다면 예외가 발생한다.","포워딩 전후의 두 페이지는 같은 page 영역에 있게 된다."],
            r : 4,
            img:'',
            summary:''
        },
        {
            q : "쿠키를 이용하여 사용자 로그인/로그아웃을 처리한다고 할 때 다음 중 로그아웃 처리에 꼭 필요한 작업은 무엇인가?",
            q1 : "",
            a : ["관리자 아이디와 비밀번호를 입력받는다","로그인에 사용했던 쿠키의 유효 시간을 -1로 변경한다","유호시간을 변경하여 쿠키를 클라이언트로 전송한다","도메인과 경로 등 쿠키의 부가정보를 모두 초기화 한다."],
            r : 3,
            img:'',
            summary:''
        },
        {
            q : "다음 코드의 실행을 예상한 내용으로 잘못된 것은?",
            q1 : "",
            a : ["쿠키 객체를 생성한다",'클라이언트가 보낸 쿠키 객체를 읽는다',"쿠키를 응답헤더에 추가한다","쿠키의 유효시간을 24시간으로 설정한다."],
            r : 2,
            img:'jsp2018.JPG',
            summary:''
        },
        {//48
            q : "클라이언트가 보낸 쿠키를 읽기 위해 다음과 같이 코딩하였다 다음 코드를 가장 정확하게 설명하는 것은?",
            q1 : "",
            a : ["문법적 오류가 존재하여 컴파일 되지 않는다.","쿠키를 읽을때 예외 처리를 안해서 문제가 있다","전달된 쿠키가 하나도 없는 경우 실행 오류가 발생한다","배열에서 첫 번째 쿠키의 이름과 값만 읽을 수 있다."],
            r : 4,
            img:'jsp201801.JPG',
            summary:''
        },
        {//49
            q : "세션의 유효시간에 관한 설명이다. 잘못된 것은?",
            q1 : "",
            a : ["유효시간이란 세션 정보의 총 저장기간이다.","web.xml설정 파일에서 <session-timeout> 태그를 이용하여 유효시간의 기본 값을 분 단위로 설정할 수 있다.","프로그램 상에서 session.setMaxInactiveInterval() 메서드를 사용하여 유효시간을 초 단위로 설정할 수 있다.","유효시간이 음수로 주어지면 세션은 무제한 유지될 수도 있다."],
            r : 1,
            img:'',
            summary:''
        },
        {//50
            q : "세션을 사용하여 로그인/ 로그아웃을 처리할 때, 다음 중 로그아웃 처리에 필요한 작업은 무엇인가?",
            q1 : "",
            a : ["웹 컨테이너를 재시작 시킨다","세션에 사용자 식별 정보를 저장한다","세션을 삭제(무효화)한다","세션의 유효시간을 0으로 변경한다."],
            r : 3,
            img:'',
            summary:''
        },
        {
            q : "request_scope.jsp 에서 밑줄 친 부분과 동일한 의미를 가지는 것은 무엇인가?",
            q1 : "",
            a : ["<% meminfo.setAge(10); %>","<%= meminfo.setAge(10) %>","<%= meminfo.setProperty(\"age\",\"10\") %>","<% meminfo.setAttribute(\"age\",\"10\"); %>"],
            r : 1,
            img:'jsp201802.JPG',
            summary:''
        },
        {//52
            q : "자바빈 객체의 속성을 출력하기 위해 밑줄 친 ㄱ 에 들어갈 적당한 내용은?",
            q1 : "",
            a : ["<jsp:getProperty id=\"meminfo\" property=\"age\" />","<jsp:getProperty name=\"meminfo\" property=\"age\" />","<jsp:setProperty name=\"meminfo\" property=\"age\" />","<%= out.print(meminfo.getAge()) %>"],
            r : 2,
            img:'',
            summary:''
        },
        {
            q : "클라이언트가 request_scoope.jsp를 요청했을 때, 요청의 처리를 설명한 것이다. 올바른 것은?",
            q1 : "",
            a : ["request_scope.jsp와 scope_test.jsp에서 사용하는 자바빈 객체는 서로 다른 별개의 객체이다.","두 페이지는 같은 request 영역에 있으나 데이터를 공유하고 있지 않다.","두 페이지는 같은 request 영역에 있으며 request 객체를 통해 데이터를 공유한다.","두 페이지는 같은 session 영역에 있으며 session 객체를 통해 데이터를 공유한다."],
            r : 3,
            img:'',
            summary:''
        },
        {
            q : "표현 언어에 관한 설명이다. 잘못된 것은?",
            q1 : "",
            a : ["스크립트릿, 표현식, 선언부에서는 표현 언어를 사용할 수 없다.","표현 언어의 기본 사용 형식은 ${수식}이다","표현 언어 수식에서 jsp 내장 객체를 자유롭게 사용할 수 있다.","표현 언어를 사용하면 jsp 페이지에서 스크립트의 사용을 줄일 수 있다."],
            r : 3,
            img:'',
            summary:''
        },
        {//55
            q : "표현 언어의 내장 객체를 이용하여 다음 코드를 다시 작성하면 무엇인가?",
            q1 : "<% request.getParameter(\"id\") %>",
            a : ["${param.id}","${param[id]}","${cookie.id.value}","${requestScope.param.id}"],
            r : 1,
            img:'',
            summary:''
        },
        {
            q : "표현 언어 수식에서 자바 메서드를 사용하기 위해 필요한 준비 작업을 설명한 것이다. 잘못된 것은?",
            q1 : "",
            a : ["해당 메서드를 포함하는 자바 클래스를 작성한다. 메서드는 static 메서드로 정의한다",".tld 파일을 작성할 때 해당 메서드의 정보를 <function> 태그 안에 기술한다",".tld 파일에서 <uri> 태그를 사용하여 .tld 파일의 축약 이름을 지정할 수 있다.","web.xml 파일에 <welcome-file-list> 태그를 포함시켜 태그 라이브러리의 정보를 기술한다."],
            r : 4,
            img:'',
            summary:''
        },
        {//57
            q : "MVC 패턴을 적용하여 컨트롤러를 구현할 때 커맨드 패턴을 정용할 수 있다 . 이때 커맨드를 구분하기 위해 서블릿의 doGet() 또는 doPost() 메서드에서 if문을 사용하는 방법 a와 '커맨드와 처리 클래스'를 저장한 설정파일을 만들고 서블릿의 init() 메서드에서 Map으로 만들어 처리하는 방법 b 가 있다. 새로운 커맨드가 추가되는 경우, 다음 설명중 올바른 것은?",
            q1 : "",
            a : ["두방법 모두 소스 코드를 수정할 필요가 없다","두방법 모두 코드를 수정하고 다시 컴파일 해야한다","방법 a는 소스코드의 수정이 필요하지만 다시 컴파일할 필요는 없다","방법 b는 소스코드의 수정 없이 설정 파일만 수정하면 된다"],
            r : 4,
            img:'',
            summary:''
        },
        {
            q : "서버의 리소스(서블릿이나 JSP페이지)를 포장하고 있는 유형으로 클라이언트의 요청을 해당 리소스로 포워딩 시키거나 해당 리소스의 실행 결과를 인클루드 할때 사용되는 유형은 무엇인가?",
            q1 : "",
            a : ["HttpServletRequest","RequestDispatcher","HttpServletResponse","ResponseDispatcher"],
            r : 2,
            img:'',
            summary:''
        },
        {
            q : "밑줄 친 ㄱ에 들어갈 적당한 SQL 구문은 무엇인가?",
            q1 : "",
            a : ["select * from member","select * from member where id=?","select * from member where id=? and pass=?","update member set (?, ?, ?, ?) where id=? "],
            r : 2,
            img:'jsp201803.JPG',
            summary:''
        },
        {
            q : "SQL 구문을 실행하기 위해 밑줄 친 ㄴ에  들어갈 알맞은 내용은 무엇인가?",
            q1 : "",
            a : ["rs.executeQuery(query)","openConnection.executeQuery()","psmt.executeUpdate(query)","pstmt.executeQuery()"],
            r : 4,
            img:'',
            summary:''
        },   
    ]
    const test2019jsp : Testtype[] = [
        {
            q : "HTTP 요청 메시지(또는 응답메시지)에서 아래와 같은 내용이 포함되었다. 이것은 어느 부분에 해당하는가?",
            q1 : "HTTP/1.1 200 OK",
            a : ["요청메시지의 시작 라인","요청 메시지의 헤더","응답메시지의 시작 라인","응답메시지의 몸체"],
            r : 3,
            img:'',
            summary:''
        },
        {
            q : "아래 폼에서 확인 버튼을 눌러 발생하는 요청을 서블릿을 이용해 처리하고자 할때, HelloServlet 클래스에서 반드시 구현해야 하는 메서드는 무엇인가?",
            q1 : "",
            a : ["get()","doGet()","post()","doPost()"],
            r : 4,
            img:'jsp2019.JPG',
            summary:''
        },
        {
            q : "아래 내용에 관한 설명으로 가장 올바른 것은?",
            q1 : "<%@ page contentType=\"text/html; charset=euc-kr\" %>",
            a : ["JSP페이지에서 사용되는 스크립트의 형식과 언어를 지정한다.","JSP 페이지 자신의 MIME 타입과 문자인코딩을 지정한다.","요청 문서의 MIME타입과 문자 인코딩을 지정한다.","응답문서의 MIME 타입과 문자 인코딩을 지정한다"],
            r : 4,
            img:'',
            summary:''
        },
        {
            q : "메서드 선언을 위해 밑줄 친 ㄱ 에 들어가야 할 내용은?",
            q1 : "",
            a : ["<%","<%@","<%!","<%--"],
            r : 3,
            img:'jsp201901.JPG',
            summary:'표현식의 형태는 <%= ...%>이다.  <%!...%> 는 메서드 선언이나 변수 선언을 위한 형태이다'
        },
        {//40
            q : "합을 출력하기 위해 밑줄친 ㄴ 에 들어갈 적당한 내용은?",
            q1 : "",
            a : ["<% sum(100) %>","<%= sum(100) %>","<% sum(100);%>","<%= out.print(sum(100)) %>"],
            r : 2,
            img:'',
            summary:' <%= 에는 ; 세미콜론이 들어가면 안됨'
        },
        {
            q : "아래와 같이 4회의 요청/응답이 이루어지는 동안 하나의 세션이 계속 유지되었다고 가정하자. 같은 session 객체를 페이지 4와 공유할수있는 페이지는 전부 무엇인가?",
            q1 : "",
            a : ["페이지 1과 2 ","페이지 1~ 3","페이지 5","페이지 1~6"],
            r : 4,
            img:'',
            summary:''
        },
        {
            q : "web.xml 파일에는 웹 어플리케이션에서 사용되는 각종 설정정보를 저장할 수 있다. 예를들면 아래와 같은 웹 어플리케이션의 초기화 파라미터를 설정할 수 있다. 이것을 활용하기 위해 사용해야 하는 내장 객체는 무엇인가?",
            q1 : "",
            a : ["pageContext","request","session","application"],
            r : 4,
            img:'jsp201902.JPG',
            summary:''
        },
        {
            q : "아래 나열된 메서드를 제공하는 내장 객체는 무엇인가?",
            q1 : "getBufferSize( ), flush(  ), isAutoFlush( ), clear( ), print( )",
            a : ["buffer","error","out","request"],
            r : 3,
            img:'',
            summary:''
        },
        {//44
            q : "including.jsp 페이지를 요청했을때, 클라이언트의 브라우저에서 표시되는 결과는 무엇인가?",
            q1 : "",
            a : ["included.jsp : 1000","including.jsp : 20  including.jsp :20","including.jsp : 20   included.jsp : 1000   including.jsp : 20","including.jsp : 20   included.jsp : 1000   including.jsp : 1000"],
            r : 4,
            img:'jsp201903.JPG',
            summary:''
        },
        {
            q : "다음 밑줄 친 ㄱ 과 ㄴ 에 들어갈 내용을 순서대로 적은 것은?",
            q1 : "",
            a : ["1","2","3","4"],
            r : 3,
            img:'jsp201904.JPG',
            summary:''
        },
        {
            q : "다음은 세션을 이용한 로그인/로그아웃 처리에서, 로그아웃 처리를 위한 logout.jsp 이다. 밑줄 부분에 들어갈 알맞은 내용은 무엇인가?",
            q1 : "",
            a : ["session.setMaxAge(0);","response.addCookie(session);","session.setMaxInactiveInterval(60*5);","session.invalidate( );"],
            r : 4,
            img:'jsp201905.JPG',
            summary:''
        },
        {//47
            q : "request_scope.jsp로 들어온 요청을 scope_test.jsp로 이동시키기 위해 밑줄 친 ㄴ 에 들어갈 알맞은 내용은?",
            q1 : "",
            a : ["<jsp:forward page =\"scope_test.jsp\" />","<jsp:forward file=\"scope_test.jsp\" />","<%@ forward page=\"scope_test.jsp\" %>","response.sendRedirect(\"scope_test.jsp\");"],
            r : 1,
            img:'jsp201906.JPG',
            summary:''
        },
        {
            q : "두 페이지 간에 자바빈 객체를 공유하기 위해 밑줄 친 ㄱ 에 들어갈 영역으로 알맞은 것은?",
            q1 : "",
            a : ["page","request","session","application"],
            r : 2,
            img:'',
            summary:''
        },
        {//49
            q : "자바빈 객체의 name 속성의 값을 출력하기 위해 밑줄 친 ㄷ 에 들어갈 내용으로 적당한 것은?",
            q1 : "",
            a : ["<% meminfo.getName( ); %>","<% request.getName( ) ; %>","<jsp.getProperty name=\"meminfo\" property=\"name\"/>","<jsp:setProperty name=\"meminfo\" property=\"*\" />"],
            r : 3,
            img:'',
            summary:''
        },
        {
            q : "JSTL 코어 라이브러리를 사용하기 위해 밑줄 친 ㄱ 에 들어갈 알맞은 내용은?",
            q1 : "",
            a : ["<%@ taglib prefix=\"c\"","<%@ taglib prefix=\"core\"","<%@ import prefix=\"c\"","<%! import taglib=\"c\""],
            r : 1,
            img:'jsp201907.JPG',
            summary:''
        },
        {
            q : "member 객체가 가진 name 속성의 값을 출력하기 위해 밑줄 친 ㄴ에 들어갈 적당한 내용은?",
            q1 : "",
            a : ["member.getName( );","out.print(member.getName( ));","${member[name]}","${member.name}"],
            r : 4,
            img:'',
            summary:''
        },
        {
            q : "보기 중에서 아래 나오는 표현언어의 사용을 대체할 수 있는 것은?",
            q1 : "",
            a : ["<% request.getAttribute(\"name\") %>","<% request.getName( ) %>","<%= request.getAttribute(\"name\") %>","<%= requestScope.getAttribute(\"name\") %>"],
            r : 3,
            img:'jsp201908.JPG',
            summary:''
        },
        {
            q : "표현언어 수식에서 자바 메서드를 사용하기 위해서 TLD 파일 (.tld)을 작성해야 한다. 이 파일에 관한 설명으로 잘못된 것은?",
            q1 : "",
            a : ["태그 라이브러리에 포함된 태그 정보를 기술한 xML형식의 파일이다","자바 메서드의 정보를 <function> 태그안에 기술한다","<uri> 태그를 사용하여 .tld 파일의 축약 이름을 지정할 수 있다.",".class 파일과 같이 /WEB-INF/classes 폴더에 저장한다."],
            r : 4,
            img:'',
            summary:' TLD 파일은 /WEB-INF/classes 폴더가 아닌 /WEB-INF 또는 /WEB-INF/tlds 폴더에 저장됩니다. 클래스 파일과 같이 /WEB-INF/classes 폴더에 저장되지 않습니다. /WEB-INF/classes는 Java 클래스 파일을 저장하는 곳입니다.'
        },
        {
            q : "다음 그림은 개략적으로 MVC 패턴의 처리과정을 보여준다 ㄱ, ㄴ, ㄷ에 들어갈 적당한 내용은 순서대로 무엇인가?",
            q1 : "",
            a : ["자바빈, 서블릿, jsp","jsp, 자바빈, 서블릿","서블릿, 자바빈, jsp","서블릿, jsp, 자바빈"],
            r : 3,
            img:'jsp201909.JPG',
            summary:''
        },
        {
            q : "메서드 doGet( ) 의 인자로서 밑줄 친 ㄱ 에 들어갈 적당한 내용은?",
            q1 : "",
            a : ["String[ ] args","java.io.PrintWriter out","ServletRequest req, ServletResponse resp","HttpServletRequest request, HttpServletResponse response"],
            r : 4,
            img:'jsp201910.JPG',
            summary:''
        },
        {//56
            q : "사용자가 보낸 파라미터를 읽기 위해 밑줄 친 ㄴ 에 들어갈 적당한 메서드는 무엇인가?",
            q1 : "",
            a : ["getParameter","getAttribute","getParameterValues","setParameter"],
            r : 1,
            img:'',
            summary:''
        },
        {//57
            q : "서블릿에서 저장했던 속성을 읽어 출력하기 위해, 밑줄 친 ㄷ 에 들어갈 적당한 내용은 무엇인가?",
            q1 : "",
            a : ["request.getParameter(\"result\")","request.getParameter(\"name\")","request.getAttribute(\"result\")","request.setAttribute(\"name\")"],
            r : 3,
            img:'',
            summary:''
        },
        {
            q : "브라우저 주소란에 아래와 같이 입력하여 요청할 때, 브라우저에 나타날 것으로 예상되는 응답 결과는 무엇인가?",
            q1 : "http://localhost:8080/MVC/ExampleServlet?name=jimmy",
            a : ["Hello, MVC!","Hello, jimmy","View 예제, jimmy","Sun Dec 08 16:11:05 KST 2019"],
            r : 4,
            img:'',
            summary:''
        },
        {
            q : "밑줄 친 ㄱ 에 들어갈 적당한 SQL 구문은 무엇인가?",
            q1 : "",
            a : ["select * from member","select * from member where id=? and pass=?","insert into member values(?, ?)","update member set pass=? where id=?"],
            r : 2,
            img:'jsp201911.JPG',
            summary:''
        },
        {
            q : "SQL 구문을 실행하기 위해 밑줄 친 ㄴ 에 들어갈 알맞은 내용은 무엇인가?",
            q1 : "",
            a : ["rs.executeQuery()","rs.executeUpdate(query)","pstmt.executeQuery()","pstmt.executeUpdate(query)"],
            r : 3,
            img:'',
            summary:''
        },
    ]
    const test2017jsp : Testtype[] = [
        {
            q : "다음이 설명하는 http요청 방식은 무엇인가?",
            q1 : "원하는 방식으로 인코딩된 데이터를 요청 메시지의 몸체에 포함하여 전송하면서 자원을 요청하는 경우 사용됨",
            a : ["GET","HEAD","POST","FTP"],
            r : 3,
            img:'',
            summary:''
        },
        {
            q : "Eclipse를 이용한 웹 프로젝트의 배포가 의미하는 것은?",
            q1 : "",
            a : ["웹 프로젝트 폴더를 압춝 파일로 만드는 것이다.","개발한 웹 프로젝트를 웹 컨테이너에 내보내는 것이다.","웹 컨테이너를 서버로 등록시키는 것이다.","버퍼의 내용을 일차적으로 클라이언트에 보내는 것이다."],
            r : 2,
            img:'',
              summary:''
        },
        {//38
            q : "jSP 페이지에서 사용할 메소드나 변수를 선언하기 위한 태그는 다음 중 어느 것인가?",
            q1 : "",
            a : ["<% ... %>","<%!... %>", "<%@ ... %>", " <%# ... %>"],
            r : 2,
            img:'',
              summary:''
        },
        {
            q : "서블릿 클래스에서 doGet() 메서드의 인자는 무엇인가?",
            q1 : "",
            a : ["request 1개", "response 1개", " request와 response", "인자가 없음"],
            r : 3,
            img:'',  
            summary:''
        },
        {//40
            q : "다음은 버퍼가 차면 내용을 클라이언트로 보내고 버퍼를 비우라는 의미를 가진다. 빈칸에 들어갈 단어는 무엇인가?",
            q1 : '<%@ page ____ = "true" %> ' ,
            a : ["flush","autoFlush","buffer","autoBuffer"],
            r : 2,
            img:'',
              summary:''
        },
        {
            q : "다음 중 JSP의 내장 객체가 아닌 것은?",
            q1 : '' ,
            a : ["request","response","out","cookie"],
            r : 4,
            img:'',
              summary:''
        },
        {
            q : "including.jsp 페이지를 요청했을 때, 클라이언트의 브라우저에서 표시되는 결과는 무엇인가?",
            q1 : '' ,
            a : ["included.jsp : 1000"," including.jsp : 20 \n including.jsp","including.jsp : 20 \n included.jsp : 1000 \n including.jsp : 20", "including.jsp : 20 \n included.jsp : 1000 \n including.jsp : 1000"],
            r : 3,
            img:'jsp1.jpg',
              summary:'변수의 스코프를 잘 생각해야함.  이 문제에서는 페이지별로 변수 스코프가 지정되어서 해당 페이지에서만 각각 변수가 사용된다. data 이름은 동일하나 서로 다른 변수라고 보고 생각해야 한다. 그래서 각 페이지마다 다른 값을 갖는다.'
        },
        {
            q : "including.jsp와 included.jsp 페이지 사이에서 공유될 수 없는 영역은 무엇인가?",
            q1 : '' ,
            a : ["page","requese","session","application"],
            r : 1,
            img:'jsp1.jpg',
              summary:''
        },
        {
            q : "jsp 페이지의 모듈화를 위해 사용하는 방법이라고 할 수 없는 것은?",
            q1 : '' ,
            a : ["page지시어","include 지시어","include 액션태그 ", "prelude와 coda"],
            r : 1,
            img:'',  summary:''
        },
        {
            q : "<jsp:forward .../> 액션의 처리를 바르게 설명한 것은?",
            q1 : '' ,
            a : ["실행 결과의 맨 앞이나 맨 뒤에 자동으로 코드를 포함시킨다.","속성으로 지정된 페이지의 실행 결과를 태그가 위치한 부분에 삽입시킨다.","<jsp:include> 액션의 서브 요소로만 사용된다.","페이지의 실행이 종료되고 새로운 페이지로의 이동이 일어난다"],
            r : 4,
            img:'',
              summary:''
        },
        {
            q : "쿠키의 유효 시간에 관한 설명으로 올바른 것은?",
            q1 : '' ,
            a : ["클라이언트 컴퓨터에서 쿠키가 유지되는 기간이다.","쿠키의 유효시간이 음수라면 영구히 보관된다","클라이언트의 추가 요청이 없어도 쿠키가 보존되는 기간이다."," 출력버퍼에서 쿠키 값을 변경할 수 있는 최대 시간이다."],
            r : 1,
            img:'',
              summary:''
        },
        {
            q : "다음 코드의 의미를 바르게 설명한 것은?",
            q1 : '<% Cookie cookie= new Cookie("name","value"); \n response.addCookie(cookie); %>' ,
            a : ["쿠키를 만들어 요청 메시지의 헤더에 추가한다"," 쿠키를 만들어 응답 메시지의 헤더에 추가한다","쿠키를 만들어 응답 메시지의 몸체에 추가한다.","클라이언트가 보낸 요청 메시지로부터 쿠키 값을 읽는다."],
            r : 2,
            img:'',
              summary:''
        },
        {
            q : "세션을 사용하여 로그인/ 로그아웃을 처리하는 jsp 페이지를 구현하려고 한다. 다음중 로그인 처리에 필요한 작업은 무엇인가?",
            q1 : '' ,
            a : ["request 영역에 session 객체를 저장한다.","session 객체에 타임아웃 시간을 수정한다.","session 객체에 사용자 확인을 위한 속성을 추가한다.","session 객체를 삭제한다."],
            r : 3,
            img:''
            ,  summary:''
        },
        {
            q : "다음중 세션이 종료되는 상황이 아닌 것은?",
            q1 : '' ,
            a : ["클라이언트가 웹 브라우저를 종료한다.","세션의 유효시간 동안 클라이언트의 추가 요청이 없었다.","JSP페이지에서 session.invaildate() 를 실행한다.","jsp 페이지에서 session 객체에 저장된 모든 속성을 삭제하였다."],
            r : 4,
            img:''
            ,  summary:''
        },
        {
            q : "위에서 사용된 자바빈 객체에 관한 설명으로 잘못된 것은?",
            q1 : '' ,
            a : ["member.MemberInfo는 클래스의 이름에 해당한다.","meminfo라는 이름의 객체가 존재하지 않으면 자바빈 객체를 생성한다.","객체가 가진 속성 name과 age에 값을 지정하고 있다.","객체의 사용 범위가 page이므로 해당 페이지에서만 사용할 수 있다."],
            r : 4,
            img:'jsp2.jpg'
            ,  summary:''
        },
        {
            q : "자바빈 객체의 이름을 출력하기 위해 밑줄 친 부분에 들어갈 적당한 내용은>?",
            q1 : '' ,
            a : ["<jsp:getProperty name='meminfo' property='name' />","<jsp:getParameter id='meminfo' property='name' />","<jsp:setProperty name='meminfo' property='name' />","<out.print(meminfo.getName()); >"],
            r : 1,
            img:'jsp2.jpg'
            ,  summary:''
        },
        {
            q : "표현언어(EL)의 사용에 관한 설명이다. 잘못된 것은?",
            q1 : '' ,
            a : ["표현식을 대신하여 자주 사용된다","태그의 속성값을 지정할 때 표현 언어 수식을 사용한다","표현 언어의 내장 객체와 jsp의 내장객체는 다른 것이다.","스크립트 요소의 내부에서 사용해야 한다."],
            r : 4,
            img:''
            ,  summary:''
        },
        {
            q : "<%= request.getParameter('name') %> 과 같은 의미를 가지는 표현 언어 수식을 내장 객체 param을 사용하여 표현하면 무엇인가?",
            q1 : '' ,
            a : ["${ param.name }","${ param[name] }","$( param.name )","$( param[name] )"],
            r : 1,
            img:''
            ,  summary:''
        },
        {
            q : "코어 라이브러리를 사용하려면 지시어를 추가해야 한다. 밑줄 친 ㄱ에 들어가야할 내용은",
            q1 : '' ,
            a : ["<%@ import", "<%= page", "<%@ taglib","<%# taglib"],
            r : 3,
            img:'jsp3.JPG'
            ,  summary:''
        },
        {
            q : "밑줄친 ㄴ에는 흐름제어를 위한 태그가 들어가야 한다 적당한 것은 무엇인가?.",
            q1 : '' ,
            a : ["c:choose","c:forEach","x:import","x:forTokens"],
            r : 2,
            img:'jsp3.JPG'
            ,  summary:''
        },
        {
            q : "다음중 MYSQL과 연동하는 JDBC프로그래밍 작업을 위한 것은 무엇인가?",
            q1 : '' ,
            a : ["Oracle 사이트에서 php-mysql패키지를 다운받아 설치함","Eclipse 사이트에서 Tomcat을 다운받아 설치함","MySQL사이트에서 Connector/J를 다운받아 설치함","MYSQL 사이트에서 MYSQL Shell을 다운받아 설치함"],
            r : 3,
            img:''
            ,  summary:''
        },
        {
            q : "MVC 패턴을 적용하여 컨트롤러를 구현할 때 커맨드 패턴을 적용할 수 있다. 이때 커맨드와 관련된 정보를 별도의 설정파일로 만든다면 어떤 장점이 있는가?",
            q1 : '' ,
            a : ["새로운 커맨드를 추가하면 설정파일을 다시 읽어야 한다","새로운 커맨드를 추가할 경우 소스코드를 수정해야 한다","새로운 커맨드를 추가되도 설정파일을 수정할 필요가 없다","새로운 커맨드를 추가되도 소스코드를 수정할 필요가 없다"],
            r : 4,
            img:''
            ,  summary:''
        },
        {
            q : "다음은 회원정보를 저장을 위한 자바빈 클래스이다. 속성 id의 getter 메서드와 setter 메서드를 올바르게 작성한 것은?",
            q1 : '' ,
            a : ["public String getId() {return id;} public void setId(String id){ id = id;}" ,"publci void getId(String id) {this.id = id; }  public String setId() { return id; }"," public String getId() { return this; }  public void setId(String id) {this.id = id;}", "public String getId() { return id;}  public void setId(String id) { this.id = id; }"],
            r : 4,
            img:'jsp4.JPG'
            ,  summary:''
        },
        {
            q : "세션 영역에 회원 아이디를 'ID'라는 이름의  속성으로 저장하려 한다. 밑출 친 ㄱ에 들어가야 할 내용은?",
            q1 : '' ,
            a : ["session.getAttribute","session.setAttribute","cookie.getAttribute","cookie.setAttribute"],
            r : 2,
            img:'jsp5.JPG'
            ,  summary:''
        },
        {
            q : "로그인 처리가 끝난 후 다음 페이지로 이동하기 위해 밑줄 친 ㄴ에 들어가야 할 내용은?",
            q1 : '' ,
            a : ["request.forward","request.sendRedirect","response.forward","response.sendRedirect"],
            r : 4,
            img:'jsp5.JPG'
            ,  summary:''
        },

    ]
    const testdbpp :Testtype[] =[
        {//형성평가 문제들
            q : "[가] 란 공통적인 개념을 이용하여 같은 종류의 다양한 객체를 정의하는 것",
            q1 : '지문 [가]에 알맞은 것은 무엇인가 ? ' ,
            a : ["자료구조","정보화","추상화","알고리즘"],
            r : 3,
            img:''
            ,  summary:'추상화란 공통적인 개념을 이용하여 같은 종류의 다양한 객체를 정의하는 것입니다.'
        },
        {//
            q : "'정보’는 현실 세계에서 관찰이나 측정을 통해서 수집된 값(value)이나 사실(fact)이다.",
            q1 : '' ,
            a : ["O","X"],
            r : 2,
            img:''
            ,  summary:`정보’는 어떤 상황에 대해서 적절한 의사결정(decision)을 할 수 있게 하는 지식(knowledge)으로서 자료의 유효한 해설(interpretation)이나 자료 상호 간의 관계(relationship)를 표현하는 내용이라고 할 수 있습니다.

‘정보’는 어떠한 상황에 적절한 결정이나 판단에 사용될 수 있는 형태로 가공되거나 분류되기 위해 ‘처리 과정’을 거쳐서 정리되고 정돈된 ‘자료’의 2차 처리 결과물이다. 정보는 자료를 처리(process)해서 얻어진 유용한 결과(result)라고 할 수 있습니다.`
        },
        {//
            q : "자료의 추상화란 컴퓨터에 의해 수행되기 위해 필요한 명령어들의 유한 집합이 사람의 머릿속에 추상화되어 존재하는 것이다",
            q1 : '' ,
            a : ["O","X"],
            r : 2,
            img:''
            ,  summary:''
        },
        {//
            q : "알고리즘을 실행하는 데 필요한 시간과 공간을 추정하는 것을 알고리즘의 성능 측정이라 하고 컴퓨터가 실제로 프로그램을 실행하는데 걸리는 시간 측정하는 것을 알고리즘의 성능 분석이라 한다.",
            q1 : '' ,
            a : ["O","X"],
            r : 2,
            img:''
            ,  summary:`
            알고리즘이란 컴퓨터에 의해 수행되기 위해 필요한 명령어들의 유한 집합이 사람의 머릿속에 추상화되어 존재하는 것 입니다
            알고리즘이 가지고 있어야 할 조건들 ① 출력, ② 유효성, ③ 입력, ④ 명확성, ⑤ 유한성 등이 있습니다.
알고리즘을 실행하는데 필요한 시간과 공간을 추정하여 알고리즘의 성능을 분석(performance analysis)을 합니다. 그리고 컴퓨터가 실제로 프로그램을 실행하는데 걸리는 시간 측정하여 알고리즘의의 성능을 측정(performance measurement)합니다.`
        },
        {// 배열
            q : "자료 구조의 유형 중 선형 구조에 해당하는 것은 무엇인가 ?",
            q1 : '' ,
            a : ["배열","그래프","트리","히프"],
            r : 1,
            img:''
            ,  summary:`배열은 인덱스와 원소값()의 쌍으로 구성된 집합으로서, 정의된 각 인덱스는 그 인덱스와 관련된 값을 갖습니다.
\n 배열의 순서는 메모리 공간에서 저장되는 ‘원소값의 물리적 순서’를 의미합니다.
\n 배열의 각 원소의 물리적인 위치(메모리 주소)의 순서가 배열의 인덱스의 순서(논리적인 순서)와 일치합니다.
\n 배열의 인덱스값을 이용해서 배열의 원소값에 접근하기 때문에 직접 접근(direct access)입니다.
\n 배열의 물리적인 저장 순서는 배열의 인덱스에 의해서 결정되며, 그 순서에 따라 메인 메모리에서의 저장 위치의 순서가 됩니다`
        },
        {//
            q : "배열은 자료에 해당하는 (가)와 몇 번째에 해당하는 지를 의미하는 (나)로 구성됩니다. 즉, 배열은 순서를 표현하는 (나)와 값을 표현하는 (가)의 쌍으로 이루어집니다. ",
            q1 : '지문 (가), (나)에 적합한 것은 ?' ,
            a : ["인덱스, 원소(워소값)","원소값, 레코드","레코드, 원소값","원소(원소값), 인덱스"],
            r : 4,
            img:''
            ,  summary:''
        },
        {//
            q : "순서를 가진 원소들의 순열로서 물리적 순서가 논리적인 순서와 일치하는 하여 논리적 순서를 의미하는 자료구조는 무엇인가 ?",
            q1 : '' ,
            a : ["트리","배열","스택","큐"],
            r : 2,
            img:''
            ,  summary:''
        },
        {//스택
            q : "A*B+C",
            q1 : '지문의 수식을 후위 표기식으로 바르게 나타낸 것은 ?' ,
            a : ["AB*C+","ABC*+","AC*B+","AC+B*"],
            r : 1,
            img:''
            ,  summary:`중위 표기법(infix notation)은 연산자를 피연산자의 사이에 표기하는 방법이며 일반적으로 가장 많이 사용되는 표기 방법(A+B)입니다.

전위 표기법(prefix notation)은 연산자를 피연산자의 앞에 표기하는 방법 (+AB)입니다.

후위 표기법(postfix notation)은 연산자를 피연산자의 뒤에 표기하는 방법 (AB+)입니다`
        },
        {//
            q : "스택의 응용 분야가 아닌 것은 ?",
            q1 : '' ,
            a : ["시스템 스택","서브루틴 호출","작업 스케쥴링","후위 수식의 계산"],
            r : 3,
            img:''
            ,  summary:''
        },
        {//
            q : "스택의 추상 자료형에서 정의된 연산은 시스템 개발자에 따라 다르게 정의되고 구현될 수도 있고, 컴파일러 설계자에 따라 프로그래밍 언어에서 다르게 제공될 수도 있습니다.",
            q1 : '' ,
            a : ["O","X"],
            r : 1,
            img:''
            ,  summary:`스택의 추상 자료형에서 정의된 연산은 시스템 개발자에 따라 다르게 정의되고 구현될 수도 있고, 컴파일러 설계자에 따라 프로그래밍 언어에서 다르게 제공될 수도 있습니다.

스택은 객체와 그 객체가 저장되는 순서를 기억하는 방법에 관한 추상 자료형입니다`
        },
        {// 큐
            q : "자료구조의 유형 중 선형 구조에 해당하는 것은 무엇인가?",
            q1 : '' ,
            a : ["큐","그래프","트리","히프"],
            r : 1,
            img:''
            ,  summary:`큐는 한쪽에서는 삽입이 발생하고 다른 한쪽에서는 삭제가 발생하도록 정의되었으며, 먼저 삽입된 원소가 먼저 삭제되므로 선입 선출(First-In-First-Out : FIFO) 또는 선착순 서브(First-Come-First-Serve : FCFS) 알고리즘을 갖는 순서 리스트라고 합니다. 교재에서는 ‘알고리즘과 함께 사용됩니다’로 되어 있습니다. 원형큐의 경우도 있어서, 순서 리스트라는 표현보다는 자료구조라는 표현이 더욱 정확하지 않을까 싶습니다.

큐에서는 원소의 삭제 연산이 이루어지는 곳을 앞(front)이라 하고 삽입 연산이 이루어지는 끝을 뒤(rear)라고 합니다.`
        },
        {//
            q : "큐에서 노드를 삽입할 경우의 설명으로 맞는 것은 ?",
            q1 : '' ,
            a : ["rear의 위치를 감소시킨 후 원소를 삽입","front의 위치를 증가시킨 후 원소를 삽입","rear의 위치를 증가시킨 후 원소를 삽입","front의 위치를 감소시킨 후 원소를 삽입"],
            r : 3,
            img:''
            ,  summary:''
        },
        {//
            q : "지문은 큐에 원소를 삽입하는 알고리즘이다. (가) 와 (나) 에 알맞은 내용은?",
            q1 : '' ,
            a : ["(가) rear == QUEUE_SIZE (나 ) rear++","(가) rear == QUEUE_SIZE (나 ) ++rear","(가) rear == QUEUE_SIZE-1  (나 ) ++rear","(가) rear == QUEUE_SIZE-1  (나 ) rear++"],
            r : 3,
            img:'자료구조 형성평가.JPG'
            ,  summary:''
        },
        {//연결리스트
            q : "다음 중 포인터로 구현된 리스트에 대한 설명으로 틀린 것은?",
            q1 : '' ,
            a : [" ‘일정한 순서’의 나열","어떤 정의에 의해서 결정된 ‘논리적인 순서’의 나열","리스트를 포인터로 구현할 경우에는 배열에 비해서 추가적인 메모리 공간이 필요하다. ","메모리 공간(주기억 장치, DDR)에서의 물리적인 위치가 논리적 위치와 일치한다."],
            r : 4,
            img:''
            ,  summary:`리스트의 ‘순서’는 데이터가 저장되는 물리적인 위치와 상관없이 사람들의 머릿속에 인식되는 ‘논리적인 순서’, 혹은 리스트에 나타나는 원소들 간의 ‘의미적인 순서’를 의미합니다.
            배열을 이용한 리스트의 구현은 실제 IT 서비스 환경에서는 자주 사용되지 않고 있습니다. 자료의 삽입과 삭제가 빈번히 발생하는 상황에서, 리스트를 배열로 구현하는 것은 빈번한 자료 이동으로 인한 비효율적인 컴퓨팅 성능을 유발합니다.
            `
        },
        {//
            q : "지문 프로그램의 (가) 에 적합한 것은?",
            q1 : '' ,
            a : [" ListNode* link;","struct ListNode* link;","struct LinkNode* link;"," LinkNode* link;"],
            r : 2,
            img:'자료구조 형성평가01.JPG'
            ,  summary:''
        },
        {//
            q : "지문 프로그램의 (나) 에 적합한 것은?",
            q1 : '' ,
            a : ["H = (list_pointer) list_node;","H = (linkedList_h*)malloc(sizeof(linkedList_h));","H = struct list_node;"," H = list_node → data;"],
            r : 2,
            img:''
            ,  summary:''
        },
        {//연결리스트 응용
            q : "원형 연결 리스트에 대한 설명으로 틀린 것은?",
            q1 : '' ,
            a : ["단순 연결 리스트의 마지막 노드의 링크 필드가 단순 연결 리스트의 처음 노드를 가리키도록 하는 구조이다.","단순 연결 리스트에 비해 추가적인 메모리 공간이 필요하다. ","한 노드에서 다른 어떤 노드로도 접근할 수 있다.","한 노드의 후행 노드를 직접 접근하면서도, 선행 노드도 접근할 수 있다."],
            r : 2,
            img:''
            ,  summary:`단순 연결 리스트는 하나의 링크 부분이 존재하고, 각각의 노드는 후행 노드만을 가리키는 구조이며, 특정 노드의 선행 노드에 대한 접근은 헤드 노드부터 재검색해야 하는 단점을 가집니다.

이중 연결 리스트는 선행 노드를 가리키는 링크 부분과 후행 노드를 가리키는 링크 부분을 가집니다.

단순 연결 리스트가 사용하지 않는 마지막 노드의 링크 부분을 활용하면서도 프로그램 성능에 도움이 되도록 하기 위해서 제안된 원형 연결 리스트는 한 방향으로 모든 노드가 원형으로 계속 연결되어 있기 때문에 한 노드에서부터 다른 어떤 노드로도 접근할 수 있는 이점이 있습니다.`
        },
        {//
            q : "지문 프로그램의 (가) 에 적합한 것은?",
            q1 : '' ,
            a : ["(listNode*)malloc(sizeof(listNode));"," listNode;","(LastNode*)malloc(sizeof(listNode));","listNode → link;"],
            r : 1,
            img:'자료구조 형성평가02.JPG'
            ,  summary:''
        },
        {//
            q : "지문 프로그램의 (나) 에 적합한 것은?",
            q1 : '' ,
            a : ["H → head = listNode → link;","H → head = LastNode;","H → head = listNode;","H → head = NewNode;"],
            r : 4,
            img:''
            ,  summary:''
        },
        {//트리
            q : "트리의 최상위 노드 혹은 부모가 없는 노드는 무엇인가?",
            q1 : '' ,
            a : ["자신노드","부모노드","잎노드","루트노드"],
            r : 4,
            img:''
            ,  summary:'트리에서 루트는 부모를 갖지 않은 노드입니다.'
        },
        {//
            q : "지문의 프로그램이 수행하는 트리 순회는 무엇인가?",
            q1 : '' ,
            a : ["중위순회","후위순회","전위순회","역순회"],
            r : 3,
            img:'자료구조 형성평가03.JPG'
            ,  summary:`트리의 각 노드를 빠짐없이 한 번씩만 방문하는 것을 순회(traverse)라고 합니다.

루트를 방문하는 순서에 따라 각각 전위(preorder) 순회, 중위(inorder) 순회, 후위(postorder) 순회라고 구분하여 부릅니다.`
        },
        {//
            q : "다음 중 완전 이진 트리는 무엇인가?",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 1,
            img:'자료구조 형성평가04.JPG'
            ,  summary:'이진 트리에서 각 레벨이 허용되는 최대 개수 노드를 가질 때 그 트리를 가득 찬(perfect) 이진 트리라고 합니다.'
        },
        {//스레드트리
            q : "이진 트리의 노드 개수를 n이라 하면, 잎 노드의 사용하지 않는 포인터 필드의 개수는 모두 몇 개인가?",
            q1 : '' ,
            a : ["n-1","n","n+1","n+2"],
            r : 3,
            img:''
            ,  summary:'노드가 n개인 이진 트리를 연결 리스트로 구현할 때 NULL 포인터는 항상 2n-(n-1) = n+1개가 존재합니다.'
        },
        {//
            q : "스레드 트리에 대한 설명으로 옳은 것은 무엇인가?",
            q1 : '' ,
            a : ["중위순회에서 사용 가능한 스레드는 후위순회나 전위순회에서는 사용할 수 없다","루트노드의 빈 포인터 필드를 활용한다.","잎 노드의 빈 포인터 필드를 활용한다.","경우에 따라서 스택을 활용하여 순회 연산을 수행한다."],
            r : 3,
            img:''
            ,  summary:'정해진 순회 방법에 따른 방문 순서를 유지하는 스레드(thread)라는 포인터를 갖는 이진 트리를 스레드 트리라고 합니다.'
        },
        {//
            q : "다음 그림의 스레드는 어떤 순회 방식은 무엇인가?",
            q1 : '' ,
            a : ["전위 순회","중위 순회","후위 순회","중복 순회"],
            r : 1,
            img:'자료구조 형성평가05.JPG'
            ,  summary:''
        },
        {//힙
            q : "다음 설명으로 옳은 것은 무엇인가 ?",
            q1 : '' ,
            a : ["우선순위 스택 : 대기 리스트에서 항상 우선순위가 높은 것을 먼저 처리하는 구조","스택 : 먼저 들어간 데이터가 먼저 삭제되는 자료구조 ","최대 힙 : 루트가 최소값인 힙","배열을 이용한 힙의 구현은 완전 이진트리이기 때문에 배열로 구현해도 기억장소 낭비가 없음"],
            r : 4,
            img:''
            ,  summary:'힙은 무엇인가를 쌓아놓은 더미이고 항상 가장 위에 있는 것을 우선 꺼내는 구조를 상징합니다. 그리고 힙은 우선순위 큐의 한 종류입니다.'
        },
        {//
            q : "지문은 무엇에 대한 설명인가 ?",
            q1 : '' ,
            a : ["선택 트리","최소 힙","최대 힙","우선 순위 큐"],
            r : 3,
            img:'자료구조 형성평가06.JPG'
            ,  summary:`최대힙은 트리의 모든 노드가 자식 노드보다 큰 값을 갖는 것을 알 수 있습니다.
            최소힙은 트리의 모든 노드가 자식 노드보다 작은 값을 갖는 것을 알 수 있습니다.`
        },
        {// 선택트리, 숲, 이진트리
            q : "차례로 정렬된 데이터 리스트 k를 완전한 순서를 유지하는 하나의 리스트로 만드는 과정을 무엇이나 하는가 ?",
            q1 : '' ,
            a : ["승자트리","패자트리","이진 선택 정렬","합병 정렬"],
            r : 4,
            img:''
            ,  summary:'합병정렬에 사용하는 특수한 트리가 선택트리입니다.'
        },
        {//
            q : "각 노드가 두 개의 자식노드 보다 더 작은 값(승자)을 갖는 완전 이진트리는 무엇인가 ?",
            q1 : '' ,
            a : ["승자트리","패자트리","숲","이진 정렬"],
            r : 1,
            img:''
            ,  summary:''
        },
        {//
            q : "지문의 그림에서  마지막 패자는 무엇인가 ?",
            q1 : '' ,
            a : [""],
            r : 0,
            img:'자료구조 형성평가07.JPG'
            ,  summary:''
        },
        {//
            q : "",
            q1 : '' ,
            a : [""],
            r : 0,
            img:''
            ,  summary:''
        },
    ]
    const test2016db :Testtype[] =[
        {//36 -233 파일명
            q : "다음 트리에 대한 설명으로 틀린 것은 무엇인가?",
            q1 : '' ,
            a : ["루트 노드 : 트리에서 부모를 갖지 않은 노드","진입 차수 : 트리에 있는 어떤 노드에 대해 그 노드에서 나가는 선의 개수"," 내부노드 :  루트도 잎노드도 아닌 노드"," 형제 (sibling) 노드 : 같은 부모를 갖는 노드들"],
            r : 2,
            img:''
            ,  summary:''
        },
        {//
            q : "다음은 연결리스트로 구현한 이진트리의 중위순회를 나타낸 것이다. 빈칸 [가], [나], [다]에 들어갈 가장 적절한 코드는?",
            q1 : '' ,
            a : ["[가] : inorder(tree_ptr->left) [나] :printf(\"%d\", tree_ptr->info) [다] :inorder(tree_ptr->right)","[가] :printf(\"%d\", tree_ptr->info) [나] :inorder(tree_ptr->left)  [다] :inorder(tree_ptr->right) ","[가] :inorder(tree_ptr->left)  [나] :printf(\"%d\", tree_ptr->info)  [다] :inorder(tree_ptr->left)","[가] :inorder(tree_ptr->left)  [나] :inorder(tree_ptr->right)  [다] :printf(\"%d\", tree_ptr->info)"],
            r : 1,
            img:'자료구조2016.JPG'
            ,  summary:''
        },
        {//38
            q : "스레드 트리에 대한 설명으로 틀린 것은 무엇인가?",
            q1 : '' ,
            a : ["잎노드의 사용하지 않는 포인터 부분을 활용할 수도 있다.","스레드는 오른쪽 스레드와 왼쪽 스레드 두가지가 있다.","기존의 트리 노드에 스레드를 위한 포인터를 추가하여 구성할 수 도 있다.","오른쪽 스레드는 정해진 순회 순서에 따른 그 노드의 선행 노드를 가리킨다."],
            r : 4,
            img:''
            ,  summary:''
        },
        {//
            q : "다음 이진트리에 대한 어떤 방문 순서를 스레드로 나타낸 것인가?",
            q1 : '' ,
            a : ["깊이 순회","후위순회","전위순회","중위순회"],
            r : 3,
            img:'자료구조201601.JPG'
            ,  summary:''
        },
        {// 40
            q : "다음 설명중에서 틀린 것은 무엇인가?",
            q1 : '' ,
            a : ["큐 : 먼저 들어간 데이터가 먼저 삭제되는 구조","우순 순위 큐 : 대기 리스트에서 항상 우선순위가 높은 것을 먼저 처리하는 구조","우순순위 큐의 작동 방식 :  삭제 명령이 실행되면 저장된 데이터 중에서 가장 작은값 (가장 큰 값)이 삭제되고, 나머지 데이터들은 특정 순서로 재배열되어 저장되어야 함","최소힢 :  루트가 전체 노드중에서 최소값인 힢"],
            r : 3,
            img:''
            ,  summary:`"우선순위 큐에서 삭제 명령이 실행되면, 저장된 데이터 중에서 가장 높은 우선순위를 가진 값(즉, 가장 작은 값 또는 가장 큰 값 중 하나, 설정에 따라 다름)이 삭제되고, 나머지 데이터들은 우선순위에 따라 재배열된다."

우선순위 큐는 최대 우선순위 큐 또는 최소 우선순위 큐로 구현될 수 있습니다.

최소 우선순위 큐: 가장 작은 값이 삭제됩니다.
최대 우선순위 큐: 가장 큰 값이 삭제됩니다.
재배열은 힙(Heap) 구조 등으로 구현하여 이루어지며, 삭제 후에도 우선순위 큐의 성질을 유지합니다.`
        },
        {//
            q : "다음은 힢의 구조체를 정의한 것과 힢에 노드를 삽입하기 위한 연산을 나타낸 것이다. 빈칸 [가]에 들어갈 가장 알맞은 코드는 무엇인가?",
            q1 : '' ,
            a : ["(item >= h -> heap[i/2]"," (item > h -> heap[i/3])","(item < h-> heap[i/2])","(item < h-> heap[i/3])"],
            r : 3,
            img:'자료구조201602.JPG'
            ,  summary:''
        },
        {//42
            q : "차례로 정렬된 데이터 리스트 k를 완전한 순서를 유지하는 하나의 리스트로 만드는 과정은 무엇인가?",
            q1 : '' ,
            a : ["합병 정렬","선택트리","승자트리","패자트리"],
            r : 1,
            img:''
            ,  summary:`합병 정렬 (Merge Sort):

특징: 분할 정복 알고리즘의 한 종류로, 배열을 절반씩 나누어 정렬한 후 다시 합치는 방식.
시간 복잡도: O(n log n)
장점: 안정적인 정렬이며, 항상 O(n log n) 성능을 보장.
단점: 추가적인 메모리 공간이 필요함.
선택 트리 (Selection Tree):

특징: 여러 정렬된 리스트에서 최소 값을 빠르게 선택하기 위해 사용되는 트리.
사용처: 다중 테이프 정렬(multi-way merge)에서 여러 테이프를 병합할 때 사용.
장점: 각 리스트의 최소 값 선택이 효율적임.
단점: 트리의 높이가 커지면 비교 횟수가 증가.
승자 트리 (Winner Tree):

특징: 내부 노드에 비교에서 이긴 값(최소 또는 최대)을 저장하는 트리.
사용처: 다중 리스트 병합, 특히 K개의 정렬된 리스트를 병합할 때 유리.
장점: 각 노드에서 최적의 값이 올라오므로 빠르게 승자를 찾을 수 있음.
시간 복잡도: O(log k) (k는 리스트의 개수)
패자 트리 (Loser Tree):

특징: 승자 트리와 유사하지만, 내부 노드에 비교에서 진 값(패자)을 저장하는 트리.
장점: 새로운 값이 들어올 때 트리의 재구성 과정이 승자 트리보다 간단.
시간 복잡도: O(log k)`
        },
        {//43
            q : "노드 vi의 왼쪽 서브트리 노이와 vi의 오른쪽 서브트리 높이가 최대 1만큼 차이가 난다는 조건을 만족하는 트리는 무엇인가?",
            q1 : '' ,
            a : ["이진 탐색 트리","AVL트리","병렬트리","레드 블랙 트리"],
            r : 2,
            img:''
            ,  summary:''
        },
        {//
            q : "모든 키값이 잎에 있고 그 키값에 대응하는 실제 데이터에 대한 주소를 잎 노드만이 가지고 있어서 인덱스된 순차 파일을 구성하는데 사용하는 트리는 무엇인가?",
            q1 : '' ,
            a : ["B 트리","B* 트리","splay 트리","B+ 트리"],
            r : 4,
            img:''
            ,  summary:`B 트리:

특징: 자식 노드가 여러 개 있는 균형 이진 트리로, 노드 하나에 여러 키를 저장할 수 있음. 각 노드는 특정 범위의 자식 노드를 가리키며, 데이터베이스와 파일 시스템에서 자주 사용됨.
장점: 데이터가 디스크에 저장된 경우에도 효율적이며, 검색, 삽입, 삭제가 모두 O(log n) 시간에 가능.
사용처: 대용량 데이터에서 빠른 검색을 위해 사용.
B 트리*:

특징: B 트리의 변형으로, 노드가 더 많이 채워지도록 하여 노드 분할을 더 적게 일으킴. B 트리에 비해 노드 공간 활용률이 더 높음.
장점: B 트리에 비해 더 많은 데이터를 저장할 수 있으며, 분할이 적어 성능이 향상됨.
사용처: B 트리와 유사한 용도로 사용되며, 자주 분할이 일어나지 않도록 개선됨.
Splay 트리:

특징: 자주 사용되는 요소를 루트로 올려서 이후 검색 시간을 줄이는 자가 균형 이진 검색 트리. 삽입, 삭제, 검색이 일어날 때마다 해당 노드를 루트로 이동시키는 splaying 연산을 사용.
장점: 자주 접근되는 데이터에 대해 효율적이며, 최근 사용된 데이터는 더 빠르게 접근 가능.
시간 복잡도: 최악의 경우 O(n)이지만, 평균적으로 O(log n).
B+ 트리:

특징: B 트리의 변형으로, 내부 노드는 키만 저장하고, 모든 데이터는 리프 노드에만 저장됨. 리프 노드들이 링크드 리스트로 연결되어 있어 순차 접근이 용이함.
장점: 순차적인 데이터 검색이 빠르고, 범위 쿼리(range query)에 적합함.
사용처: 데이터베이스 인덱스에서 자주 사용됨.`
        },
        {//45
            q : "다음은 2-3 트리의 노드 구조와 탐색 연산을 나타낸 것이다.  코드에 대한 설명으로 틀린 것은? (단, lchild, mchild, rchild는 왼쪽자식, 중간자식, 오른쪽 자식을 가리키는 포인터고, compate(x,t)함수는 검색키 x와 노드 t의 키값을 비교하는 함수이다)",
            q1 : '' ,
            a : ["2-3 트리 노드의 데이터 구조를 보면 키값을 두 개까지 가질 수 있다.","compare(x,t)는 x가 비교하는 트리 노드의 키값 중 어느것 과 같은 경우 4를 반환한다.","compare(x, t)는 x가 비교하는 트리 노드의 왼쪽 키값보다 크고 오른쪽 키 값보다 작은 경우 2를 반환한다.","compare(x, t)는 x가 비교하는 트리 노드의 오른쪽 키값보다 큰 경우 1을 반환한다."],
            r : 4,
            img:'자료구조201603.JPG'
            ,  summary:''
        },
        {//46
            q : "다음 그래프에 대한 설명으로 틀린 것은 무엇인가?",
            q1 : '' ,
            a : ["인접 : 두정점이 간선으로 연결되었을 때  두 정점은 인접함"," 인접 행렬 :  그래프의 표현방법의 하나로 정점 사이의 인접성을 행렬로 나타낸 것","그래프 : 정점 집합 v와 간선 집합 E에 대하여 그래프는 G=(V,E)"," 간선 :  시작점과 끝점이 같은 경로"],
            r : 4,
            img:''
            ,  summary:''
        },
        {//47
            q : "그래프에서 특정 정점에서 시작하여 모든 형제를 방만한 후 자손을 방문하는 탐색 방법은 무엇인가?",
            q1 : '' ,
            a : ["너비 우선 탐색","깊이 우선탐색","솔린 탐색방법","크루스컬 탐색 방법"],
            r : 1,
            img:''
            ,  summary:''
        },
        {// 48
            q : "다음 [그래프 G] 를 인접 행렬로 표현했을 때, 가장 옳은 것은 무엇인가?",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 4,
            img:'자료구조201604.JPG'
            ,  summary:''
        },
        {//49
            q : "다음 중 그래프에 대한 설명으로 옳지 않은 것은>??",
            q1 : '' ,
            a : ["간선의 시작점과 끝점이 같은 정점의 길이가 1인 경로를 루프(loop)라고 한다.","트리는 그래프의 일종으로, 그래프에서 사이클이 없는 특수한 경우를 말한다."," 방향 그래프에서 진입 차수는 주어진 정점에서 시작하는 간선의 개수를 말한다.","무방향 그래프의 차수는 그 정점이 연결된 간선들의 개수이다."],
            r : 3,
            img:''
            ,  summary:''
        },
        {//
            q : "다음 중 스택의 응용에 대한 설명이 아닌 것은 무엇인가?",
            q1 : '' ,
            a : ["중앙처리 장치 할당을 위한 RR기법","서브루틴의 수행이 끝난 후에 되돌아갈 함수 주소 저장","프로그램에서 사용되는 변수들의 생명주기 관리"," 연산자들 간의 우선순위에 의해 계산 순서가 결정되는 수식 계산"],
            r : 1,
            img:''
            ,  summary:''
        },
        {//51
            q : "자료의 복잡한 논리적 성격을 정의하는 형식으로 자료 값의 집합과 연산 집합에 대한 명세의 집합을 무엇이라 하는가?",
            q1 : '' ,
            a : ["추상화 집합","알고리즘","자료형","추상 자료형"],
            r : 4,
            img:''
            ,  summary:''
        },
        {//52
            q : "배열에 대한 설명으로 틀린 것은 무엇인가?",
            q1 : '' ,
            a : ["인덱스와 원소값(<index, value>) 의 쌍으로 구성된 집합이다.","원소들이 모두 같은 자료형이다.","구성 원소들의 논리적 관계와 원소의 저장 위치는 무관하다.","메모리의 주소값과 추상화된 인덱스값이 관련되어 있다."],
            r : 3,
            img:''
            ,  summary:''
        },
        {//
            q : "아래는 배열값의 저장을 나타낸 것이다. [가]에 들어갈 가장 알맞은 코드는 무엇인가?",
            q1 : '' ,
            a : ["i >= 0 && i < array_size","i >= 0 || i < array_size"," i <= 0 && i < array_size","i <= 0 || i < array_size"],
            r : 1,
            img:'자료구조201605.JPG'
            ,  summary:''
        },
        {// 54 
            q : "파이프의 입구와 출구 부분을 연결시킨 형태의 큐로 기억장소의 낭비를 줄이기 위한 자료구조는 무엇인가?",
            q1 : '' ,
            a : ["연결 큐","이중 큐","원형 큐","데 큐"],
            r : 3,
            img:''
            ,  summary:''
        },
        {//
            q : "다음 [가]와 [나]에 알맞은 것은 무엇인가?",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 2,
            img:'자료구조201606.JPG'
            ,  summary:''
        },
        {//56
            q : "다음 중 연결리스트에 대한 설명으로 틀린 것은 무엇인가?",
            q1 : '' ,
            a : ["데이터가 '논리적인 순서' 혹은 리스트에 나타나는 원소들 간의 '의미적인 순서'를 유지한다.","원소의 순서가 메모리 공간에서의 물리적 순서를 의미한다","원소들의 물리적인 저장 순서나 위치와는 무관하게 원소들 간의 논리적인 순서만 유지해주면 된다."," 배열을 이용하여 구현할 수 있다."],
            r : 2,
            img:''
            ,  summary:''
        },
        {//
            q : "다음 10과 3.14를 출력하기 위해 [가] 와  [나] 에 알맞은 것은 무엇인가?",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 4,
            img:'자료구조201607.JPG'
            ,  summary:''
        },
        {//58 그림문제
            q : "다음 프로그램에 대한 물음에 답하시오 (아래 두문제)",
            q1 : '' ,
            a : [""],
            r : 0,
            img:'자료구조201608.JPG'
            ,  summary:''
        },
        {//
            q : "14번 라인을 수행한 결과로 옳은 것은 무엇인가?",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 1,
            img:'자료구조201609.JPG'
            ,  summary:''
        },
        {// 59
            q : "15번 라인을 실행한 결과로 옳은 것은 무엇인가?",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 4,
            img:'자료구조201610.JPG'
            ,  summary:''
        },
        {//60
            q : "다음은 스택의 연산들이다 4를 수행한 결과는 무엇인가?",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 2,
            img:'자료구조201611.JPG'
            ,  summary:''
        },
    ]
    const test2017db :Testtype[] =[
        {//36
            q : "아래의 문장을 수식으로 표현한 것으로 알맞은 것은?",
            q1 : '' ,
            a : ["R = P(D), (R: 결과, D : 자료, P : 처리)","I = P(R) , (I : 정보, R : 결과, P : 처리)","P = R(D), (R : 결과, D:자료, P : 처리)", "I =P(D) , (I : 정보, D: 자료, P : 처리)"],
            r : 4,
            img:'자료구조2017.JPG'
            ,  summary:''
        },
        {//37
            q : "현실 세계에서 관찰이나 측정을 통해 수집된 값이나 사실을 무엇이라 하는가?",
            q1 : '' ,
            a : ["자료","정보","자료구조","추상화"],
            r : 1,
            img:''
            ,  summary:''
        },
        {
            q : "다음 설명 중 틀린 것은 무엇인가?",
            q1 : '' ,
            a : ["배열은 인덱스와 원소값의 쌍으로 구성된다.","배열의 순서는 원소값이 저장되는 물리적인 위치와 아주 밀접한 상관이 있다.","배열의 인덱스값을 이용해서 원소값에 직접 접근한다.","배열의 각 원소값의 의미적인 순서는 인덱스의 순서와 일치한다"],
            r : 4,
            img:''
            ,  summary:''
        },
        {//39
            q :  "다음 설명 중 틀린 것은 무엇인가?",
            q1 : '' ,
            a : ["스택은 자료의 삽입과 삭제가 같은 변수를 통해 제어된다.","스택은 객체와 객체가 저장되는 순서를 기억하는 방법에 관한 추상 자료형이다.","스택의 크기는 가변적이다.","후위 표기식은 연산자를 피연산자의 뒤에 표기하는 방법이다"],
            r : 3,
            img:''
            ,  summary:''
        },
        {//40
            q : "다음 큐에 대한 설명으로 틀린 것은 무엇인가?",
            q1 : '' ,
            a : ["원형 큐의 입구(rear 변수)와 출구(front 변수)를 연결하여 데이터 공간을 연속적으로 사용하기 위해 제안되었다.","큐는 서로 다른 부분에서 삽입과 삭제가 바생하는 fifo 특성을 갖는 순서리스트이다.","큐가 가득 차는 경우는 삽입되는 부분의 rear 변수와 삭제되는 부분의 front 변수를 이용하여 찾아낸다.","삽입되는 부분의 rear 변수가 마지막을 가리키면, 큐에 포함된 원소의 갯수는 큐의 크기와 같고 큐가 가득 찬 경우이다"],
            r : 4,
            img:''
            ,  summary:'원형 큐에서 rear 변수가 마지막을 가리킨다고 해서 큐가 가득 찼다는 보장은 없습니다. 큐가 가득 차려면 rear와 front의 위치 관계에 따라 판단해야 하며, rear가 front와 인접해 있을 때 큐가 가득 찬 상태입니다. 큐의 마지막 자리에 있다고 해서 반드시 가득 찬 것은 아니다.'
        },
        {// 41
            q : "단순 연결리스트의 사용되지 않는 마지막 노드의 링크 부분을 활용하기 위해 제안된 리스트는 무엇인가?",
            q1 : '' ,
            a : ["원형 연결 리스트","이중 연결 리스트"," 복합 연결 리스트","순서 연결 리스트"],
            r : 1,
            img:''
            ,  summary:''
        },
        {//42
            q : "다음 이진 트리의 후위순회 결과는 무엇인가?",
            q1 : '' ,
            a : ["ABCD","CABD","DBAC","BCDA"],
            r : 4,
            img:'자료구조201701.JPG'
            ,  summary:`후위 순회(Postorder traversal)는 왼쪽 자식 → 오른쪽 자식 → 루트의 순서로 노드를 방문합니다. 
            주어진 트리에서 후위 순회를 적용해보겠습니다 왼쪽 서브트리: B
오른쪽 서브트리: C의 오른쪽 자식은 D
C의 왼쪽 자식은 없으므로, D를 먼저 방문하고 C를 방문합니다.
루트: A
따라서 후위 순회 결과는 B → D → C → A가 됩니다.
"B->C->D->A"라고 생각했지만, 실제로는 BDCA가 후위 순회 결과입니다`
        },
        {//43
            q : "다음 설명 중 틀린 것은 무엇인가?",
            q1 : '' ,
            a : ["트리는 논리적 계층을 표현하는 자료구조이다.","트리에서 루트는 부모가 없는 노드이다.","트리에서 각 노드의 차수는 진출차수이다."," 이진트리는 모든 노드의 차수가 2인 트리이다."],
            r : 4,
            img:''
            ,  summary:''
        },
        { //44
            q : "널 링크를 이용하여 이진 트리 순회를 편리하고 빠르게 향상시킨 트리는 무엇인가",
            q1 : '' ,
            a : ["경사 이진트리","스레드 이진트리","포화 이진트리","균형 이진트리"],
            r : 2,
            img:''
            ,  summary:''
        },
        { //45
            q : "다음 전위 순회 스레드 트리의 전위 순회에서 빈칸 [가] 에 알맞은 것은 무엇인가?",
            q1 : '' ,
            a : ["p = p->left"," p = p->right;","p = p->left->right;","p = p->right -> left"
            ],
            r : 1,
            img:'자료구조201702.JPG'
            ,  summary:''
        },
        {//47
            q : "선택트리에 대한 설명으로 틀린 것은 무엇인가?",
            q1 : '' ,
            a : ["선택 트리에서는 승자트리와 패자트리가 있다.","패자트리는 루트 노드 위에 최상위 0번 노드를 갖는다.","승자트리는 루트 노드 위에 최상위 0번 노드를 가지며, 각 노드가 두 자식노드보다 더 작은 값을 갖는다","선택트리를 사용하면 정렬을 위한 합병 횟수를 줄일 수 있다."],
            r : 3,
            img:''
            ,  summary:''
        },
        {//48
            q : "자주 탐색하는 키를 가진 노드를 루트에 가깝게 위치하는 트리는 무엇인가?",
            q1 : '' ,
            a : ["Splay 트리","BS트리","BB트리","AVL 트리"],
            r : 1,
            img:''
            ,  summary:`1. Splay 트리 (Splay Tree)
**자기조정 이진 검색 트리(Self-adjusting Binary Search Tree)**입니다.
트리에서 최근에 접근한 노드를 트리의 루트로 이동시킵니다.
이 과정을 Splaying이라고 하며, 빈번하게 접근하는 데이터에 빠르게 접근할 수 있도록 최적화되어 있습니다.
최악의 경우에도 시간 복잡도는 O(n)이지만, 평균적으로 **O(log n)**의 성능을 유지합니다.
삽입, 삭제, 탐색 연산이 모두 splay 과정을 통해 동적으로 트리를 재구성합니다.
2. BS 트리 (Binary Search Tree, BST)
**이진 검색 트리(Binary Search Tree)**는 각 노드의 왼쪽 자식은 부모보다 작고, 오른쪽 자식은 부모보다 큰 특성을 가집니다.
탐색, 삽입, 삭제 연산의 평균 시간 복잡도는 **O(log n)**이지만, 트리가 편향되면 최악의 경우 **O(n)**이 됩니다.
구조가 단순하여 구현하기 쉽지만, 균형이 잘 맞지 않으면 성능이 떨어질 수 있습니다.
3. BB 트리 (Balanced Binary Tree)
균형 이진 트리는 모든 하위 트리의 높이 차이가 일정 범위 내에 있도록 유지되는 트리입니다.
대표적인 예로는 AVL 트리, 레드-블랙 트리 등이 있습니다.
트리의 균형을 유지하기 위해 **삽입, 삭제 연산 시 트리의 재구성(회전)**이 필요합니다.
트리가 균형을 이루기 때문에 탐색, 삽입, 삭제 연산은 **O(log n)**의 시간 복잡도를 보장합니다.
4. AVL 트리 (Adelson-Velsky and Landis Tree)
이진 검색 트리의 일종으로, 자기 균형 이진 검색 트리입니다.
각 노드의 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이가 1 이하로 유지되도록 트리를 관리합니다.
삽입, 삭제 시 트리가 불균형해질 수 있는데, 이를 회전(Rotation) 연산을 통해 균형을 맞춥니다.
항상 균형을 유지하기 때문에 탐색, 삽입, 삭제 연산의 시간 복잡도는 **O(log n)**입니다.`
        },
        { //49
            q : "차수가 m인 B트리의 조건으로 틀린 것은 무엇인가?",
            q1 : '' ,
            a : ["루트와 단발 노드를 제외한 트리의 각 노드는 최소 [m/2]개의 서브트리를 갖는다","트리의 모든 단말 노드는 같은 레벨에 있다","트리의 루트는 퇴소한 2개의 서브트리를 갖는다"," 잎 노드를 순차적으로 연결하는 포인터 집합이 있다"],
            r : 4,
            img:''
            ,  summary:''
        },
        { //50
            q : "다음과 같은 트리는 무엇인가",
            q1 : '' ,
            a : ["이진 트리","1-2 트리","2-3 트리","2-3-4 트리"],
            r : 3,
            img:'자료구조201703.JPG'
            ,  summary:''
        },
        {//51
            q : "그래프에 대한 설명으로 틀린 것은 무엇인가?",
            q1 : '' ,
            a : ["두 정점이 사이클로 연결되었을때, 두 정점이 인접하다고 정의한다.","사이클이 없는 그래프를 트리 혹은 두사이를 그래프라 한다","한 정점에서 출발하여 자신으로 연결하는 간선을 루프라고 한다","시작점과 끝점이 같은 경로를 사이클이라고 한다"],
            r : 1,
            img:''
            ,  summary:''
        },
        { //52
            q : "그래프 G의 모든 정점과 간선의 일부를 포함하는 트리는 무엇인가?",
            q1 : '' ,
            a : ["m원 트리","균형 트리","신장 트리","이진탐색트리"],
            r : 3,
            img:''
            ,  summary:''
        },
        { //53
            q : "다음중 m원 탐색트리에 대한 설명으로 틀린것은 무엇인가? {p0,p1,.....pn은 서브트리에 대한 포인터이고 k0, ....,kn-1은 키값이다. 또한 n<= m-1 이 성립한다)",
            q1 : '' ,
            a : ["노드 vi의 키를 ki라 할때, vi의 왼쪽 서브트리에 있는 모든 노드의 키값은 vi의 키값보다 작다.","i=0,...,n-2 인 i 에 대해 ki < ki+1 를 만족한다 ","i=0,...,n-1인 i에 대해 pi가 가리키는 서브트리의 모든 킷값은 ki의 킷값보다 작다","pn이 가리키는 서브트리의 모든 키값은 kn-1의 킷값보다 크다."],
            r : 1,
            img:''
            ,  summary:''
        },
        { //54
            q : "다음중 B트리에 대한 설명으로 틀린 것은?",
            q1 : '' ,
            a : ["루트와 단말 노드를 제외한 트리의 각 노드는 최소 [m/2]개의 서브트리를 갖는다.","트리의 루트는 최소한 2개의 서브트리를 갖는다","트리의 모든 단말노드는 같은 레벨에 있다","루트가 가장 작은 값을 갖고 부모는 자식보다 작은 값을 갖는다" ],
            r : 4,
            img:''
            ,  summary:''
        },
        {//55
            q : "다수의 간선을 선택하고 그래프의 모든 정점들로 구성된 숲에서 시작하여 최소 비용 신장 트리를 결정하는 방법은 무엇일까?",
            q1 : '' ,
            a : ["Prim 방법","DFS 방법","Kruscal 방법","BFS 방법"],
            r : 3,
            img:''
            ,  summary:`Prim 방법: 하나의 정점에서 시작하여 최소 신장 트리를 만드는 알고리즘.
DFS 방법: 깊이 우선 탐색, 스택이나 재귀를 이용해 그래프를 탐색.
Kruskal 방법: 간선의 가중치를 기준으로 최소 신장 트리를 만드는 알고리즘.
BFS 방법: 너비 우선 탐색, 큐를 이용해 레벨별로 탐색.`
        },
        {//56
            q : "다음은 스택의 연산들이다, 6을 수행한 결과는 무엇인가?",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 4,
            img:'자료구조201704.JPG'
            ,  summary:''
        },
        {//57
            q : "다음은 G1에 대한 인접리스트를 표현한 것이다. G1에 대한 그래프로 알맞은 것은?",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 1,
            img:'자료구조201705.JPG'
            ,  summary:''
        },
        {//58
            q : "다음은 깊이 우선 탐색(DFS) 알고리즘의 의사코드이며 해당 코드는 순환 호출을 이용하는 경우이다. 이때 [그림1]의 v7 노드에 방문하기 위해선 몇번의 7 코드가 실행되는가?",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 3,
            img:'자료구조201706.JPG'
            ,  summary:''
        },
        {
            q : "다음은 큐를 이용한 너비 우선 탐색(BFS) 알고리즘의 의사코드이다. 아래의 코드에서 빈 칸 ㄱ, ㄴ에 들어갈 알맞은 코드는 무엇인가?",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 2,
            img:'자료구조201707.JPG'
            ,  summary:''
        },
        {
            q : "위의 [그림1]을 너비 우선 탐색(BFS) 알고리즘으로 탐색할 때의 노드 방문순서로 옳은 결과는 무엇인가?",
            q1 : '' ,
            a : ["v1,v2,v4,v5,v3,v6,v7","v1,v2,v3,v6,v5,v4,v7","v1,v2,v3,v4,v5,v6,v7","v1,v2,v4,v7,v3,v5,v6"],
            r : 3,
            img:'자료구조201708.JPG'
            ,  summary:''
        },
        
    ]
    const test2018db :Testtype[] =[
        {//36
            q : "I=P(D)의 해석으로 옳은것은?",
            q1 : '' ,
            a : ["정보는 자료를 처리해서 얻어진 결과다","정보는 결과를 처리해서 얻어진 자료이다","자료는 결과를 처리해서 얻어진 정보다","자료는 정보를 처리해서 얻어진 결과다"],
            r : 1,
            img:''
            ,  summary:''
        },
        {//37
            q : "자료구조의 유형 중 미리 정의된 자료구조인 것은 무엇인가",
            q1 : '' ,
            a : ["배열","스택","큐","트리"],
            r : 1,
            img:''
            ,  summary:''
        },
        {//38
            q : "다음 수식을 전위 표기식으로 바르게 나타낸 것은?",
            q1 : '' ,
            a : ["++AB*CD","ABCD++*","++*ABCD","AB+B+C*"],
            r : 1,
            img:'자료구조2018.JPG'
            ,  summary:''
        },
        {//39
            q : "다음 일반 트리를 이진트리로 변환한 것으로 옳은 것은?",
            q1 : '' ,
            a :  ["1","2","3","4"],
            r : 1,
            img:'자료구조201801.JPG'
            ,  summary:''
        },
        {//40
            q : "알고리즘의 조건에 포함되지 않는 것은?",
            q1 : '' ,
            a : ["출력","입력","절대성","유한성"],
            r : 3,
            img:''
            ,  summary:''
        },
        {//41
            q : "인덱스와 원소값(<index, value>)의 쌍으로 구성된 집합이며 정의된 각 인덱스는 그 인덱스와 관련된 값으로 정의되는 자료구조는 무엇인가?",
            q1 : '' ,
            a : ["리스트","스택","배열","큐"],
            r : 3,
            img:''
            ,  summary:''
        },
        {//42
            q : "다음과 같은 행렬이 행우선 방식으로 저장된다면, [3,4]의 다음에 저장되는 행렬의 원소는 무엇인가?",
            q1 : '' ,
            a : ["[3,5]","[3,3]","[4,4]","[4,3]"],
            r : 1,
            img:'자료구조201802.JPG'
            ,  summary:''
        },
        {//43
            q : "다음은 스택에 대한 연산이다. 교재에 기술된 스택의 추상자료형을 따른다면, 8 연산을 수행한 후의 스택의 모습은 무엇인가?",
            q1 : '' ,
            a :  ["1","2","3","4"],
            r : 1,
            img:'자료구조201803.JPG'
            ,  summary:''
        },
        {//44
            q : "큐의 운용과 유사하게 운영되는 것이 아닌 것은 무엇인가",
            q1 : '' ,
            a : ["문서 출력을 위해 프린터기를 이용할 때, 여러개의 문서를 출력해도 먼저 인쇄버튼을 누른 문서부터 차례로 출력된다.","은행에서 번호표를 뽑고 창구에 가기를 기다린다","택시 승강장에서 택시를 기다린다","웹브라우저에서 방금전 방문했던 사이트 기록 저장 후 이전페이지로 돌아가기를 클릭한다"],
            r : 4,
            img:''
            ,  summary:''
        },
        {//45
            q : "다음은 큐에대한 연산이다 교재에 기술된 큐의 추상자료형을 따른다면 8 연산을 수행한 후의 스택 모습은 무엇인가?",
            q1 : '' ,
            a :  ["1","2","3","4"],
            r : 3,
            img:'자료구조201804.JPG'
            ,  summary:'그림이 잘못되었다 맨 밑에칸에 D가 있어야하는데  위치가 2번째 칸으로 되어있어 틀림 정답은 없는상태임'
        },
        {// 46
            q : "단순 연결리스트의 사용되지 않는 마지막 노드의 링크 부분을 활용하기 위해 제안된 리스트는 무엇인가?",
            q1 : '' ,
            a : ["이중 연결 리스트","원형 연결 리스트","회전 연결 리스트","중복 연결 리스트"],
            r : 2,
            img:''
            ,  summary:''
        },
        {// 47
            q : "사용하지 않는 포인터를 이용하여 이진 트리 순회를 편리하고 빠르게 향상시킨 트리는 무엇인가",
            q1 : '' ,
            a : ["탐색 이진트리","스레드 이진트리"," 포화이진트리","완전 이진트리"],
            r : 2,
            img:''
            ,  summary:''
        },
        {//48
            q : "각 노드가 두개의 자식노드 보다 더 큰 값(패자)을 가지며 최종 승자는 0번 노드에 저장하는 트리는 무엇인가?",
            q1 : '' ,
            a : ["선택 트리","패자트리","승자트리"," AVL트리"],
            r : 2,
            img:''
            ,  summary:`1. 선택 트리 (Selection Tree)
선택 트리는 여러 정렬된 리스트에서 최소값을 빠르게 선택하기 위해 사용되는 트리 구조입니다.
다수의 정렬된 입력에서 가장 작은 값을 선택하는 작업을 효율적으로 처리합니다.
이 트리는 일반적으로 최소값을 찾고, 그 값을 빼내면서 새로운 최소값을 트리에 삽입하는 과정을 반복합니다.
**K-방향 병합(K-way merging)**에서 주로 사용됩니다.
2. 패자 트리 (Loser Tree)
패자 트리는 선택 트리의 일종으로, K개의 정렬된 리스트에서 최소값을 선택하는 트리입니다.
각 노드는 패배자(비교에서 작은 값을 가진 노드)를 저장합니다.
트리의 루트에는 승자(가장 작은 값)가 위치하지 않으며, 승자가 아닌 값이 트리 내부 노드에 저장되는 방식입니다.
최소값을 찾는 연산과 다음 최소값을 구하는 연산이 효율적으로 처리됩니다.
3. 승자 트리 (Winner Tree)
승자 트리는 패자 트리와 반대로, K개의 정렬된 리스트에서 **승자(최소값)**를 저장하는 트리입니다.
트리의 루트에는 항상 가장 작은 값이 저장됩니다.
승자 트리는 각 노드가 두 자식 중 큰 값을 저장하고, 루트에는 전체 트리에서 가장 작은 값이 위치합니다.
트리를 갱신할 때, 루트에서 리프까지 경로만 갱신하면 되므로 효율적입니다.
4. AVL 트리 (Adelson-Velsky and Landis Tree)
AVL 트리는 **자기 균형 이진 검색 트리(Self-balancing Binary Search Tree)**입니다.
각 노드에서 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이가 1 이하로 유지됩니다.
삽입이나 삭제 시 트리의 균형이 깨지면 회전(Rotation) 연산을 통해 균형을 맞춥니다.
탐색, 삽입, 삭제 연산의 시간 복잡도가 항상 **O(log n)**을 보장합니다.
트리의 균형을 유지하기 위해 추가적인 작업이 필요하지만, 항상 빠른 탐색 속도를 제공합니다.`
        },
        {//49
            q : "트리에 속한 잎 노드의 개수를 무엇이라 하는가?",
            q1 : '' ,
            a : ["트리의 깊이","트리의 높이","트리의 무게","트리의 경로"],
            r : 3,
            img:''
            ,  summary:''
        },
        {//50
            q : "노드 vi의 왼쪽 서브트리 높이와 vi의 오른쪽 서브트리 높이가 최대 1만큼 차이난다는 조건을 만족하는 트리는 무엇인가?",
            q1 : '' ,
            a : ["Splay트리"," BS트리","BB트리","AVL트리"],
            r : 4,
            img:''
            ,  summary:''
        },
        {//51
            q : "그래프에 대한 설명으로 옳은 것은 무엇인가?",
            q1 : '' ,
            a : ["사이클이 없는 그래프를 트리라고 한다","두 정점이 사이클로 연결되었을 때 , 두 정점이 인접한다고 정의한다"," 시작점과 끝점이 같은 경로를 루프라고 한다.","한 정점에서 출발하여 자신으로 연결하는 간선을 사이클이라고 한다."],
            r : 1,
            img:''
            ,  summary:''
        },
        {//52
            q : "다음과 같은 트리는 무엇인가?",
            q1 : '' ,
            a : ["이진 트리","1-2 트리","2-3 트리","2-3-4 트리"],
            r : 4,
            img:'자료구조201805.JPG'
            ,  summary:`이진 트리: 각 노드는 최대 2개의 자식을 가짐.
1-2 트리: 각 노드는 1개 또는 2개의 자식을 가짐.
2-3 트리: 각 노드는 2개 또는 3개의 자식을 가짐. 모든 리프 노드의 깊이가 같음.
2-3-4 트리: 각 노드는 2개, 3개, 또는 4개의 자식을 가짐. 삽입, 삭제 시 트리가 균형을 유지함.`
        },
        {//53
            q : "다음중 B트리에 대한 설명으로 옳은 것은 무엇인가?",
            q1 : '' ,
            a : ["트리의 루트는 최소한 3개의 서브트리를 갖는다","트리의 모든 잎 노드는 같은 레벨에 있다.","루트가 가장 작은 값을 갖고 부모는 자식보다 작은 값을 갖는다","루트와 잎 노드를 제외한 트리의 각 녿느느 최소 [m/3]개의 서브트리를 갖는다."],
            r : 2,
            img:''
            ,  summary:''
        },
        {// 54
            q : "남은 간선중에서 무조건 최소 비용인 간선을 선택한 후 사이클을 형성하지 않으면 그 간선을 선택하는 최소 비용 신장트리 결정방법은 무엇인가?",
            q1 : '' ,
            a : ["Prim방법","DFS 방법","Kruscal 방법","BFS 방법"],
            r : 3,
            img:''
            ,  summary:`Prim 방법: 시작 정점에서 시작해 최소 가중치 간선을 선택해 최소 신장 트리를 만드는 탐욕 알고리즘.
DFS 방법: 깊이 우선 탐색으로 스택이나 재귀 호출을 사용해 그래프의 끝까지 탐색하는 방법.
Kruskal 방법: 모든 간선 중 최소 가중치를 차례로 선택해 최소 신장 트리를 만드는 탐욕 알고리즘.
BFS 방법: 너비 우선 탐색으로 큐를 사용해 가까운 노드부터 탐색하는 방법, 최단 경로 탐색에 유용.`
        },
        {// 55
            q : "두 정점쌍이 간선을 여러개 가질 수 있는 그래프를 무엇이라고 하는가?",
            q1 : '' ,
            a : ["중복 그래프"," 무방향 그래프","다중 그래프","단순 그래프"],
            r : 3,
            img:''
            ,  summary:''
        },
        {// 56
            q : "다음 프로그램은 교재에서 정의된 이중 연결 리스트에 새 노드를 삽입하는 연산이다. 프로그램의 흐름상 다음 빈칸 ㄱ 에 들어갈 알맞은 코드는 무엇인가?",
            q1 : '' ,
            a : ["NewNode -> Rlink -> Link = NewNode","prevNode -> Link ->Rlink = NewNode","prevNode -> Rlink -> Link = NewNode","NewNode -> Rlink -> Link = prevNode"],
            r : 1,
            img:'자료구조201806.JPG'
            ,  summary:''
        },
        {// 57
            q : "다음 표에서 (가),(나)의 순서대로 가장 적합한 내용은 무엇인가?",
            q1 : '' ,
            a : ["프로그램. 알고리즘","자료구조, 알고리즘","슈도 코드, 프로그램","알고리즘, 프로그램"],
            r : 4,
            img:'자료구조201807.JPG'
            ,  summary:''
        },
        {// 58
            q : "다음은 깊이 우선탐색(DFS)알고리즘의 의사코드이며 해당 코드는 순환 호출을 이용하는 경우이다. 다음 알고리즘에서 ㄱ 과 ㄴ 에 들어갈 알맞은 명령어는 무엇인가?",
            q1 : '' ,
            a : ["ㄱ : VISITED[v] =0; ㄴ: if(!q_empty())","ㄱ : VISITED[v] = 0;  ㄴ : if(VISITED[w])","ㄱ : VISITED[v] = 1  ㄴ: if(!VISITED[w])","ㄱ : VISITED[v] = 1   ㄴ : if(!VISITED[v])"],
            r : 3,
            img:'자료구조201808.JPG'
            ,  summary:''
        },
        {//
            q : "다음 배열을 이용해 스택을 구현하고 스택에 데이터를 삽입하는 과정을 나타내는 코드이다 [가]에 들어갈 코드로 가장 알맞은 것은 무엇인가?",
            q1 : '' ,
            a : ["top == -1","top >= STACK_SIZE - 1"," top >= STRACK_SIZE","top <= STACK_SIZE"],
            r : 2,
            img:'자료구조201809.JPG'
            ,  summary:''
        },
        {// 
            q : "다음 프로그램은 최소 힙에서 데이터를 삽입하는 프로그램이다. 아래 그림은 최소 힙에 새 노드를 삽입하기 위해 마지막 노드에 새노드인 7이 위치한 모습이다. 새 노드인 7이 삽입한 후 완전한 최소 힙이 되도록 하려면 [가] 부분이 몇번 이루어져야 하는가?",
            q1 : '' ,
            a : ["0","1","2","3"],
            r : 3,
            img:'자료구조201810.JPG'
            ,  summary:`최소 힙에서 데이터를 삽입하는 과정
데이터 추가: 먼저 데이터를 힙의 마지막 자리에 추가합니다. 힙은 완전 이진 트리이므로, 트리의 가장 오른쪽 리프 노드 자리에 데이터를 삽입합니다.

부모와 비교: 삽입한 데이터가 부모 노드보다 작은지 확인합니다. 만약 삽입된 노드의 값이 부모 노드보다 작으면, 두 값을 교환합니다.

재귀적 비교: 교환 후, 부모 노드와의 관계를 다시 확인하고, 더 이상 부모 노드보다 작지 않을 때까지 위로 올라가며 비교를 반복합니다.

최종 정렬 완료: 부모보다 작은 값이 없거나 루트에 도달하면 힙이 완성됩니다.`
        },
    ]
    const test2017cs :Testtype[] =[
        {//
            q : "다음중 컴퓨터 명령어를 구성하는 연산코드 필드 (op code filed)에 대한 설명으로 가장 적절한 것은?",
            q1 : '' ,
            a : ["기억장치 주소 혹은 처리장치 레지스터를 선택하기 위한 필드이다.","중앙처리장치에서 수행할 연산을 지정하는 필드이다.","명령어의 주소지정방식을 지정하는 필드이다","인터럽트 요청을 위한 제어필드이다."],
            r : 2,
            img:''
            ,  summary:''
        },
        {//
            q : "다음 컴퓨터 명령어에 관한 설명으로 적절한 것은?",
            q1 : 'ADD X' ,
            a : ["2-주소 명령어이다.","데이터 전송을 위한 컴퓨터 명령어이다","컴퓨터의 내부구조로 볼때 누산기를 이용하는 컴퓨터 명령어이다","컴퓨터의 내부구조로 볼때 다중 레지스터를 이용하는 컴퓨터 명령어이다"],
            r : 3,
            img:''
            ,  summary:'0-주소 : 스택, 1=주소 : 누산기, 2,3-주소 다중레지스터 이용'
        },
        {//
            q : "아래 프로그램은 다음 중 어느 수식을 계산하는 것인가?",
            q1 : '' ,
            a : ["X=(A+B)*C","X=C*(A*B)","X=(A+B)/C","X=(A*B)+C"],
            r : 1,
            img:'컴퓨터구조201810.JPG'
            ,  summary:''
        },
        {//4
            q : "프로그램에서 (F)의 괄호안에 들어갈 식으로 알맞은 것은?",
            q1 : '' ,
            a : ["M[X] <- AC * AC","AC <- AC * M[X]","AC <- M[X]","M[X] <- AC"],
            r : 4,
            img:''
            ,  summary:''
        },
        {//
            q : "다음 중 산술연산에서 두수를 가산할때 결과를 저장할 수 있는 레지스터의 자릿수가 모자라는 경우에 발생하는 에러를 저장하는 상태 레지스터의 플래그(FLAG)는?",
            q1 : '' ,
            a : ["sign bit","zero bit","overflow bit","carry bit"],
            r : 3,
            img:''
            ,  summary:''
        },
        {//6
            q : "다음 마이크로 연산에 관한 설명으로 잘못된 것은?",
            q1 : '' ,
            a : ["T1 + T2 은 두 변수의 OR연산이다.","R0에는 R2의 2의 보수가 저장된다","R0에는 R2의 1의 보수가 저장된다","R3에는 R4와 R5의 논리 곱 연산결과가 저장된다"],
            r : 3,
            img:'컴퓨터구조201701.JPG'
            ,  summary:''
        },
        {//
            q : "즉치 주소지정방식과 직접 주소지정방식을 이용한다면 각각 어떤 값이 AC에 적재될 것인가?",
            q1 : '' ,
            a : ["257,500","456,256","500,456","500,818"],
            r : 4,
            img:'컴퓨터구조201702.JPG'
            ,  summary:''
        },
        {//
            q : "간접 주소지정방식과 상대주소지정방식을 이용한다면 각각의 유효주소는?",
            q1 : '' ,
            a : ["818,758","818,700","500,818","500,256"],
            r : 1,
            img:''
            ,  summary:'간접주소지정방식은 주소 필드에 유효주소가 저장되어 있는 기억장치 주소를 기억시키는 방식이므로 유효주소는 500번지에 저장되어있고, 500번지에 저장된 818번지가 유효주소가 된다. 따라서 818번지에 있는 456이 AC에 적재됨.   상대주소지정방식에서 유효주소는 주소필드 + PC의 내용이며 PC는 다음 명령어를 수행하기 위해 258로 증가되었으므로 500 + 258  = 758번지가 유효주소가 되며 758번지에 저장된 700이 AC에 적재된다'
        },
        {//9
            q : "인덱스된 주소지정방식과 레지스터 간접 주소지정방식을 이용한다면 각각 유효주소는?",
            q1 : '' ,
            a : ["400,500","458,500","500,400","900,400"],
            r : 4,
            img:''
            ,  summary:'인덱스된 주소지정방식의 유효주소는 명령어 주소의 부분 + 인덱스 레지스터의 내용이므로 (문제에서 레지스터를 사용시 R1을 사요하라 했음)  유효주소는 500 + 400 = 900번지이며,  레지스터 간접주소지정방식의 유효주소는 지정된 레지스터에 있는 주소이므로 R1에 있는 400번지가 유효주소다.'
        },
        {//
            q : "다음중 내부 버스에 대한 설명으로 적절한 것은?",
            q1 : '' ,
            a : ["기억장치와 중앙처리장치 사이의 데이터 전송을 위한 공통선로의 집합이다.","중앙처리장치 내부에서 정보를 전달할 수 있는 통로이다","멀티플렉서와 인코더를 이용하여 구성할 수 있다","입출력 장치들을 내부적으로 연결할 수있는 통로이다."],
            r : 2,
            img:''
            ,  summary:''
        },
        {//
            q : "각필드에 관한 설명 중에서 부적절한 것은?",
            q1 : '' ,
            a : ["A와 B는 출발레지스터를 선택하는 필드이다.","D는 도착레지스터를 선택하는 필드이다","F는 ALU에서 수행되는 연산의 하나를 선택하는 필드이다","H는 상태레지스터의 상태값을 선택하는 필드이다."],
            r : 4,
            img:'컴퓨터구조201703.JPG'
            ,  summary:'H는 시프터다'
        },
        {//12 ???
            q : "위의 제어단어로부터 알 수 있는 사실로서 적절한 것은?",
            q1 : '' ,
            a : ["A가 3비트이므로 외부 입력까지 고려한다면 레지스터 세트에는 최대한 8개의 레지스터가 포함될 수 있다.","D가 3비트이므로 외부 출력까지 고려한다면 레지스터 세트에는 최대한 7개의 레지스터가 포함될 수 있다.","F가 4비트이므로 시프터에서 이루어지는 연산의 종류가 최대한 16개이다","H가 3비트이므로 최대 8개의 상태값이 존재한다."],
            r : 2,
            img:''
            ,  summary:''
        },
        {//
            q : "중앙처리장치에서 내부버스를 구성하는 방법은 멀티플렉서와 ㄱ 을 이용한다. 여기서 앞의 괄호안에 ㄱ 에 해당되는 장치는 위 그림에서 어디인가?",
            q1 : '' ,
            a : ["가","나","다","라"],
            r : 1,
            img:'컴퓨터구조201704.JPG'
            ,  summary:''
        },
        {//14
            q : "그림 나에 관한 설명으로 적절한 것은?",
            q1 : '' ,
            a : ["출발 레지스터의 내용을 ALU로 보내는데 필요하다","도착 레지스터를 결정하는데 필요하다","상태비트를 보관하는데 필요하다","ALU의 결과를 비트 단위의 이동을 위해 필요하다."],
            r : 3,
            img:''
            ,  summary:''
        },
        {//
            q : "위 그림에서 레지스터 세트에 15개의 레지스터가 있고 다는 21개의 연산 라는 7개의 연산을 수행한다고 가정했을때 제어단어는 총 몇 비트가 되겠는가?",
            q1 : '' ,
            a : ["20","22","23","24"],
            r : 1,
            img:''
            ,  summary:'4 4 4 5 3 '
        },
        {//16
            q : "다음 중 시프트 마이크로연산의 설명으로 잘못된 것은?",
            q1 : '' ,
            a : ["레지스터 내의 데이터를 시프트시키는 연산이다.","데이터의 측면이동에 사용된다","연산의 종류로는 가산 시프트와 감산 시프트가 있다.","왼쪽과 오른쪽 쉬프트에 있어서 입력비트는 0으로 가정한다."],
            r : 3,
            img:''
            ,  summary:''
        },
        {//
            q : "그림에서 마 에 들어갈 내용으로 적절한 것은?",
            q1 : '' ,
            a : ["상태비트","제어신호","제어단어","선택비트"],
            r : 1,
            img:'컴퓨터구조201705.JPG'
            ,  summary:''
        },
        {//18
            q : "그림에서 만일 MUX 1에서 가 로 입력되는 데이터가 8비트이고 다른 것은 변동이 없다면 나 는 어떻게 바뀌는가?",
            q1 : '' ,
            a : ["64 * 26","128 * 27","256 * 28","512 * 28"],
            r : 3,
            img:''
            ,  summary:''
        },
        {//
            q : "그림에서 가 와 다에 들어갈 내용으로 적절한 것은?",
            q1 : '' ,
            a : ["처리장치, 제어장치","시프터, 제어주소 레지스터","제어주소 레지스터, 처리장치","산술논리연산장치, 중앙처리장치"],
            r : 3,
            img:''
            ,  summary:''
        },
        {//20  ** 공부좀 더하자 이건
            q : "다음과 같은 연산을 수행하려 할 때 그림에서 제어기억장치의 27개 비트에 대한 설명으로 잘못된 것은?",
            q1 : 'R5<-R6+R3, if(C=0) then (CAR<-62) else (CAR <-CAR+1)' ,
            a : ["1번 ~ 16번 비트는 마이크로연산 R5<-R6+R3 를 수행한다.","17번 비트는 (0)^2 이어야 한다.","18번~20번 비트는 캐리의 상태에 따라 결정된다.","21~27번 비트는 조건문 if(C=0)를 수행한다."],
            r : 4,
            img:''
            ,  summary:''
        },
        {//
            q : "다음 중 마이크로프로그램에 관한 설명으로 부적절한 것은?",
            q1 : '' ,
            a : ["마이크로명령어를 이용해서 작성된 프로그램을 말한다","펌웨어라고도 한다","소프트웨어 프로그램을 작성하는 것보다 용이하다.","마이크로프로그램이 하드웨어와 소프트웨어 중간 정도임을 의미한다."],
            r : 3,
            img:''
            ,  summary:''
        },
        {//22
            q : "다음 설명에서 괄호 안에 들어갈 용어로 적절한 것은?",
            q1 : '명령어 사이클 중 (가) 은 기억장치로부터 명령어를 가져오는 것을 말한다.  이때 가져올 명령어 주소는  (나) 에 들어있다.' ,
            a : ["(가) 제어 사이클, (나) 명령어 레지스터","(가) 인출 사이클, (나) 데이터 레지스터","(가) 실행 사이클, (나) 스택 포인터","(가) 인출 사이클, (나) 프로그램 카운터"],
            r : 4,
            img:''
            ,  summary:'명령어는 pc에 저장되어있다.'
        },
        {//
            q : "다음과 같은 일련의 마이크로 연산은 무엇을 수행하는 것인가?",
            q1 : '' ,
            a : ["LOAD 명령어","AND 명령어","STORE 명령어","ADD 명령어"],
            r : 4,
            img:'컴퓨터구조201706.JPG'
            ,  summary:''
        },
        {//24
            q : "다음 중 cpu에 있는 레지스터에 대한 설명으로 적절한 것은?",
            q1 : '' ,
            a : ["레지스터는 데이터의 임시 저장소로서 컴퓨터의 기억장치 중에서 엑세스 속도가 가장 빠르다","다음에 수행해야할 명령어가 저장된 기억장치 주소를 저장하는 레지스터는 누산기이다","명령어 레지스터는 오퍼랜드나 연산결과를 일시적으로 저장한다.","스택 포인터는 특수 레지스터로서 스택 영역에 들어있는 데이터를 저장한다."],
            r : 1,
            img:''
            ,  summary:''
        },
        {//
            q : "다음중 PC(program counter)의 설명으로 잘못된 것은?",
            q1 : '' ,
            a : ["다음에 수행되어질 명령어가 들어있는 주소를 갖고있다.","비트 수는 기억장치의 용량에 따라 결정되나.","현재의 데이터를 인출한 후에는 자동적으로 1 증가한다","스택 공간의 최상위 주소를 갖고있다."],
            r : 4,
            img:''
            ,  summary:''
        },
        {// 26
            q : "다음 설명에서 괄호 안에 들어갈 용어로서 올바른 것은?",
            q1 : '' ,
            a : ["프로그램 카운터","명령어 레지스터","메모리 주소 레지스터","누산기"],
            r : 2,
            img:'컴퓨터구조201707.JPG'
            ,  summary:''
        },
        {//27 
            q : "다음의 내용과 관계가 깊은 것은?",
            q1 : '어떤 내용을 참조하면, 그 내용에 가까운 곳에 있는 다른 내용을 참조하기 쉽다.' ,
            a : ["공간적 지역성","시간적 지역성","내부적 참조성","외부적 참조성"],
            r : 1,
            img:''
            ,  summary:''
        },
        {//
            q : "다음 중 캐시기억장치와 주기억장치 사이의 데이터 교환을 일컫는 용어는?",
            q1 : '' ,
            a : ["blocking","mapping","paging","buffering"],
            r : 2,
            img:''
            ,  summary:''
        },
        {//29
            q : "다음의 기억장치를 기억용량의 크기 순서로 나열한 것은?",
            q1 : 'ㄱ : 레지스터 , ㄴ : 캐시기억장치, ㄷ : 주기억장치 , ㄹ : 보조기억장치' ,
            a : ["ㄹ -ㄷ -ㄴ- ㄱ","ㄹ-ㄴ-ㄱ-ㄷ","ㄷ-ㄹ-ㄴ-ㄱ","ㄱ-ㄷ-ㄴ-ㄹ"],
            r : 1,
            img:''
            ,  summary:''
        },
        {//다음 중 30
            q : "다음 중 주기억장치의 성능을 평가하는 단위로 사용되지 않는 것은?",
            q1 : '' ,
            a : ["기억용량","기억 소자","사이클 타임","엑세스 타임"],
            r : 2,
            img:''
            ,  summary:''
        },
        {//
            q : "다음의 단어와 가장 관계가 깊은 기억장치는?",
            q1 : '"물리주소"  "희생페이지"  "세그먼트"    "페이지"' ,
            a : ["가상기억장치","캐시기억장치","주기억장치","연관기억장치"],
            r : 1,
            img:''
            ,  summary:''
        },
        {//32
            q : "다음중 컴퓨터 내부장치와 입출력 장치의 차이점이 아닌 것은?",
            q1 : '' ,
            a : ["데이터 전송속도의 차이","데이터 처리단위의 차이","에러율의 차이","데이터 신호 종류의 차이"],
            r : 4,
            img:''
            ,  summary:''
        },
        {//33
            q : "다음중 입출력 시스템에서 버스 사용을 중재하는 방법이 아닌 것은?",
            q1 : '' ,
            a : ["중앙집중식 병렬중재 방법","우선순위 인코더 방법","폴링 중재방법","데이지 체인 방법"],
            r : 2,
            img:''
            ,  summary:''
        },
        {//
            q : "다음중 중앙처리장치의 개입 없이 주기억장치에 직접 접근하여 입출력을 행하는 방식으로 사이클 요청 신호가 사용되는 방식은",
            q1 : '' ,
            a : ["DMA제어","핸드쉐이킹 제어","스트로브 제어","중앙처리장치 제어"],
            r : 1,
            img:''
            ,  summary:''
        },
        {//
            q : "다음 중 병렬처리를 수행하는 시스템이 아닌 것은?",
            q1 : '' ,
            a : ["pipeline processor","array processor","mulitiple processor","I/O processor"],
            r : 4,
            img:''
            ,  summary:''
        },

    ]
    const test2019db :Testtype[] =[
        {//36
            q : "다음의[가]에 들어갈 내용으로 알맞은 것은?",
            q1 : '' ,
            a : ["알고리즘","정보","추상화","데이터"],
            r : 3,
            img:'자료구조2019.JPG'
            ,  summary:''
        },
        {//37
            q : "배열에 대한 내용으로 알맞지 않은 것은 무엇인가?",
            q1 : '' ,
            a : ["배열은 인덱스와 원소값의 쌍으로 구성된 집합이다.","원소들 마다 기억 공간의 크기가 다르다"," 원소들이 모두 같은 자료형을 가진다"," 인덱스 값으로 직접 접근이 가능하다"],
            r : 2,
            img:''
            ,  summary:''
        },
        {//38
            q : "스택을 이용하여 A+B*C연산을 후위표기식으로 변환할 경우 스택의 그림 순서로 알맞은 것은 무엇인가?",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 1,
            img:'자료구조201901.JPG'
            ,  summary:''
        },
        {//
            q : "원형큐에 대한 설명으로 알맞은 것은 무엇인가?",
            q1 : '' ,
            a : ["메모리 공간을 50%만 사용하게 되어 비효율적이다.","큐가 만원 상태인 경우 원소의 개수가 n-1개이다","front 값으로만 큐의 만원 상태를 판단한다","나머지 계산하는 mod 연산자를 사용하여 rear 값을 관리하게 한다."],
            r : 2,
            img:''
            ,  summary:` 정답이 2개 2,4번
            1. "메모리 공간을 50%만 사용하게 되어 비효율적이다."
오답: 원형 큐는 메모리 공간을 효율적으로 사용하기 위한 자료구조입니다. 선형 큐에서는 메모리 공간이 제한되면, 삭제된 공간을 다시 사용할 수 없는 문제가 있지만, 원형 큐는 이러한 문제를 해결합니다. 따라서 메모리를 비효율적으로 사용하지 않습니다.
2. "큐가 만원 상태인 경우 원소의 개수가 n-1개이다."
정답: 원형 큐에서는 큐가 가득 차면 rear와 front가 같아지는 상황을 피하기 위해, 실제로 큐의 크기가 n인 경우, n-1개의 원소를 저장하고 하나의 공간을 비워 둡니다. 이 공간이 없으면 큐가 빈 상태와 가득 찬 상태를 구별할 수 없기 때문에 공간을 하나 남겨둡니다.
3. "front 값으로만 큐의 만원 상태를 판단한다."
오답: 큐가 가득 찬 상태는 front와 rear의 상대적 위치로 판단됩니다. 즉, front 값만으로는 큐가 가득 찬 상태를 알 수 없습니다. 일반적으로 front가 rear 바로 뒤에 위치할 때 큐가 가득 찼다고 판단합니다.
4. "나머지 계산하는 mod 연산자를 사용하여 rear 값을 관리하게 한다."
정답: 원형 큐에서는 인덱스가 끝에 도달했을 때 다시 처음으로 돌아가도록 mod 연산을 사용합니다. rear와 front는 mod 연산을 사용하여 배열의 크기를 넘지 않도록 관리됩니다. 이 방식으로 원형 구조를 구현할 수 있습니다.`
        },
         {//40
            q : " 다음은 연결 리스트 프로그램의 일부이다. 현재 헤드 노드만 존재하며, x값은 100이라고 가정하고 NewNode의 주소값은 5000 이라고 가정할 때, 결과 상태를 그림으로 표현한 것으로 알맞은 것은 무엇인가?",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 2,
            img:'자료구조201902.JPG'
            ,  summary:''
        },
         {//
            q : "다음 연산들을 수행할 경우 4번 연산의 결과는 무엇인가?",
            q1 : '' ,
            a :  ["1","2","3","4"],
            r : 1,
            img:'자료구조201903.JPG'
            ,  summary:''
        },
         {//42
            q : "다음 그림과 같이 높이가 k인 이진 트리가 레빌 0부터 레벨 k-2까지 다 채우고 마지막 레벨 k-1에서는 왼쪽부터 오른쪽으로 노드들이 차례로 채워진 이진트리를 무엇이라고 하는가?",
            q1 : '' ,
            a :  ["서브트리","완전이진트리","B트리","splay트리"],
            r : 2,
            img:'자료구조201904.JPG'
            ,  summary:''
        },
         {//
            q : "다음 스레드 트리는 어떤 방문순서로 순회하는 것을 나타낸 것인가?",
            q1 : '' ,
            a :  ["후위 순회 스레드 트리","중위순회 스레드트리","전위순회 스레드트리","이중 순회 스레드 트리"],
            r : 3,
            img:'자료구조201905.JPG'
            ,  summary:''
        },
         {//44
            q : "대기 리스트에서 항상 우선순위가 높은 사람이 먼저 서비스를 받는 구조는 무엇인가",
            q1 : '' ,
            a : ["우선순위 스택","우선순위 큐","우선순위 리스트","우선순위 배열"],
            r : 2,
            img:''
            ,  summary:''
        },
         {//
            q : "트리의 각 내부 노드가 두 자식 노드 값의 승자를 자신의 값으로 하며, 각 노드는 두 자식 노드보다 더 작은 값을 갖는 선택트리는 무엇인가?",
            q1 : '' ,
            a : ["승자 트리","패자트리","힙트리"," 스레드 트리"],
            r : 1,
            img:''
            ,  summary:''
        },
         {//46
            q : "높이가 균형 잡힌 높이 균형 트리로 다음과 같은 조건을 만족 할 때 그 트리의 높이가 균형 잡혔다고 하는 트리는 무엇인가?",
            q1 : '' ,
            a : ["AVL트리","선택트리","3원탐색트리","스레드 트리"],
            r : 1,
            img:'자료구조201906.JPG'
            ,  summary:`1. AVL 트리
높이 균형 이진 탐색 트리로, 각 노드에서 왼쪽과 오른쪽 서브트리의 높이 차이가 1 이하로 유지됩니다.
삽입과 삭제 시 **균형 조정(회전)**이 필요하여, 탐색, 삽입, 삭제의 시간 복잡도는 **O(log N)**입니다.
2. 선택 트리 (Winner Tree)
K-way 병합 정렬에서 사용되며, 각 내부 노드는 두 자식 노드의 값 중 더 작은 값을 선택합니다.
루트에 최종 승자가 위치하며, 가장 작은 값을 효율적으로 찾을 수 있습니다.
3. 3원 탐색 트리 (Ternary Search Tree)
각 노드가 세 개의 자식을 가지는 탐색 트리로, 문자열 탐색에서 유용하게 사용됩니다.
가운데 자식이 키 값과 같고, 왼쪽 자식은 작은 값, 오른쪽 자식은 큰 값을 가집니다.
4. 스레드 트리 (Threaded Tree)
이진 트리에서 비어 있는 포인터를 이용해 노드 간 중위 순회를 쉽게 할 수 있도록 연결한 트리입니다.
일반적인 트리보다 공간 효율성을 높여 트리 순회를 빠르게 수행합니다.`
        },
         {//47
            q : "현실 세계에서 관찰이나 측정을 통해서 수집된 값이나 사실을 무엇이라 하는가",
            q1 : '' ,
            a : ["자료","정보","추상데이터","추상데이터 형"],
            r : 1,
            img:''
            ,  summary:''
        },
         {// 
            q : "다음 희소행렬을 배열로 표현할 경우, 희소행렬 배열 표기로 표현할 경우에 첫 번째 행에 저장되는 값은 무엇인가?",
            q1 : '' ,
            a : ["1,2,20","0,1,20","8,9,10","9,8,10"],
            r : 3,
            img:'자료구조201907.JPG'
            ,  summary:`주어진 행렬은 대부분의 요소가 0인 **희소 행렬(Sparse Matrix)**입니다. 희소 행렬을 효율적으로 표현하기 위해 일반적으로 3중 배열 형태로 저장합니다. 이 방식에서는 비어 있지 않은(non-zero) 값만 저장하여 메모리 사용을 최소화합니다.

3중 배열 표현법 (Triplet Representation)
희소 행렬을 배열로 표현할 때, 각 비어 있지 않은 값의 행 번호(row), 열 번호(column), **값(value)**을 저장합니다. 즉, 이 3개의 요소로 하나의 비어 있지 않은 요소를 나타냅니다. 첫 번째 행에는 전체 행렬의 정보가 포함되며, 다음과 같은 값들을 저장합니다:

총 행의 수 (행렬의 행 개수)
총 열의 수 (행렬의 열 개수)
비어 있지 않은 값의 개수 (행렬 내에서 0이 아닌 값의 개수) 위 문제에서는 총 10개임`
        },
         {//49
            q : "다음과 같은 행렬이 열우선 방식으로 저장된다면, [5,3]의 다음에 저장되는 행려의 원소는 무엇인가?",
            q1 : '' ,
            a : ["[3,5]","[5,4]","[4,4]","[6,3]"],
            r : 4,
            img:'자료구조201908.JPG'
            ,  summary:''
        },
         {//50
            q : "다음은 큐에 대한 연산이다, 교재에 기술된 큐의 추상자료형을 따른다면 6 연산을 수행한 후의 큐의 모습은 무엇인가",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 2,
            img:'자료구조201909.JPG'
            ,  summary:''
        },
         {//
            q : "단순연결 리스트의 각 노드에서 선행 노드 검색의 문제점을 해결하기 위해 제안된 리스트는 무엇인가?",
            q1 : '' ,
            a : ["이중 연결 리스트","원형연결리스트","회전 연결 리스트","중복 연결리스트"],
            r : 1,
            img:''
            ,  summary:`1. 이중 연결 리스트 (Doubly Linked List)
각 노드가 앞쪽 노드와 뒤쪽 노드에 대한 포인터를 가집니다.
양방향으로 노드를 탐색할 수 있어 삽입, 삭제 시 효율적입니다.
2. 원형 연결 리스트 (Circular Linked List)
마지막 노드가 첫 번째 노드를 가리키는 연결 리스트로, 리스트의 끝에서 다시 처음으로 돌아갑니다.
연속적인 순회가 필요한 경우 유용합니다.
3. 회전 연결 리스트 (Rotating Linked List)
특정 노드를 기준으로 리스트를 회전시켜 첫 노드로 설정한 연결 리스트입니다.
데이터의 회전 처리 및 관리에 사용됩니다.
4. 중복 연결 리스트 (Multi-linked List)
하나의 노드가 여러 리스트에 중복으로 연결된 구조를 가집니다.
여러 경로를 통해 동일한 노드에 접근할 수 있으며, 복잡한 데이터 구조에 사용됩니다.`
        },
         {//52
            q : "리스트를 배열로 구현했을 경우에 대한 설명으로 틀린 것은 무엇인가?",
            q1 : '' ,
            a : ["삽입에 따른 원소의 이동이 발생한다","포인터를 이용한 구현보다 메모리를 절약할 수 있다","삭제에 따른 원소의 이동을 줄일 수 있다.","논리적 순서와 물리적 순서(메모리에 적재된 원소의 순서)가 동일하다"],
            r : 3,
            img:''
            ,  summary:`1. 삽입에 따른 원소의 이동이 발생한다
맞습니다. 배열에서 중간에 원소를 삽입하면, 해당 위치 이후의 모든 원소를 한 칸씩 뒤로 이동시켜야 합니다. 예를 들어, 배열 [1, 2, 3, 4] 에서 두 번째 위치에 5를 삽입하면 [1, 5, 2, 3, 4]가 되며, 2, 3, 4가 한 칸씩 이동합니다.

2. 포인터를 이용한 구현보다 메모리를 절약할 수 있다
맞습니다. 배열은 연속된 메모리 공간에 저장되기 때문에 추가적인 메모리 오버헤드가 없습니다. 반면, 포인터를 이용한 연결 리스트는 각 노드가 데이터와 함께 다음 노드의 주소(포인터)를 저장해야 하므로 메모리 사용이 더 늘어날 수 있습니다.

3. 삭제에 따른 원소의 이동을 줄일 수 있다
틀렸습니다. 배열에서 원소를 삭제하면, 해당 위치 이후의 모든 원소를 한 칸씩 앞으로 이동시켜야 합니다. 예를 들어, 배열 [1, 2, 3, 4] 에서 두 번째 원소 2를 삭제하면 [1, 3, 4]가 되며, 3과 4가 한 칸씩 이동합니다. 따라서 삭제에 따른 원소의 이동을 줄일 수 없습니다.

4. 논리적 순서와 물리적 순서(메모리에 적재된 원소의 순서)가 동일하다
맞습니다. 배열은 연속된 메모리 위치에 저장되므로, 배열의 논리적 순서와 메모리에 저장된 물리적 순서가 동일합니다. 예를 들어, 배열 [1, 2, 3, 4] 에서 1이 메모리의 첫 번째 위치에, 2가 두 번째 위치에, 이렇게 순서대로 저장됩니다.`
        },
         {//
            q : "포인터를 이용한 리스트의 구현에서 노드 삽입에 관한 설명으로 옳은 것은 무엇인가?",
            q1 : '' ,
            a : ["가-나-다","다-나-가","나-가-다","나-다-가"],
            r : 1,
            img:'자료구조201910.JPG'
            ,  summary:''
        },
         {//54
            q : "연결리스트 그림에 대한 설명으로 틀린 것은 무엇인가?",
            q1 : '' ,
            a : ["C언어로 구현한다면 포인터 변수로 구현된다.","ㄴ에는 데이터 필드에 해당한다.","head는 링크 필드만 갖는다.","마지막 노드의 포인터는 head에 대한 주소값을 갖는다."],
            r : 4,
            img:'자료구조201911.JPG'
            ,  summary:''
        },
         {//55
            q : "이진트리에 대한 설명으로 틀린 것은 무엇인가?",
            q1 : '' ,
            a : ["모든 노드의 차수가 2 이하인 트리이다.","컴퓨터 내부에서 구현하기도 쉽고, 메모리의 소모가 다른 트리에 비해서 효율적이다.","모든 노드가 2개의 자식 노드를 가진다.","일반성을 잃지 않고 '오른쪽','왼쪽'이라는 방향 개념을 부여할 수 도 있다."],
            r : 3,
            img:''
            ,  summary:''
        },
         {//
            q : "아래의 문장을 수식으로 표현한 것으로 알맞은 것은 무엇인가? (R : 결과, D :  자료, P:처리)",
            q1 : '' ,
            a : ["R = P(D)","P = I(R)","R= D(P)","I= P(D)"],
            r : 4,
            img:'자료구조201912.JPG'
            ,  summary:`1강 수업 6분 화면에서 i=p(d)라고 명시하고 있다.`
        },
         {//57
            q : "아래의 그림을 너비 우선 탐색(BFS)알고리즘으로 탐색할 때의 노드 방문 순서로 옳은 결과는 무엇인가? (시작점 v1)",
            q1 : '' ,
            a : ["v1,v2,v4,v5,v3,v6,v7","v1,v2,v3,v6,v5,v4,v7","v1,v3,v2,v6,v5,v4,v7","v1,v3,v2,v4,v6,v5,v7"],
            r : 3,
            img:'자료구조201913.JPG'
            ,  summary:''
        },
         {// 58
            q : "다음중 B트리에 대한 설명으로 옳은 것은 무엇인가",
            q1 : '' ,
            a : ["루트와 단말 노드를 제외한 트리의 각 노드는 최소 [2/m]개의 서브 트리를 갖는다","트리의 루트는 최소한 3개의 서브트리를 갖는다","트리의 모든 노드는 같은 레벨에 있다","루트가 가장 작은 값을 갖고 부모는 자식보다 작은 값을 갖는다."],
            r : 1,
            img:''
            ,  summary:`B-트리(B-tree)는 균형 잡힌 검색 트리로, 대용량 데이터를 디스크에 효율적으로 저장하고 검색할 때 사용되는 자료구조입니다. 주로 데이터베이스나 파일 시스템에서 활용되며, 이진 탐색 트리의 확장 버전입니다. B-트리의 주요 특징은 다음과 같습니다:

균형 유지: 트리의 모든 리프 노드가 같은 깊이를 가지며, 삽입과 삭제가 이루어져도 트리의 균형이 유지됩니다. 이는 트리의 깊이를 최소화하여 검색 속도를 일정하게 유지하게 해줍니다.

다중 자식 노드: B-트리의 각 노드는 두 개 이상의 자식을 가질 수 있습니다. 즉, 각 노드는 여러 키와 자식을 가지며, 이를 통해 트리의 높이를 줄여 효율적인 검색이 가능해집니다.

디스크 입출력 최소화: B-트리는 노드 하나에 여러 데이터를 저장해 한 번에 많은 양의 데이터를 읽고 쓰도록 설계되었습니다. 이로 인해 대용량 데이터 처리에 적합합니다.

삽입/삭제 효율성: B-트리는 삽입과 삭제 연산이 자동으로 트리의 균형을 유지하면서 수행됩니다. 노드 분할과 병합을 통해 항상 균형 잡힌 상태를 유지합니다.

높이 제어: 노드의 자식 수를 제어하는 매개변수(차수)가 있어서, 트리의 높이를 제한하고 검색, 삽입, 삭제 성능을 보장합니다.`
        },
         {//
            q : "그래프 G의 모든 정점과 간선의 일부를 포함하는 트리는 무엇인가?",
            q1 : '' ,
            a : ["완전 이진트리","B트리","신장트리","포화이진트리"],
            r : 3,
            img:''
            ,  summary:`완전 이진 트리: 마지막 레벨을 제외하고 모든 레벨이 꽉 차 있으며, 마지막 레벨은 왼쪽부터 순차적으로 채워진 이진 트리.
B-트리: 다중 자식을 가지는 균형 잡힌 검색 트리로, 데이터베이스와 파일 시스템에서 대용량 데이터 처리를 효율화함.
신장 트리 (Spanning Tree): 그래프의 모든 정점을 포함하면서 사이클이 없는 최소 연결 그래프.
포화 이진 트리: 모든 레벨이 꽉 차서 모든 내부 노드가 두 자식을 가지는 이진 트리.`
        },
         {//60
            q : "그래프에 대한 설명으로 옳은 것은 무엇인가?",
            q1 : '' ,
            a : ["두 정점이 사이클로 연결되었을 때, 두 정점이 인접한다고 정의한다"," 사이클이 없는 그래프를 가중 그래프라 한다"," 한 정점에서 출발하여 자신으로 연결하는 간선을 사이클이라고 한다.","다중 그래프는 두 정점을 잇는 간선이 여러개인 그래프이다."],
            r : 4,
            img:''
            ,  summary:''
        },
         {//대면시험 대체 같음 16번부터
            q : "다음 설명 중 옳은 것은?",
            q1 : '출석대체시험 문제이다.' ,
            a : ["알고리즘은 자료와 정보를 처리한다.","정보는 현실세계에서 관찰이나 측정을 통해서 수집된 값이나 사실이다.","알고리즘은 문제 해결을 위한 명령어가 구체적으로 표현된 결과이다.","자료구조는 자료의 저장과 이용을 위해 추상화 방법을 사용한다."],
            r : 4,
            img:''
            ,  summary:''
        },
         {//
            q : "알고리즘의 명령을 수행하다가 특수한 경우를 제외하고는 반드시 종료되어 결과를 제공하는 것을 목표로 하는 알고리즘의 특성은 무엇인가?",
            q1 : '출석대체시험 문제이다.' ,
            a : ["유한성","유효성","입력","명확성"],
            r : 1,
            img:''
            ,  summary:`유한성은 알고리즘이 반드시 종료되어 결과를 제공하는 것을 의미함`
        },
         {//18
            q : "다음과 같은 저장방식을 사용하는 것은 무엇인가?",
            q1 : '출석대체시험 문제이다.' ,
            a : ["열우선 저장","행우선 저장","2차원 배열 우선 저장","1차원 배열 우선 저장"],
            r : 2,
            img:'컴퓨터구조201912.JPG'
            ,  summary:`행(Row): 수평으로 나열된 데이터를 의미합니다. 위 표에서는 같은 숫자로 표시된 A[i]의 데이터들이 하나의 행에 해당합니다.
예: A[0][0], A[0][1], A[0][2], A[0][3] → 첫 번째 행 (A[0])
예: A[1][0], A[1][1], A[1][2], A[1][3] → 두 번째 행 (A[1])
열(Column): 수직으로 나열된 데이터를 의미합니다. 위 표에서는 같은 열에 위치한 값들이 열에 해당합니다.
예: A[0][0], A[1][0], A[2][0] → 첫 번째 열
예: A[0][1], A[1][1], A[2][1] → 두 번째 열`
        },
         {//19
            q : "다음 행렬 A를 보다 효율적인 배열로 표현하기 위해 0이 아닌 값만을 따로 모아서 배열 B로 표현할 경우에 B[0,0], B[0,1], B[0,2]의 값은 무엇인가?",
            q1 : '출석대체시험 문제이다.' ,
            a : ["8,9,10","9,8,10","0,1,20","20,0,1"],
            r : 1,
            img:'컴퓨터구조201913.JPG'
            ,  summary:`희소행렬에서 0을 제외한 값을 출력하게되면 인덱스 0의 값에 [행갯수,열갯수,값의갯수]가 처음위치에 오게된다.`
        },
         {//20
            q : "한 노드에서 후속 노드를 가리키는 포인터를 가지는 자료구조는 무엇인가?",
            q1 : '출석대체시험 문제이다.' ,
            a : ["연결리스트","스택","배열","큐"],
            r : 1,
            img:''
            ,  summary:''
        },
         {//21
            q : "실제 언어를 통한 구현과는 분리되어 정의되며, 객체의 명세와 그 연산의 명세를 통해 정의되는 것은 무엇인가?",
            q1 : '출석대체시험 문제이다.' ,
            a : ["자료","자료구조","알고리즘","추상자료형"],
            r : 4,
            img:''
            ,  summary:''
        },
         {//22
            q : "'A - B + K / D' 의 후위표기로 옳은 것은 무엇인가?",
            q1 : '출석대체시험 문제이다.' ,
            a : ["AB-KD/+","-A/+BKD","ABKD/+-","/A-+BKD"],
            r : 1,
            img:''
            ,  summary:''
        },
         {//23
            q : "일반적인 큐를 배열로 구현할 경우에는 공간이 남아있음에도 불구하고 'front'변수와 rear변수의 비교를 통한 공간 확인으로 인해 큐에 저장공간이 없다는 결론을 내리는 경우가 있다. 이러한 불합리한 부분을 해결하기 위해 고안된 자료 구조는 무엇인가?",
            q1 : '출석대체시험 문제이다.' ,
            a : ["원형 큐","선형 큐","이중 큐","멀티 큐"],
            r : 1,
            img:''
            ,  summary:''
        },
         {//24
            q : "리스트에 대한 설명으로 틀린 것은 무엇인가?",
            q1 : '출석대체시험 문제이다.' ,
            a : ["물품이나 사람의 이름 따위를 논리적인 순서로 적어 놓은 것이다.","원소들 간의 의미적인 순서를 논리적 순서로 사용하기도 한다.","배열을 통해 구현할 수 있다.","논리적인 순서가 메모리 공간에서의 물리적 순서를 결정한다."],
            r : 4,
            img:''
            ,  summary:''
        },
         {//25
            q : "다음의 연산들을 수행할 경우에 8번의 연산 수행 결과는 무엇인가?",
            q1 : '출석대체시험 문제이다.' ,
            a : ["1","2","3","4"],
            r : 4,
            img:'컴퓨터구조201914.JPG'
            ,  summary:''
        },
         {//26
            q : "실제로 프로그램을 구현하지 않고 알고리즘의 수행을 계산하여 프로그램의 실행 시간을 예측하는 것은 무엇인가?",
            q1 : '출석대체시험 문제이다.' ,
            a : ["알고리즘의 성능 분석"," 알고리즘의 성능 측정","알고리즘 메모리 분석","알고리즘 메모리 측정"],
            r : 1,
            img:''
            ,  summary:''
        },
         {//
            q : "인덱스와 원소값(<index, value>)의 쌍으로 구성된 집합이며, 인덱스를 통해 데이터에 대한 직접 접근이 가능한 자료구조는 무엇인가?",
            q1 : '출석대체시험 문제이다.' ,
            a : ["리스트","스택","배열","큐"],
            r : 3,
            img:''
            ,  summary:''
        },
         {//28
            q : "자료의 복잡한 논리적 성격을 정의하는 형식으로 자료 값의 집합과 연산 집합에 대한 명세의 집합을 무엇이라고 하는가?",
            q1 : '출석대체시험 문제이다.' ,
            a : ["추상 자료형"," 복합 자료형","자료형","자료 추상화"],
            r : 1,
            img:''
            ,  summary:''
        },
         {//29
            q : "다음 스택을 구현한 프로그램 중 메인 함수에서 호출하여 사용하는 push 함수에 대한 내용이다. push 함수는 *top이 가리키는 주소값을 먼저 증가시킨 후에 item으로 전달된 값을 저장한다. (가)에 알맞은 내용은 무엇인가?",
            q1 : '출석대체시험 문제이다.' ,
            a : ["top=top+1","top++","(*top)++","++(*top)"],
            r : 4,
            img:'컴퓨터구조201915.JPG'
            ,  summary:''
        },
         {//
            q : "다음 그림은 연결리스트가 실제로는 저장 위치가 순차적으로 이루어지지 않는다는 것을 보여주기 위해서 메모리 부분과 함께 표현한 것이다. 리스트 원소들이 논리적인 순서로 알맞은 것은 무엇인가?",
            q1 : '출석대체시험 문제이다.' ,
            a : ["1","2","3","4"],
            r : 2,
            img:'컴퓨터구조201916.JPG'
            ,  summary:'왼쪽이 인덱스 값이라면 요일의 우측에 있는 숫자가 다음좌표라고 생각하자.'
        },
    ]

    const test2018cs :Testtype[] =[
        {//
            q : "다음 중 컴퓨터 명령어를 구헝하는 대표적인 필드가 아닌 것은?",
            q1 : '' ,
            a : ["기억장치주소 혹은 처리장치 레지스터를 선택하기 위한 주소필드","주소필드에 대한 해석방법을 지정하는 방식필드","수행할 연산ㅇ르 나타내는 연산코드 필드","인터럽트 요청을 위한 제어 필드"],
            r : 4,
            img:'',  
            summary:''
        },
        {//
            q : "다음 컴퓨터 명령어에 관한 설명으로 적절한 것은?",
            q1 : 'AND R1, R2, R3' ,
            a : ["2-주소 명령어이다.","데이터 전송을 위한 컴퓨터 명령어이다","컴퓨터의 내부구조로 볼때 누산기를 이용하는 컴퓨터 명령어이다.","컴퓨터의 내부구조로 볼때 다중 레지스터를 이용하는 컴퓨터 명령어이다."],
            r : 4,
            img:'',  
            summary:`0주소 명령 형식은 스택을 이용한 구조, 1주소 명령어 형식은 누산기 레지스터를 사용한 구조, 2주소 또는 3주소는 다중 레지스터를 이용한 구조로 2주소 명령 형식이 오퍼랜드가 2개, 3주소 명령 형식은 오퍼랜드가 3개인 명령어 구조다.`
        },
        {//
            q : "위 프로그램은 다음 중 어느 수식을 계산하는 것인가?",
            q1 : '' ,
            a : ["X = (A + B) * C","X = (A - B) *C","AC = (A +B) * C","AC = (A -B ) * C"],
            r :2,
            img:'컴퓨터구조2018.JPG',  
            summary:'AC에 A를 불러와 저장하고 AC에 저장된 값에 B를 뺀다 ,  AC에 C를 불러와 저장하고   AC에 (c)에서 m[x]에 저장했던 값을  C와 곱한다.  X = (A - B ) * C , --> (f)에서 store에 x에 무언가를 하도록 되어있고 X에 저장하는 로직으로 유추된다. '
        },
        {//
            q : "위 프로그램에서 (f)의 괄호 안에 들어갈 식으로 알맞은 것은?",
            q1 : '' ,
            a : ["AC <-M[A] - [B]","AC <- AC * M[X]","AC <- M[X]","M[X] <- AC"],
            r : 4,
            img:'',  
            summary:''
        },
        {//
            q : "위 프로그램의 명령어 형식과 관계가 깊은 컴퓨터 내부 구조는?",
            q1 : '' ,
            a : ["누산기를 가진 구조","다중 레지스터를 가진 구조","스택을 가진 구조","프로그램 카운터를 가진 구조"],
            r : 1,
            img:'',  
            summary:`0주소 명령 형식은 스택을 이용한 구조, 1주소 명령어 형식은 누산기 레지스터를 사용한 구조, 2주소 또는 3주소는 다중 레지스터를 이용한 구조로 2주소 명령 형식이 오퍼랜드가 2개, 3주소 명령 형식은 오퍼랜드가 3개인 명령어 구조다.`
        },
        {// 6
            q : "즉치 주소지정방식과 직접 주소지정 방식을 이용한다면 각각 어떤 값이 AC에 적재될 것인가?",
            q1 : '' ,
            a : ["300, 500","300, 618","618, 456","618, 458"],
            r : 2,
            img:'컴퓨터구조201801.JPG',  
            summary:'즉치주소지정방식에서는 주소 필드에 저장된 내용이 명령어에서 사용될 실제 데이터이므로 오퍼랜드 300이 AC에 적재되며, 직접주소지정방식은 주소 필드에 직접 오퍼랜드의 주소를 저장시키는 방식이므로 300번지에 저장된 618이 AC에 적재된다'
        },
        {//7
            q : "레지스터 주소지정방식과 레지스터 간접 주소지정방식을 이용한다면 각각 어떤 값이 AC에 적재될 것인가?",
            q1 : '' ,
            a : ["200 ,500","500, 300","500, 618","618, 300"],
            r : 1,
            img:'',  
            summary:' 레지스터 주소지정방식은 r1의 값이 ac에 적재된다. AC <- R1  레지스터 간접주소지정방식은 R1에 있는 200번지가 유효주소로 쓰여서 200번지에 있는 500이 ac에 저장된다.  AC <- M[R1]' 
        },
        {//8
            q : "상대 주소지정방식과 인덱스된 주소지정방식을 이용한다면 각각의유효주소는? (여기서 인덱스 레지스터는 R1 이다)",
            q1 : '' ,
            a : ["458,400","456,500","458,500","618,300"],
            r : 3,
            img:'',  
            summary:`
            상대주소 지정방식에서 유효주소는 주소 필드 (NBR 300) + PC의 내용이며  PC는 다음 명령어를 수행하기 위해 158로 증가되었으므로 = 300+ 158 = 458이 유효주소다, 
            인덱스 주소지정방식은 명령어의 주소부분 + 인덱스레지스터 값  (NBR = 300 +  R1 = 200 =  번지가 유효주소임 500 )`   
        },
        {//9
            q : "다음 마이크로 연산에 관한 설명으로 올바른 것은?",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 4,
            img:'컴퓨터구조201802.JPG',  
            summary:'Y와 T에 밑줄이 위에 없는경우 1이라는 뜻이고  밑줄이 있는경우 0이라는 의미이다. Y와 Y1이 1인경우 R0에 R0 + R1을 저장한다는 말이고 , 밑에 식은 Y에 밑줄이 올라가 있으니 0인 경우인데.  Y가 영이고 T1은 1인경우 R0 에 R1을 더하게 되는데 R1에 밑줄이 있으니 보수로 처리해서 더하는것인데 컴퓨터에서 뺄셈이 어렵기 때문에 보수로 뒤집어서 더해버리는것으로 처리하는것임  .'
        },
        {//10
            q : "다음 중 내부 버스에 대한 설명으로 올바르지 않은 것은?",
            q1 : '' ,
            a : ["중앙처리장치 내부의 연산장치와 레지스터간의 데이터 전송을 위한 공통 선로의 집합이다.","멀티플렉서와 디코더를 이용해서 구성할 수 있다","레지스터와 ALU를 이용해서 구성할 수 있다.","중앙처리장치 내부에서 정보를 전달할 수 있는 경로이다."],
            r : 3,
            img:'',  
            summary:'내부버스는 중앙처리장치 내부에서 정보를 전달할 수 있는 신호의 경로로 레지스터간 연결통로이다. 내부버스는 멀티플랙서와 디코더를 이용하여 구성할 수 있다. 기억장치와 중앙처리장치 사이의 데이터 전송을 위한 공통 선로의 집합은 주기억장치버스이며 입출력장치들을 내부적으로 연결하는 버스는 입출력버스이다.'
        },
        {//11
            q : "다음 그림은 제어단어의 각 필드를 나타내고 있다. 각 필드에 관한 설명 중으로 적절한 것은?",
            q1 : '' ,
            a : ["A와 D는 출발 레지스터를 선택하는 필드이다","B는 도착 레지스터를 선택하는 필드이다","F는 상태 레지스터의 상태값을 선택하는 필드이다.","H는 시프터에서 수행되는 연산의 하나를 선택하는 필드이다."],
            r : 4,
            img:'컴퓨터구조201803.JPG',  
            summary:'A와 B는 출발레지스터를 선택하는 필드이며, D는 도착레지스터를 선택하는 필드다 F는 ALU마이크로 연산을 선택하는 필드이며, H는 시프터 마이크로연산을 선택하는 필드이다.'
        },
        {//12
            q : "위 그림에서 나 와 라에 해당하는 것은 각각 무엇인가?",
            q1 : '' ,
            a : ["Flag Register, Shifter","Decoder, ALU","Decoder, Shifter","Flag Register, Multiplexer"],
            r : 1,
            img:'컴퓨터구조201804.JPG',  
            summary:'가는 처리장치의 선택신호에 따라 도착 레지스터를 결정하게 되는 디코더이며, 나는 ALU에서 산출연산을 수행한 수 연산 결과에 의해 세트되는 상태레지스터다. 다는 산솔/논리 연산을 수행하는 ALU이다.  라는 시프터이다.'
        },
        {//13
            q : "그림 다에 관한 설명으로 적절한 것은?",
            q1 : '' ,
            a : ["마이크로 프로그램의 조건부 분기를 구현하는데 필요하다","데이터를 비트단위로 이동시키는 시프트 연산을 수행한다.","산술논리연산을 수행한다","제어장치에서 처리장치를 제어하기 위해 필요한 정보가 저장되는 장소이다."],
            r : 3,
            img:'',  
            summary:'다는 산솔/논리 연산을 수행하는 ALU이다.'
        },
        {//14
            q : "위 그림에서 D에 관한 설명으로 적절한 것은?",
            q1 : '' ,
            a : ["마이크로프로그램의 조건부 분기를 구현하는데 필요하다.","데이터를 비트단위로 이동시키는 시프트 연산을 수행한다.","산술논리연산을 수행한다","도착레지스터를 결정하는데 필요하다"],
            r : 4,
            img:'',  
            summary:'가는 처리장치의 선택신호에 따라 도착 레지스터를 결정하게 되는 디코더이며'
        },
        {//15* ****** 무조건 나올듯
            q : "위 그림에서 레지스터 세트에 40개의 레지스터가 있고, 다는 20개의 연산, 라는 12개의 연산을 수행한다고 가정했을때 제어 단어는 몇비트가 되겠는가?",
            q1 : '' ,
            a : ["24","25","27","28"],
            r : 3,
            img:'',  
            summary:`레지스터 식별을 위한 비트 수
레지스터가 40개이므로, 제어단어의 (디코더 + 멀티플렉서 2개 ) 필드는 각각  6비트가 필요하다
레지스터 40개를 처리하려면 제어단어의 해당 필드가 2의 6제곱이 되어야 처리가 가능 ( 2의 5제곱= 32  2의 6제곱 = 64 ) 
그래서 제어단어의 디코더 멀티플랙서 필드 6 + 6 + 6 =  18 다는 ALU이며 20개의 연산을 위해서 5비트가 필요함 (2의 5승= 32  2의 4승= 16  4승으로는 20개의 연산 처리불가),  
라는 시프터이며 12개의 연산을 처리하려면 4비트가 필요함 (2의 3승 =8 2의 4승 = 16)   값을 다 더하면  멀티플렉서필드 2개 -> 6비트+6비트 + ALU필드 5비트 + 시프터필드 4비트 + 디코더필드 6비트 = 총 27비트
`
        },
        {// 16
            q : "다음중 마이크로프로그램에 의한 제어방식의 설명으로 잘못된 것은?",
            q1 : '' ,
            a : ["다양한 주소지정방식을 갖는다","명령어 집합을 변경하기 쉽다","비교적 복잡한 명령어 집합 컴퓨터에 적합하다","하드웨어에 의한 방식에 비해 컴퓨터의 처리속도가 향상된다."],
            r :4,
            img:'',  
            summary:'마이크로프로그램 제어의 중요한 장점은 하드웨어 구성이 한번 만들어지면 더이상의 하드웨어나 연결 형태를 변화시킬 필요가 없다는 것이다. 다른 제어순서를 구성하고자 할때에는 제어기억장치에 다른 마이크로명령어를 기억시키기만 하면 된다, 기억장치에 여러 개의  단어로 2진 제어값을 지정하여 사용하는 제어장치이다 , 기억장치에 저장된 각각의 단어는 시스템에서 수행할 하나 이상의 마이크로 연산을 지정하는 마이크로 명령어에 해당된다, 제어변수값들을 여러 개의 단어로 결합하여 표현하고 그것을 연속적으로 읽어서 제어논리회로에 공급하여 동작시키는 방식이다  '
        },
        {//17
            q : "그림에서 MUX 1에 대한 설명으로 잘못된 것은?",
            q1 : '' ,
            a : ["내부 주소와 외부 주소 중의 하나를 선택하는 장치다.","MUX1의 선택신호로 1비트가 필요하다","선택신호로서 (O)2은 내부구조를, (1)2은 외부주소를 선택한다.","MUX1의 출력은 디코더와연결된다."],
            r : 4,
            img:'컴퓨터구조201805.JPG',  
            summary:'MUX1은 제어주소 레지스터 CAR과 연결된다.'
        },
        {//18
            q : "그림에서 만일 MUX1에서 가 로 입력되는 데이터가 7비트고 다른 것은 변동이 없다면 나 는 어떻게 바뀌는가?",
            q1 : '' ,
            a : ["64 * 26","128 * 27","256 * 28","512 * 28"],
            r : 2,
            img:'',  
            summary:'6비트인 경우에 ROM에서 총 26비트로 처리가 가능하지만 7비트가 되면 64 단어로 처리가 되지 않는다  (2^6 = 64, 2^7 = 128) 그래서 7비트 128단어로 증가시   (16 + 6 + 3 + 1  = 26) 에서 (16 + 7 + 3 + 1 = 27 로 증가하게된다.) '
        },
        {//19
            q : "그림에서 다 와 관련된 내용으로 적절한 것은?",
            q1 : '' ,
            a : ["처리장치로서 입력 16비트는 제어단어이다.","인코더로서 입력 16비트는 상태비트로 인코딩한다.","시프터로서 입력 16비트는 시프트 연산의 종류를 결정한다.","산술논리연산장치로서 입력 16비트는 산술논리연산의 종류를 결정한다."],
            r : 1,
            img:'',  
            summary:'다는 처리장치이다.'
        },
        {//
            q : "그림에서 가 에 들어갈 내용으로 적절한 것은?",
            q1 : '' ,
            a : ["처리장치","제어장치","제어주소 레지스터","산술논리연산장치"],
            r : 3,
            img:'',  
            summary:'제어주소 레지스터 CAR'
        },
        {//21
            q : "다음과 같은 비트 연산을 수행하려 할때 그림에서 제어기억장치의 26비트에 대한 설명으로 잘못된 것은?",
            q1 : 'R4 <- 0, if (S = 1) then (CAR <- 37) else (CAR <- CAR + 1)' ,
            a : ["1~16번 비트는 마이크로연산 R4 <- 0 을 수행한다.","17번 비트는 (1)2 이어야한다"," 18~20번 비트는 조건문 if(S=1)을 수행한다.","21~26번 비트는 주소 37번지를 나타낸다."],
            r : 2,
            img:'',  
            summary:'17번 비트는 일반적으로 조건을 만족할 때 다음 마이크로명령어 주소를 분기하도록 하는 비트입니다. 설명에서 "17번 비트는 (1)이어야 한다"라고 되어 있는데, 이 비트는 항상 1이어야 하는 것은 아닙니다. 실제로 17번 비트는 조건 분기 여부를 설정하는 비트로, 조건이 참일 때 분기할지 아닐지를 결정하는 역할을 합니다.'
        },
        {//22
            q : "아래 그림은 컴퓨터의 두 가지 구성요소 사이의 상호관계를 보여주고 있다. 괄호 (A)와 (B)에 각각 들어갈 용어들을 순서대로 나열한 것은?",
            q1 : '' ,
            a : ["입력 데이터, 출력 데이터","제어신호, 상태신호","제어장치, 처리장치","처리신호, 제어신호"],
            r : 2,
            img:'컴퓨터구조201806.JPG',  
            summary:''
        },
        {//23
            q : "다음 중 중앙처리장치에서 명령어의 연산코드 (OP code)가 보관되는데 사용되는 레지스터는",
            q1 : '' ,
            a : ["PC","AC","IR","SP"],
            r : 3,
            img:'',  
            summary:'중앙처리장치에서 수행할 연산을 지정하는 필드이다'
        },
        {// 24
            q : "다음과 같은 일련의 마이크로연산은 명령어 사이클 중 어느 사이클인가?",
            q1 : '' ,
            a : ["인출 사이클","실행 사이클","간접 사이클","인터럽트 사이클"],
            r : 1,
            img:'컴퓨터구조201807.JPG',  
            summary:''
        },
        {//
            q : "다음과 같은 일련의 마이크로연산은 무엇을 수행하는 것인가?",
            q1 : '' ,
            a : ["LOAD 명령어","STORE 명령어","AND 명령어","ADD 명령어"],
            r : 2,
            img:'컴퓨터구조201808.JPG',  
            summary:''
        },
        {//26
            q : "다음중 SP(Stack Pointer)의 설명으로 잘못된 것은?",
            q1 : '' ,
            a : ["비트 수는 기억장치의 용량에 따라 결정된다.","다음에 수행되어질 명령어가 들어있는 주소를 갖고 있다.","PC(Program Counter)와 동일한 비트 수를 갖는다","스택 공간의 최상위 구조를 갖고있다."],
            r : 2,
            img:'',  
            summary:'스택포인터는 스택 주소지정방식에서 사용되며, 스택의 최상위 주소를 지정한다 (TOS : Top of Stack) , 스택은 스택 포인터와 스택영역으로 나뉜다. 스택포인터는 CPU 내부에 있는 레지스터로서 스택 영역의 번지를 지정해주는 포인터다. 스택영역은 실제로 데이터가 저장되는 기억장소로 기억장치에 있다. 따라서 스택포인터는 프로그램 카운터와 같은 크기의 비트수를 갖는다. / 2번은 프로그램 카운터의 내용이다. '
        },
        {//
            q : "다음 설명에서 괄호안에 들어갈 용어로 적절하지 않은 것은?",
            q1 : '명령어 사이클 중 (   가   )은 기억장치로부터 명령어를 가져오는 것을 말한다. 이때 가져올 명령어 주소는 (  나  )에 들어있다.' ,
            a : ["가: 제어사이클  나: 명령어 레지스터","가 : 인출사이클 , 나: 데이터 레지스터","가 : 실행사이클   나 : 스택 포인터","가: 인출 사이클   나: 프로그램 카운터"],
            r : 4,
            img:'',  
            summary:'명령어의 주소는 PC 프로그램 카운터가 가지고 있다. '
        },
        {//28
            q : "다음 중 기억장치와 그 특성을 연결한 것으로 올바른 것은?",
            q1 : '' ,
            a : ["연관 기억장치  -  memory 공간확대","가상 기억장치 - memory access 속도증가","캐시기억장치 = memory access 속도증가","복수모듈기억장치 - memory 공간확대"],
            r : 3,
            img:'',  
            summary:''
        },
        {//29
            q : "기억장치에 기억되어있는 데이터를 이용하여 기억장치에 접근할 수 있기 때문에 내용 주소화 기억장치 (CAM : content addressable memory)라고도 불리는 기억장치는",
            q1 : '' ,
            a : ["연관기억장치","복수모듈기억장치","가상기억장치","캐시기억장치"],
            r : 1,
            img:'',  
            summary:''
        },
        {//
            q : "위에서 복수모듈기억장치를 설명하고 있는 것은?",
            q1 : '' ,
            a : ["A","B","C","D"],
            r : 4,
            img:'컴퓨터구조201809.JPG',  
            summary:''
        },
        {//31
            q : "위에서 캐시기억장치를 설명하고 있는것은?",
            q1 : '' ,
            a : ["A","B","C","D"],
            r : 3,
            img:'',  
            summary:''
        },
        {//
            q : "다음 중 버스의 중재에 있어서 우선순위를 정하는 방법으로 외부의 하드웨어 회로를 이용하는 방법은?",
            q1 : '' ,
            a : ["데이지 체인 방식","핸드쉐이킹 방식","입출력 제어방식","프로그램 제어방식"],
            r : 1,
            img:'',  
            summary:''
        },
        {//33
            q : "다음 중 입출력 장치 인터페이스에 포함되어야 하는 하드웨어가 아닌 것은?",
            q1 : '' ,
            a : ["데이터 버퍼","장치의 동작상태를 나타내는 플래그 ","장치번호 디코더","멀티플랙서"],
            r : 1,
            img:'',  
            summary:''
        },
        {//
            q : "다음중 DMA 제어에 대한 설명으로 올바른 것은?",
            q1 : '' ,
            a : ["직접 주기억장치에서 접근해서 이루어지는 입출력 제어방식","중앙처리장치 제어를 통한 입출력 제어방식","입출력 프로세서인 채널을 이용한 제어방식","프로그램과 인터럽트를 이용하는 입출력 제어방식"],
            r : 1,
            img:'',  
            summary:'직접 주기억장치에 접근하여 입출력을 행하는 방식이며, '
        },
        {//
            q : "다음 중 프로그램 수행에 필요한 작업을 시간적으로 중첩하여 수행시키는 처리기는?",
            q1 : '' ,
            a : ["Pipeline processor","Array processor","data Flow machine","VLSI processor"],
            r : 1,
            img:'',  
            summary:'파이프라인 프로세서는 명령어를 여러 단계로 나누어 병렬로 처리하는 프로세서 설계 기법입니다. 명령어 실행을 여러 단계(예: 인출, 해석, 실행, 쓰기)로 나눠 각 단계를 동시에 수행할 수 있도록 하여 성능을 높입니다./ 어레이 프로세서는 여러 개의 연산 유닛을 병렬로 배치하여 한 번에 다수의 데이터 요소에 대해 동일한 연산을 수행할 수 있는 프로세서입니다 / 데이터 플로우 머신은 전통적인 명령어 기반의 프로세서와 달리 데이터의 흐름을 중심으로 연산이 이루어지는 아키텍처입니다. 프로그램은 명령어의 순서에 따라 실행되는 것이 아니라, 데이터가 준비되는 즉시 연산이 수행됩니다. / VLSI (Very Large Scale Integration)는 수백만 개의 트랜지스터를 하나의 칩에 집적할 수 있는 기술로, 이를 기반으로 제작된 프로세서입니다. VLSI 기술은 고성능, 저전력, 소형화된 프로세서를 가능하게 하였습니다'
        },
    ]
    const test2019cs :Testtype[] =[
        {//
            q : "다음 컴퓨터 명령어를 구성하는 연산코드 필드(OP codefield)에 대한 설명으로 가장 적절한 것은?",
            q1 : '' ,
            a : ["기억장치 주소 혹은 처리장치 레지스터를 선택하기 위한 필드이다.","명령어의 주소지정 방식을 지정하는 필드이다.","중앙처리장치에서 수행할 연산을 지정하는 필드이다","인터럽트 요청을 위한 제어필드이다."],
            r : 3,
            img:''
            ,  summary:''
        },
        {// 2
            q : "다음 컴퓨터 명령어에 관한 설명으로 적절한 것은?",
            q1 : '' ,
            a : ["2-주소 컴퓨터 명령어이다","데이터 전송을 위한 컴퓨터 명령어이다","컴퓨터의 내부구조로 볼 때 누산기를 이용하는 컴퓨터 명령어이다"," 컴퓨터의 내부구조로 볼 때 다중 레지스터를 이용하는 컴퓨터 명령어이다."],
            r : 3,
            img:'컴퓨터구조2019.JPG'
            ,  summary:''
        },
        {//3 
            q : "위의 프로그램은 다음 중 어느 수식을 계산하는 것인가?",
            q1 : '' ,
            a : ["X= ( A + B ) * C","X = ( A - B ) * C","X = ( A + B ) / C","X = ( A - B ) + C"],
            r : 2,
            img:'컴퓨터구조201901.JPG'
            ,  summary:''
        },
        {//
            q : "프로그램에서 (a)의 괄호안에 들어갈 식으로 알맞은 것은?",
            q1 : '' ,
            a : ["AC <- AC * M[X]" , "AC <-M[A]","AC<-M[X]","M[X] <- AC"],
            r : 2,
             img:'컴퓨터구조201901.JPG'
            ,  summary:''
        },
        {//
            q : "위의 프로그램과 관계가 깊은 명령어 형식은?",
            q1 : '' ,
            a : ["3-주소 명령어","2-주소 명령어","1-주소 명령어","0-주소 명령어"],
            r : 3,
            img:'컴퓨터구조201901.JPG'
            ,  summary:`1. 3-주소 명령어 (Three-address instruction)
설명: 3-주소 명령어는 연산에 필요한 두 개의 피연산자와 결과를 저장할 목적지 주소를 모두 명시하는 명령어입니다.
형식: ADD R1, R2, R3
R1에 R2와 R3를 더한 결과를 저장.
장점: 연산에 필요한 데이터와 결과를 각각의 레지스터나 메모리에 명확히 지정할 수 있어 코드가 간결해짐.
단점: 명령어가 길어질 수 있으며, 더 많은 레지스터나 메모리 주소가 필요함.
2. 2-주소 명령어 (Two-address instruction)
설명: 2-주소 명령어는 피연산자 중 하나가 결과를 저장할 대상과 같은 주소를 사용합니다. 즉, 하나의 피연산자는 연산 후 덮어씌워집니다.
형식: ADD R1, R2
R1에 R2를 더하고 결과를 R1에 저장.
장점: 명령어 길이가 짧고, 주소 공간을 절약할 수 있음.
단점: 결과가 피연산자 중 하나를 덮어씌우기 때문에 추가적인 메모리 이동 명령이 필요할 수 있음.
3. 1-주소 명령어 (One-address instruction)
설명: 1-주소 명령어는 주로 누산기(Accumulator)를 사용하여 연산을 수행합니다. 피연산자 하나는 명시하고, 다른 하나는 누산기에 암묵적으로 존재합니다.
형식: ADD R1
누산기에 저장된 값에 R1을 더하고 결과를 누산기에 저장.
장점: 명령어가 매우 간단하고 짧음.
단점: 누산기를 계속 사용해야 하므로 유연성이 떨어짐.
4. 0-주소 명령어 (Zero-address instruction)
설명: 0-주소 명령어는 주로 스택 기반 구조에서 사용됩니다. 피연산자는 스택에서 암묵적으로 가져오고, 연산 결과도 스택에 저장됩니다.
형식: ADD
스택의 두 최상위 값을 더하고 그 결과를 스택에 저장.
장점: 명령어가 매우 짧고 간단하며 주소를 명시할 필요가 없음.
단점: 스택 기반 연산에 의존해야 하며, 다른 방식보다 속도가 느릴 수 있음.`
        },
        {// 6 
            q : "다음 중 컴퓨터 명령어와 컴퓨터의 내부구조와의 관계가 적절하게 연결된 것은?",
            q1 : '' ,
            a : ["0-주소 명령 : 다중 레지스터를 이용한 구조","1-주소 명령 : 단일 누산기를 이용한 구조","2-주소 명령 : 스택을 이용한 구조","3-주소 명령 : 프로그램 카운터를 이용한 구조"],
            r : 2,
                img:''
            ,  summary:''
        },
        {//
            q : "직접 주소지정방식과 간접 주소지정방식을 이용한다면 각각의 유효주소는?",
            q1 : '' ,
            a : ["500,400","500,818","818,456","818,900"],
            r : 2,
                img:'컴퓨터구조201902.JPG'
            ,  summary:`1. 직접 주소 지정 방식 (Direct Addressing Mode)
설명: 명령어에 피연산자의 실제 메모리 주소가 직접 포함되어 있는 방식입니다. 즉, 명령어에 명시된 주소에서 데이터를 가져와 연산에 사용합니다.
특징:
피연산자가 저장된 메모리 주소가 명령어에 명시되어 있음.
상대적으로 간단하고 이해하기 쉬움.
장점: 명령어가 간결하고 연산 속도가 빠름(주소 해석이 바로 가능).
단점: 주소 공간이 한정되어 있을 때 유연성이 떨어질 수 있음.
예시: MOV A, 1000 (메모리 주소 1000에 있는 데이터를 레지스터 A로 이동)
2. 간접 주소 지정 방식 (Indirect Addressing Mode)
설명: 명령어에 포함된 주소는 실제 데이터가 있는 메모리 주소를 가리키는 포인터 역할을 합니다. 즉, 명령어에서 제공하는 주소로 이동한 후 그 주소에 저장된 값이 실제 데이터의 위치가 됩니다.
특징:
명령어에 포함된 주소는 포인터 역할을 하며, 이 포인터가 가리키는 주소에서 실제 데이터를 가져옴.
다단계 간접 참조도 가능함.
장점: 메모리 주소 공간을 효율적으로 사용하고, 유연성이 높음(포인터를 이용한 간접 참조).
단점: 주소 해석 과정이 추가되므로 연산 속도가 느릴 수 있음.
예시: MOV A, (1000) (메모리 주소 1000에 저장된 주소에서 데이터를 가져와 레지스터 A로 이동)`
        },
        {//8
            q : "간접 주소지정방식과 상대 주소지정방식을 이용한다면 각각 어떤 값이 AC에 적재될 것인가?",
            q1 : '' ,
            a : [""],
            r : 2,
                img:'컴퓨터구조201902.JPG'
            ,  summary:` 간접주소지정방식은 주소 필드에 유효주소가 저장되어 있는 기억장치주소를 기억시키는 방식이므로 유효주소는 500번지에 저장되어있다
                500번지에 저장된 818번지가 유효주소가 된다. 따라서 818번지에 저장되어있는 456이 AC에 적재된다
                상대주소 지정방식에서 유효주소는 주소 필드 + PC의 내용이며  PC는 다음 명령어를 수행하기 위해 258로 증가되었으므로 500+ 258 = 758 번지가 유효주소가 되며
                758번지에 저장된 700이 AC에 적재된다.
`
        },
        {//
            q : "인덱스된 주소지정방식과 레지스터 주소지정방식을 이용한다면 각각 어떤 값이 AC에 적재될 것인가?",
            q1 : '' ,
            a : ["458,400","500,818","800,818","900,800"],
            r : 1,
             img:'컴퓨터구조201902.JPG'
            ,  summary:`인덱스된 주소지정방식의 유효주소는 명령어 주소의 부분 + 인덱스 레지스터의 
            내용이므로 (문제에서 레지스터를 사용할경우 R1을 사용하라고 했으므로 ) 
            유효주소는 500 + 400 = 900번지이며, 레지스터 간접주소지정방식의 유효주소는 
            지정된 레지스터에 있는 주소이므로 R1에 있는 400번지가 유효주소이다.
            레지스터 주소지정방식 (Register Addressing Mode)
       레지스터 주소지정방식은 명령어에서 피연산자의 실제 데이터가 레지스터에 직접 저장된 경우입니다.
        이 경우, R1에 저장된 값 400이 바로 피연산자로 사용되며, 메모리를 참조하지 않고 R1의 값이 그대로 AC에 적재됩니다.
따라서 레지스터 주소지정방식에서는 AC에 400이 적재됩니다
            `
        },
        {//10
            q : "아래 그림은 상태 레지스터의 구조를 나타낸 것이다. 그림에서 (가)에 들어갈 상태비트로서 적절한 것은?",
            q1 : '' ,
            a : ["부호 비트","제로 비트","캐리 비트","오버플로우 비트"],
            r : 4,
                img:'컴퓨터구조201903.JPG'
            ,  summary:''
        },
        {//
            q : "다음 중 내부 버스에 대한 설명으로 적절한 것은?",
            q1 : '' ,
            a : ["중앙처리장치와 레지스터간의 데이터 전송을 위한 공통 선로의 결합이다.","멀티플렉서와 ALU를 이용해서 구성할 수 있다.","레지스터와 ALU를 이용해서 구성할 수 있다","중앙처리장치 내부에서 정보를 전달 할 수 있는 경로이다."],
            r : 4,
                img:''
            ,  summary:''
        },
        {//12 ----
            q : "다음 마이크로 연산에 관한 설명으로 적절한 것은?",
            q1 : '' ,
            a : ["T1 + T2 은 산술 마이크로 연산이다.","R0에는 R1 - R2의 결과가 저장된다.","모두 세가지 마이크로 연산이 수행된다.","R3에는 R4와 R5의 논리 곱 연산 결과가 저장된다."],
            r : 2,
                img:'컴퓨터구조201904.JPG'
            ,  summary:''
        },
        {//13
            q : "중앙처리장치에서 내부 버스를 구성하는 방법은 멀티플렉서와 ㄱ 를 이용한다. 여기서 앞의 괄호 안의 ㄱ 에 해당되는 장치는 위의 그림에서 어디인가?",
            q1 : '' ,
            a : ["가","나","다","라"],
            r : 1,
                img:'컴퓨터구조201905.JPG'
            ,  summary:''
        },
        {//14
            q : "위 그림에서 나에 대한 설명으로 적절한 것은?",
            q1 : '' ,
            a : ["출발레지스터의 내용을 ALU로 보내는데 필요하다","도착 레지스터를 결정하는데 필요하다","상태비트를 보관하는데 필요하다","ALU의 결과를 비트 단위의 이동을 위해 필요하다"],
            r : 3,
                img:'컴퓨터구조201905.JPG'
            ,  summary:''
        },
        {//15
            q : "위 그림에서 레지스터 세트에 15개의 레지스터가 있고, 다 는 21개의 연산, 라 는 7개의 연산을 수행한다고 가정했을 때 제어 단어는 몇비트가 되겠는가?",
            q1 : '' ,
            a : ["20","22","23","24"],
            r : 1,
                img:'컴퓨터구조201905.JPG'
            ,  summary:''
        },
        {//16
            q : "다음 중 처리장치에 있는 각 구성요소의 선택신호를 설명하는 것으로 잘못된 것은?",
            q1 : '' ,
            a : ["처리장치에서 수행되는 마이크로연산을 선택하는 신호","처리장치의 각 구성요소를 제어","선택신호로서 특정 마이크로연산을 선택","처리장치를 구동하는 클럭 신호"],
            r : 4,
                img:''
            ,  summary:''
        },
        {//17
            q : "다음 그림은 제어단어의 각 필드를 나타내고 있다. 각 필드에 관한 설명 중으로 적절한 것은?",
            q1 : '' ,
            a : ["A와 B는 출발레지스터를 선택하는 필드이다.","B는 상태 레지스터의 상태값을 선택하는 필드이다.","F는 쉬프터에서 수행되는 연산의 하나를 선택하는 필드이다.","H는 도착 레지스터를 선택하는 필드이다."],
            r : 1,
                img:'컴퓨터구조201906.JPG'
            ,  summary:''
        },
        {//18
            q : "그림에서 다 에 관련된 내용으로 적절한 것은?",
            q1 : '' ,
            a : ["처리장치로서 입력 16비트는 제어단어이다.","인코더로서 입력 16비트를 상태비트로 인코딩한다.","쉬프터로서 입력 16비트는 쉬프트 연산의 종류를 결정한다.","산술논리연산장치로서 입력 16비트는 산술논리연산의 종류를 결정한다."],
            r : 1,
                img:'컴퓨터구조201907.JPG'
            ,  summary:''
        },
        {//19
            q : "그림에서 만일 MUX1에서 가 로 입력되는 데이터가 6비트이고 다른것은 변동이 없다면 나는 어떻게 바뀌는가?",
            q1 : '' ,
            a : ["64 * 26","128 * 27", "256 * 27", "256 * 28"],
            r : 1,
                img:'컴퓨터구조201907.JPG'
            ,  summary:''
        },
        {//20
            q : "그림에서 가 에 들어갈 내용으로 적절한 것은?",
            q1 : '' ,
            a : ["처리장치","제어장치","제어주소 레지스터","산술논리연산장치"],
            r : 3,
                img:'컴퓨터구조201907.JPG'
            ,  summary:''
        },
        {//21
            q : "다음과 같은 연산을 수행하려 할 때 그림에서 제어기억장치의 27개 비트에 대한 설명으로 잘못된 것은?",
            q1 : '' ,
            a : ["1 ~ 16번 비트는 마이크로연산 R5 <- R6 + R3 를 수행한다.","17번 비트는 (0)2 이어야 한다.","18~ 20번 비트는 캐리의 상태에 따라 결정된다.","21번 ~ 27번 비트는 조건문 if(C=0)을 수행한다."],
            r : 4,
                img:'컴퓨터구조201908.JPG'
            ,  summary:''
        },
        {//
            q : "다음의 CPU에 있는 특수 레지스터 중에서 데이터를 기억하는 레지스터는?",
            q1 : '' ,
            a : ["IR(Instruction Register)","SP(Stack Pointer)","PC(Program Counter)","AC(Accumulator)"],
            r : 4,
                img:''
            ,  summary:''
        },
        {//
            q : "다음 중 중앙처리장치에서 명령어의 연산 코드 (OP code)가 보관되는데 사용되는 레지스터는?",
            q1 : '' ,
            a : ["PC","AC","IR","SP"],
            r : 3,
                img:''
            ,  summary:`IR 명령어 레지스터, SP스택포인터 PC프로그램카운터 `
        },
        {//24
            q : "다음 중 명령어 수행 사이클에 해당되지 않는 것은?",
            q1 : '' ,
            a : ["인출 사이클","저장 사이클","인터럽트 사이클","실행 사이클"],
            r : 2,
                img:''
            ,  summary:''
        },
        {//
            q : "다음과 같은 일련의 마이크로 연산은 무엇을 수행하는 것인가?",
            q1 : '' ,
            a : ["LOAD 명령어","STORE 명령어","AND 명령어","ADD 명령어"],
            r : 1,
                img:'컴퓨터구조201909.JPG'
            ,  summary:''
        },
        {//26
            q : "다음 중 CPU에 있는 레지스터에 대한 설명으로 잘못된 것은?",
            q1 : '' ,
            a : ["레지스터는 데이터의 임시 저장소로서 컴퓨터의 기억장치 중에서 엑세스 속도가 가장 빠르다","명령어 레지스터(IR)는 현재 수행되는 명령어를 갖고 있다.","프로그램 카운터(PC)는 다음에 수행되어질 명령어가 들어있는 주소를 갖고 있다.","스택 포인투(SP)는 특수 레지스터로서 스택에 있는 데이터를 갖고 있다."],
            r : 4,
                img:''
            ,  summary:''
        },
        {//
            q : "다음 설명에서 괄호 안에 들어갈 용어로 알맞은 것은?",
            q1 : '' ,
            a : ["가 : 스택포인터 나: 프로그램 카운터","가 : 프로그램 카운터 나 : 제어주소 레지스터","가 : 프로그램 카운터   나 : 명령어 레지스터","가 : 명령어 버퍼 레지스터   나 :  누산기"],
            r : 3,
                img:'컴퓨터구조201910.JPG'
            ,  summary:''
        },
        {//28
            q : "다음중 기억장치의 성능평가에 사용되는 요인으로서 기억장치에서 데이터를 판독하거나 기록하는 데 걸리는 시간을 나타내는 것은?",
            q1 : '' ,
            a : ["access time","cycle time","transfer time","hit time"],
            r : 1,
                img:''
            ,  summary:''
        },
        {//
            q : "다음 중 기억장치와 그 특성을 연결한 것으로 적절한 것은?",
            q1 : '' ,
            a : ["연관 기억장치  - memory 공간 확대"," 가상기억장치  - memory access 속도증가"," 캐시 기억장치  - memory access 속도증가","복수 모듈 기억장치  - memory 공간 확대"],
            r : 3,
                img:''
            ,  summary:''
        },
        {//30
            q : "위에서 기억장치 접근의 지역성(locallty)를 충분히 이용하는 기억장치를 두개 고르면?",
            q1 : '' ,
            a : ["A,B","B,C","C,D","A,D"],
            r : 2,
                img:'컴퓨터구조201911.JPG'
            ,  summary:''
        },
        {//
            q : "위에서 연관기억장치를 설명하고 있는 것은?",
            q1 : '' ,
            a : ["A","B","C","D"],
            r : 1,
                img:'컴퓨터구조201911.JPG'
            ,  summary:''
        },
        {//32
            q : "위에서 B에대한 설명으로 적합한 기억장치는?",
            q1 : '' ,
            a : ["복수모듈 기억장치","캐시 기억장치","가상 기억장치","보조 기억장치"],
            r : 3,
                img:''
            ,  summary:''
        },
        {//
            q : "중앙처리장치의 개입 없이 직접 주기억장치로 접근하여 데이터의 입출력을 수행하기 위해 주기억장치와 입출력장치 사이에 위치하는 장치를 무엇이라 하는가?",
            q1 : '' ,
            a : ["캐시","DMA","연관 메모리","가상 메모리"],
            r : 2,
                img:''
            ,  summary:''
        },
        {//34
            q : "버스 중재에 있어서 중재기에 가까운 순으로 우선순위가 주어지는 방법은?",
            q1 : '' ,
            a : ["중앙집중식 병렬중재 방법","우선순위 인코더 방법","폴링 중재방법","데이지 체인 중재 방법"],
            r : 4,
                img:''
            ,  summary:''
        },
        {//
            q : "다음 중 병렬처리기를 처리기의 상호연결망 구조에 따라 분류한 것으로 옳은 것은?",
            q1 : '' ,
            a : ["SISD, SIMD, MISD, MIMD" ,"다중장치 처리기, 파이프라인 처리기","버스, 크로스바, 트리, 입방체","공유 기억장치 시스템, 메시지 전달 시스템"],
            r : 3,
                img:''
            ,  summary:''
        },
    ]
    const testcswork :Testtype[] =[
        {//51파일  
            q : "다음중 컴퓨터 시스템의 주요 구성요소들에 대한 설명으로 부적절한 것은?",
            q1 : '' ,
            a : ["입력장치 : 사용자가 입력하는 데이터와 명령어를 받아서 컴퓨터가 알 수 있는 형태로 변환하여 기억장치나 중앙처리장치로 전달하는 장치이다.","시스템 버스 : 입력장치와 출력장치, 기억장치, 중앙처리장치들 간의 통신을 가능하게 해주는 통신 선로이다.","캐시 : 주기억장치와 보조기억장치 사이에 위치한 기억장치로서 데이터가 중앙처리장치에 보다 빨리 전달되게 한다.","보조기억장치 : 대량의 데이터를 저장하기 위한 장치로서 캐시나 주기억장치와 달리 전원이 꺼져도 저장된 데이터를 유지한다."],
            r : 3,
            img:'',
            summary:'캐시는 중앙처리장치와 주 기억장치 사이에 위치한 기억장치로 중앙처리장치와 주 기억장치 간의 속도 차이를 줄여주는 역할을 한다.'
        },
        {//
            q : "다음중 컴퓨터 발전과정의 특징들이 발전 순서대로 올바르게 열거된 것은?",
            q1 : '' ,
            a : ["트랜지스터 - 진공관 - 집적회로 (IC) - 대규모 집적회로 (LSI)"," 진공관 -  트랜지스터 - 집적회로 - 대규모 집적회로","집적회로- 진공관- 대규모집적회로 - 트렌지스터","진공관 - 집적회로 - 트렌지스터 - 대규모 집적회로"],
            r : 2,
            img:'',
            summary:'컴퓨터는 제1세대 - 진공관, 제2세대 - 트렌지스터, 제3세대 - 집적회로, 제4세대 - 대규모 집적회로 , 차세대 -VLSI순으로 발전되었다.'
        },
        {//03
            q : "다음 중 트랜지스터를 사용하는 컴퓨터는 어느것인가?",
            q1 : '' ,
            a : ["ENIAC","EDVAC","UNIVAC","TX-0"],
            r : 4,
            img:'',
            summary:'TX-0는 가장 초기의 트랜지스터 컴퓨터이다. ENIAC,EDVAC ,"UNIVAC는 진공관을 사용한 제 1세대 컴퓨터에 해당한다.'
        },
        {//
            q : "미래형 컴퓨터의 형태로 옳게 짝지어진 것은?",
            q1 : '' ,
            a : ["신경계망 컴퓨터, TX-0, UNIVAC","광컴퓨터, 신경망 컴퓨터, 대규모 병렬처리 컴퓨터","대규모 병렬처리 컴퓨터, 광컴퓨터 , PX-XT","광컴퓨터, 신경망 컴퓨터, UNIVAC"],
            r : 2,
            img:'',
            summary:'미래형 컴퓨터의 대표적 형태로  대규모 병렬처리컴퓨터, 광컴퓨터, 신경망 컴퓨터등이 있다.'
        },
        {//
            q : "컴퓨터 시스템의 구성요소 중 시스템 버스에 대하여 적절히 설명한 것은?",
            q1 : '' ,
            a : ["데이터를 처리하여 사람이 알아볼 수 있는 형태로 변환한다.","중앙처리장치가 처리한 데이터를 기억한다.","2개이상의 장치를 연결하는 통신선로이다.","연산과 제어작용을 수행한다."],
            r : 3,
            img:'',
            summary:'버스란 2개 이상의 장치를 연결해주는 통신선로를 말한다.  1은 출력장치 2는 주기억장치 4는 중앙처리장치를 나타낸다.'
        },
        {//
            q : "논리게이트의 두 입력 X , Y를 각각 X= 1 , Y= 0 이라고 했을때 출력 F가 F=1이 되는 논리게이트만 묶어놓은 것은?",
            q1 : '' ,
            a : ["AND, OR","OR, NAND","NAND. NOR","NOR, XOR"],
            r : 2,
            img:'',
            summary:'X=1, Y=0일때 F=1이 되는 논리게이트는 OR, NAND, XOR게이트다'
        },
        {//
            q : "불함수에 관한 설명으로 옳지 않은 것은?",
            q1 : '' ,
            a : ["불함수는 디지털 논리회로의 특성을 표시하는데 사용된다.","불함수는 논리게이트로 구성되는 논리회로도로 바꿀 수 있다.","하나의 불함수에 대한 진리표는 오직 하나뿐이다.","하나의 진리표에 대한 불함수는 오직 하나뿐이다."],
            r : 4,
            img:'',
            summary:'주어진 불함수에 대한 진리표는 하나이지만 동일한 진리표를 만족하는 불함수는 여러개일 수 있다.'
        },
        {//08
            q : "다음중 조합회로와 순서회로의 차이점으로 부적합한 설명은?",
            q1 : '' ,
            a : ["조합회로는 상태표로 입출력 특성을 표시할 수 있다.","순서회로는 플립 플롭과 조합회로로 구성된다고 볼 수 있다.","순서회로는 플립플롭을 가지고 있으나 조합회로는 플립플롭이 없다.","조합회로의 출력은 현재 입력만으로 결정되지만, 순서회로의 출력은 현재 입력과 저장요소의 값으로 결정된다."],
            r : 1,
            img:'',
            summary:'조합회로는 진리표로 입출력 특성을 표시할 수 있다.'
        },
        {//
            q : "다음 논리회로도와 관계가 깊은 것은?",
            q1 : '' ,
            a : ["반가산기","전가산기","전감산기","직렬가산기"],
            r : 3,
            img:'컴퓨터구조워크북01.JPG',
            summary:'전감산기는 2개의 반감산기와 OR 게이트로 구성된다.'
        },
        {//
            q : "데이터 전송 시스템에서 송신단에 적합한 회로는?",
            q1 : '' ,
            a : ["인코더","디코더","멀티플렉서","디멀티플렉서"],
            r : 3,
            img:'',
            summary:'데이터 전송 시스템의 송신단에는 멀티플랙서, 수신단에는 디멀티플렉서를 사용한다.'
        },
        {//
            q : "플립플롭에 관한 설명 중 옳지 않은 것은?",
            q1 : '' ,
            a : ["0 또는 1을 저장할 수 있다.","조합논리회로에 필수적으로 사용된다.","D 플립플롭은 입력신호를 지연시켜서 그대로 출력한다","T 플립플롭은 입력신호가 1일때 출력값의 보수를 출력한다."],
            r : 2,
            img:'',
            summary:'플립플롭은 순서논리회로에 필수적으로 사용된다.'
        },
        {//
            q : "다음 카운터의 설명 중 틀린 것은?",
            q1 : '' ,
            a : ["카운터의 입력펄수의 적용에 따라 미리 정해진 순서를 밟아가는 조합논리회로이다.","카운터를 동작 클록 펄스의 인가방식에 따라 분류하면 비동기식 카운터와 동기식 카운터로 나눌 수 있다.","BCD 리플 카운터는 0부터 9까지 10개의 상태를 계수하는 카운터다","모듈로-N 카운터는 n개의 상태를 반복하는 카운터이다."],
            r : 1,
            img:'',
            summary:'카운터는 플립플롭을 사용하는 순서논리회로로, 클록펄스가 입력될때마다 미리 정해진 일련의 순서에 따라 상태가 변한다.'
        },
        {//
            q : "컴퓨터 명령을 구성하는 필드와 설명이 적절하게 연결된 것은?",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 2,
            img:'컴퓨터구조워크북02.JPG',
            summary:'하나의 컴퓨터 명령을 구성하는 필드 중 방식필드는 주소필드에 대한 해석방법을 지정하고 , 연산코드 필드는 수행할 연산을 나타내며, 주소필드는 기억장치 주소나 처리기 레지스터를 선택하기 위한 주소를 나타낸다.'
        },
        {//
            q : "다음 중 컴퓨터 명령어와 컴퓨터 내부 구조의 관계가 적절하게 연결된 것은?",
            q1 : '' ,
            a : ["0-주소 명령 :  다중 레지스터를 이용한 구조","1-주소 명령 :단일 누산기를 이용한 구조","2-주소 명령 : 스택을 이용한 구조","3-주소명령 : 프로그램 카운터를 이용한 구조"],
            r : 2,
            img:'',
            summary:'0주소 명령 형식은 스택을 이용한 구조, 1주소 명령어 형식은 누산기 레지스터를 사용한 구조, 2주소 또는 3주소는 다중 레지스터를 이용한 구조로 2주소 명령 형식이 오퍼랜드가 2개, 3주소 명령 형식은 오퍼랜드가 3개인 명령어 구조다.'
        },
        {//
            q : "즉치주소지정방식과 직접주소지정방식을 이용한다면 각각 어떤 값이 AC에 적재되는가?",
            q1 : '' ,
            a : ["400, 500","400, 850","500, 850","850, 456"],
            r : 3,
            img:'컴퓨터구조워크북03.JPG',
            summary:'즉치주소지정방식에서는 주소 필드에 저장된 내용이 명령어에서 사용될 실제 데이터이므로 오퍼랜드 500이 AC에 적재되며, 직접주소지정방식은 주소 필드에 직접 오퍼랜드의 주소를 저장시키는 방식이므로 500번지에 저장된 850이 AC에 적재된다.'
        },
        {//
            q : "간접주소 지정방식과 상대주소 지정방식을 이용한다면 각각 어떤 값이 AC에 적재되는가?",
            q1 : '' ,
            a : ["456,700","456, 502","758,458","850,500"],
            r : 1,
            img:'',
            summary:'간접주소지정방식은 주소 필드에 유효주소가 저장되어 있는 기억장치 주소를 기억시키는 방식이므로 유효주소는 500번지에 저장되어있고, 500번지에 저장된 850번지가 유효주소가 된다. 따라서 850번지에 있는 456이 AC에 적재됨.   상대주소지정방식에서 유효주소는 주소필드 + PC의 내용이며 PC는 다음 명령어를 수행하기 위해 258로 증가되었으므로 500 + 258  = 758번지가 유효주소가 되며 758번지에 저장된 700이 AC에 적재된다.'
        },
        {//
            q : "인덱스된 주소지정방식과 레지스터 간접주소지정방식을 이용한다면 각각의 유효주소는?",
            q1 : '' ,
            a : ["400,500","458,500","500,400","900,400"],
            r : 4,
            img:'',
            summary:'인덱스된 주소지정방식의 유효주소는 명령어 주소의 부분 + 인덱스 레지스터의 내용이므로 (문제에서 레지스터를 사용시 R1을 사요하라 했음)  유효주소는 500 + 400 = 900번지이며,  레지스터 간접주소지정방식의 유효주소는 지정된 레지스터에 있는 주소이므로 R1에 있는 400번지가 유효주소다.'
        },
        {//
            q : "다음 그림은 제어단어의 각 필드를 나타내고 있다. 각 필드에 관한 설명으로 적절한 것은?",
            q1 : '' ,
            a : ["A와 D는 출발 레지스터를 선택하는 필드다.","B는 도착레지스터를 선택하는 필드다","F는 상태레지스터의 상태값을 선택하는 필드다","H는 시프터에서 수행되는 연산의 하나를 선택하는 필드이다."],
            r : 4,
            img:'컴퓨터구조워크북04.JPG',
            summary:'A와 B는 출발레지스터를 선택하는 필드이며, D는 도착레지스터를 선택하는 필드다 F는 ALU마이크로 연산을 선택하는 필드이며, H는 시프터 마이크로연산을 선택하는 필드이다.'
        },
        {//
            q : "마이크로연산에 대한 설명으로 옳지 않은 것은?",
            q1 : '' ,
            a : ["한 클록 주기 동안 수행된다.","일련의 비트에 대하여 병렬로 수행된다.","레지스터에 저장된 데이터를 대상으로 수행된다.","마이크로연산은 여러 개의 마이크로명령어로 수행된다."],
            r : 4,
            img:'',
            summary:'마이크로연산은 레지스터에 저장된 정보를 대상으로 수행하는 연산으로서 한 클록 주기동안에 일련의 비트에 대하여 병렬로 수행할 수 있는 가장 기본적인 연산이다. 한편 하나의 마이크로명령어는 하나 또는 여러개의 마이크로 연산을 나타낸다.'
        },
        {//
            q : "R1 에 R2의 2의 보수를 더한 후 R0에 저장하는 산술 마이크로 연산을 옳게 나타낸 것은?",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 1,
            img:'컴퓨터구조워크북05.JPG',
            summary:'2진수의 2의 보수를 구하는 방법은 1의 보수를 구한 후 1을 더하면 된다. 따라서 R2의 2의 보수는 _R2 +1 이다.'
        },
        {//21
            q : "다음중 시프트 마이크로연산의 설명으로 잘못된 것은?",
            q1 : '' ,
            a : ["레지스터 내의 데이터를 시프트시키는 연산이다","데이터의 측면이동에 사용된다","연산의 종류로는 가산 시프트와 감산 시프트가 있다.","왼쪽과 오른쪽 시프트에서 입력비트는 0으로 가정한다."],
            r : 3,
            img:'',
            summary:'시프트 마이크로 연산은 데이터의 측면이동에 사용되며, 출발 레지스터의 왼쪽 혹은 오른쪽으로 시프트 될 수 있다. 왼쪽과 오른쪽 시프트에서 입력비트는 0으로 가정하며 가산, 감산 시프트 연산은 존재하지 않는다.'
        },
        {//
            q : "위의 프로그램은 다음 중 어느 수식을 계산하는 것인가?",
            q1 : '' ,
            a : ["X = (A +B) *C","X=C*(A*B)","X=(A+B)/C","X=(A*B)+C"],
            r : 1,
            img:'컴퓨터구조워크북06.JPG',
            summary:'위의 프로그램은 먼저 주소 a가 가리키는 메모리의 내용을 AC로 가져와서 load a : AC <-m[a], 주소 b가 가리키는 메모리 내용과 합한 결과값을  AC에 저장하가고 (ADD B: AC <- AC + M[b]) 주소 X가 가리키는 메모리에 AC의 내용을 저장한다.  STORE X : M[X] <-AC  따라서 X에는 A+B가 저장된다. 그리고 주소 C가 가리키는 메모리의 내용을 AC로 가져와서 (LOAD C : AC <-M[C]) 주소 X가 가리키는 메모리 내용과 곱한 결과값을 AC에 저장하고 (MUL X : AC <- AC * M[C]) 주소 X가 가리키는 메모리에 AC의 값 (A+B)*C를 저장한다 STORE X : M[X] <- AC'
        },
        {//
            q : "위 프로그램에서 (e)에 들어갈 식으로 알맞은 것은?",
            q1 : '' ,
            a : ["M[X] <- AC * AC","AC <- AC*M[X]","AC <- M[AC*X]","M[X] <- AC*M[AC]"],
            r : 2,
            img:'',
            summary:'MUL X는 주소 X가 가리키는 메모리의 내용 M[X]와 AC 의 값을 곱한 결과값 AC* M[T]를 다시 AC에 저장하는 명령임'
        },
        {//
            q : "식 (b)와 관계 깊은 주소지정방식은?",
            q1 : '' ,
            a : ["의미주소지정","즉치주소지정","간접주소지정","상대주소지정"],
            r : 1,
            img:'',
            summary:'ADD B는 AC의 값과 주소 B가 가리키는 메모리 내용을 합한 결과값을 AC에 저장하라는 의미로, 명령어 ADD에 지정된 묵시적인 의미로 오퍼랜드 AC를 지정한다. 이러한 방식을 의미 주소지정이라 함'
        },
        {//
            q : "다음중 데이터 전송 명령어는?",
            q1 : '' ,
            a : ["XCH","NEG","SHL","RET"],
            r : 1,
            img:'',
            summary:'XCH (Exchange) 명령어는 두 레지스터 간 또는 레지스터와 기억장치 간의 정보를 서로 바꾸는 데이터 전송 명령이다. 참고로 NEG(Negation)은 데이터 처리 명령어(산술명령어)  SHL(Shift left)데이터 처리 명령어(시프트명령어) RET(Return)는 프로그램 제어 명령이다.'
        },
        {//
            q : "오퍼랜드의 비트를 선택적으로 몇개만 보수화하려한다. 다음 중 어떤 명령어로 가능한가?",
            q1 : '' ,
            a : ["OR","XOR","AND","COM"],
            r : 2,
            img:'',
            summary:'OR는 비트를 선택적으로 1로 세트시키고, XOR은 비트를 선택적으로 보수로 만들며, AND는 비트를 선택적으로 0으로 리셋시킨다. COM은 피연산자의 비트 전체를 모두 보수로 만든다.'
        },
        {//27
            q : "다음 중 내부버스에 대한 설명으로 적절한 것은?",
            q1 : '' ,
            a : ["기억장치와 중앙처리장치 사이의 데이터 전송을 위한 공통 선로의 집합이다.","멀티플랙서와 인코더를 이용하여 구성할 수 있다.","중앙처리장치 내부에서 정보를 전달할 수 있는 경로이다.","입출력장치들을 내부적으로 연결할 수 있는 통로이다."],
            r : 3,
            img:'',
            summary:'내부버스는 중앙처리장치 내부에서 정보를 전달할 수 있는 신호의 경로로 레지스터간 연결통로이다. 내부버스는 멀티플랙서와 디코더를 이용하여 구성할 수 있다. 기억장치와 중앙처리장치 사이의 데이터 전송을 위한 공통 선로의 집합은 주기억장치버스이며 입출력장치들을 내부적으로 연결하는 버스는 입출력버스이다.'
        },
        {//
            q : "다음 중 복합명령어 세트 컴퓨터(CICS : Complex Instruction Set Computer)의 특징과 관계가 없는 것은?",
            q1 : '' ,
            a : ["고급언어 동작을 지원하는 하드웨어를 제공하기 때문에 간결한 프로그래밍이 가능하다.","대부분의 명령어는 직접적으로 기억장치를 엑세스 할 수 있다.","명령어는 기본적인 연산과 복잡한 연산을 모두 수행한다.","명령어 포맷은 모두 같은 길이를 갖는다."],
            r : 4,
            img:'',
            summary:'정답 4번은 단축명령어 세트 컴퓨터의 특징이며 ,  복합명령어 세트 컴퓨터는 1, 2,3 외에도 다음과 같은 특징을 갖고있다. 1.프로그래밍 언어에서 사용하는 연산기능에 더 가깝도록 하면서 프로그램 규모를 작게하며 기억장치를 줄이도록 하는 명령어를 갖고있다. 2. 성능상의 효율은 RSC에서 기본연산만 할 경우와 비교할때 기억장치에서 가져오는 명령어 수가 줄어들기 때문에 향상된다, 3. 주소지정방식의 수가 상당히 많다. 4. 명령어 포맷은 여러개의 길이를 갖는다. '
        },
        {//29 좀이해 안감
            q : "다음 중 단축명령어 세트 컴퓨터 (RICS : Reduced Instruction Set Computer)의 특징과 관계없는 것은?",
            q1 : '' ,
            a : ["주소지정방식의 수가 상당히 많다.","명령어는 기본적인 연산만 수행한다.","명령어가 간단하고 유연한 구조를 가지며, 실행속도도 빨라지고 더 높은 처리능력을 갖는다.","기억장치 액세스는 로드와 스토어 명령어에 의해서만 가능하고, 데이터 처리명령어는 레지스터 대 레지스터 모드에서만 가능하다."],
            r : 4,
            img:'',
            summary:'앞문제의 해설을 참고해라'
        },
        {//
            q : "시스템버스를 사용하는 시스템에서 시스템버스의 사용을 중재하기 위해 필요한 것은?",
            q1 : '' ,
            a : ["버스 중재기","멀티플렉서","채널","제어기"],
            r : 1,
            img:'',
            summary:'시스템버스는 여러 장치가 하나의 데이터 전달 회선을 시간에 따라 멀티플랙싱 하여 사용하기 때문에 어떠한 단위의 시간 동안에는 하나의 데이터 전달만 수행해야 한다. 따라서 장치들간의 데이터 전달을 위해 시스템버스 사용의 중재기능을 하는 버스 중재기가 필요하다. 만약 한순간에 하나 이상의 데이터 전달이 이루어진 다면, 버스상에 나타나는 데이터가 그 자체의 의미를 잃어버리게 된다. 따라서 주장치가 데이터 전달을 위해 버스를 사용하려면 우선 중재기에게 버스 사용권한을 요청해야 하며. 그 중재기로부터 요청에 대한 승인을 얻어야만 버스를 사용할 수 있다.'
        },
        {//
            q : "제어선의 구성요소로 부적절한것은?",
            q1 : '' ,
            a : ["기억장치 쓰기선","기억장치 읽기선","전송 확인선","CPU요청선"],
            r : 4,
            img:'',
            summary:'제어선의 구송요소는 기억장치 쓰기선, 기억장치 읽기선, 입출력 쓰기선, 입출력 읽기선, 전송확인선, 버스 요청선, 버스 승인선, 인터럽트 요청선, 인터럽트 확인선, 클록선, 리셋선 등이 있음'
        },
        {//
            q : "레지스터에 관한 설명 중 옳지 않은 것은?",
            q1 : '' ,
            a : ["레지스터는 컴퓨터의 가장 기본적 구성요소이다.","레지스터는 하나 이상의 연산을 수행할 수 있다.","레지스터에 저장되어있는 데이터에 대해서 실행하는 연산을 마이크로 연산이라고 한다.","두 레지스터의 내용을 합하는 것은 마이크로 연산에 해당하지 않는다."],
            r : 4,
            img:'',
            summary:'마이크로연산은 대게 한 클록 사이클 동안 비트 열에 대해서 병렬로 실행된다. 마이크로연산의 예를 들면 한 레지스터의 내용을 다른 레지스터로 옮기는 것, 두 레지스터의 내용을 합하는 것. 레지스터의 내용을 1만큼 증가시키는 것 등이다.'
        },
        {//
            q : "그림에서 가와 나에 해당되는 것은 무엇인가?",
            q1 : '' ,
            a : ["디코더, 상태 레지스터","디코더 ,ALU","멀티플렉서, 디코더","ALU, 시프터"],
            r : 1,
            img:'컴퓨터구조워크북07.JPG',
            summary:'가는 처리장치의 선택신호에 따라 도착 레지스터를 결정하게 되는 디코더이며, 나는 ALU에서 산출연산을 수행한 수 연산 결과에 의해 세트되는 상태레지스터다.'
        },
        {//
            q : "그림 다에 관한 설명으로 적절한 것은?",
            q1 : '' ,
            a : ["마이크로프로그램의 조건부 분기를 구현하는데 필요하다.","데이터를 비트 단위로 이동시키는 연산을 수행한다.","산술/논리 연산을 수행한다.","제어장치에서 처리장치를 제어하기 위해 필요한 정보가 저장되는 장소이다."],
            r : 3,
            img:'',
            summary:'다는 산솔/논리 연산을 수행하는 ALU이다. 마이크로프로그램의 조건 분기를 구현하는데 필요한 것은 연산 결과에 대한 상태를 저장하는  나(상태레지스터)이며 제어장치에서 처리장치를 제어하기 위해 필요한 정보가 저장된 장소는 제어기억장치로 제어장치에 존재한다.'
        },
        {//
            q : "그림에서 레지스터 세트에 36개의 레지스터가 있고, 다는 19개의 연산, 라는 15개의 연산을 수행한다고 가정했을때 제어단어는 몇비트가 되는가?",
            q1 : '' ,
            a : ["24","25","27","28"],
            r : 3,
            img:'',
            summary:'레지스터 세트가 36개이므로 제어단어의 A,B,D필드는 각각 6비트(26 = 64) 가 필요하다. 또한 19개의 ALU마이크로 연산을 수행하기 위해서는 5비트 (25-32)가 필요하고 15개의 시프트 마이크로 연산을 수행하기 위해서는 4비트 (24=16) 가 필요하다. 따라서 제어단어는 6비트 (A필드 ) + 6비트 (B필드) + 5비트 (F필드) + 4비트(H필드) + 6비트 (D필드) = 27 비트가 필요하다'
        },
        {//
            q : "다음 (  ) 안에 들어갈 단어는?",
            q1 : '' ,
            a : ["출력장치","시스템버스","ALU","병렬처리장치"],
            r : 3,
            img:'컴퓨터구조워크북08.JPG',
            summary:'위의 글은 산술/논리 연산장치 ALU를 설명한 글이다.'
        },
        {//
            q : "위 그림은 무엇을 나타내는가?",
            q1 : '' ,
            a : ["데이터 전송의 단계","파이프라인의 실행단계","시프터의 실행단계","배열처리기의 장치단계"],
            r : 2,
            img:'컴퓨터구조워크북09.JPG',
            summary:'위 그림은 파이프라인에서 한순간에 부분적으로 진행되는 마이크로연산 실행과정을 나타낸 것이다.'
        },
        {//
            q : "위 그림에 대한 설명으로 옳지 않는 것은?",
            q1 : '' ,
            a : ["1클록 주기에서 1번 마이크로연산이 오퍼랜드 읽기 단계에 있다.","3,4,5,6,7 클록 주기의 파이프라인에 병목현상이 생긴다.","파이프라인의 이용률이 가장 적은 때는 1, 9클록 주기이다.","7개의 마이크로 연산이 모두 수행된다."],
            r : 2,
            img:'',
            summary:'위 그림은 3,4,5,6,7클록 주기일때 파이프라인이 최대한 활용되고 있는 상태이다.'
        },
        {//59페이지 116쪽 39번문제임
            q : "디지털 시스템에는 두가지 유형의 제어장치가 있는데 이를 옳게 짝지은 것은?",
            q1 : '' ,
            a : ["마이크로프로그램으로 구현한 제어장치, 소프트웨어로 구현한 제어장치","소프트웨어로 구현한 제어장치 - 하드웨어로 구현한 제어장치","하드웨어로 구현한 제어장치 - 마이크로프로그램으로 구현한 제어장치","마이크로 프로그램으로 구현한 제어장치 - 마이크로오퍼레이션으로 구현한 제어장치"],
            r : 3,
            img:'',
            summary:'전체적인 측면에서 보면, 디지털 시스템에는 두가지 서로 다른 유형의 제어장치가 있다. 하나는 마이크로프로그램으로 구현한 제어장치이고 다른 하나는 하드웨어로 구현한 제어장치이다.'
        },
        {//
            q : "마이크로프로그램 제어에 대한 설명으로 옳지 않은 것은?",
            q1 : '' ,
            a : ["기억장치에 여러 개의  단어로 2진 제어값을 지정하여 사용하는 제어장치이다","기억장치에 저장된 각각의 단어는 시스템에서 수행할 하나 이상의 마이크로 연산을 지정하는 마이크로 명령어에 해당된다.","제어변수값들을 여러 개의 단어로 결합하여 표현하고 그것을 연속적으로 읽어서 제어논리회로에 공급하여 동작시키는 방식이다.","하드웨어 구성이 한번 만들어진 후 다른 제어 순서를 구성하기 위해서는 연결형태를 변화시켜야 한다."],
            r : 4,
            img:'',
            summary:'마이크로프로그램 제어의 중요한 장점은 하드웨어 구성이 한번 만들어지면 더이상의 하드웨어나 연결 형태를 변화시킬 필요가 없다는 것이다. 다른 제어순서를 구성하고자 할때에는 제어기억장치에 다른 마이크로명령어를 기억시키기만 하면 된다.'
        },
        {//
            q : "일반적으로 CPU는 크게 두 부분으로 나뉘는데 이를 옳게 나타낸 것은?",
            q1 : '' ,
            a : ["출력장치와 제어장치","시스템버스와 기억장치","기억장치와 처리장치","처리장치와 제어장치"],
            r : 4,
            img:'',
            summary:'일반적으로 CPU는 대게 두 부분, 즉 처리장치와 제어장치로 나눌 수 있다. 처리장치는 레지스터, ALU, 시프터, 내부버스로 구성되어 있으며, 제어장치는 프로그램 카운터 명령어 레지스터. 제어논리로 구성되어 있다.'
        },
        {//
            q : "위 프로그램은 어떤 연산을 계산하는 것인가?",
            q1 : '' ,
            a : ["8개 레지스터에 있는 내용의 합을 구하는 프로그램","8개 레지스터에 있는 내용의 합의 보수를 구하는 프로그램","처음 4개 레지스터 내용의 합의 보수와 다음 4개 레지스터 내용의 합의 보수를 구하는 프로그램","8개 레지스터 내용의 각각의 보수를 구하여 합하는 프로그램"],
            r : 1,
            img:'컴퓨터구조워크북10.JPG',
            summary:'위 프로그램에서는 네쌍의 레지스터 (RI-1, RI), I= 1,3,5,7에 값이 더해져서 그 결과가 RI에 저장된다. 그리고 나서 결과 레지스터의 두쌍의 값이 더해진다. 끝으로 그 결과들이 더해져 최종 합이 R7에서 구해진다. 이 프로그램에서는 3개의 NOP명령어가 추가되는데 이것은 아무것도 실행하지 않는 명령어이다.'
        },
        {//
            q : "위 프로그램에서 NOP 명령어를 두는 이유는 무엇인가?",
            q1 : '' ,
            a : ["프로그램을 간단하게 하기 위해서","4단계 파이프라인에서 실행될 때 프로그램이 원활하게 작동하게 하기 위해서","프로그램이 서브루틴으로 분기 시 복귀주소를 저장하기 위해서","합산한 값의 보수를 구하기 위해서"],
            r : 2,
            img:'',
            summary:'위 프로그램에서 NOP 명령이 없다면, 4단계 파이프라인 실행시 4번의 명령의 결과가 저장되지 않은 상태에서 7번 명령어가 수행되므로 , 데이터 헤저드 현상이 발생한다. 단순화된 파이프라인에서 이와같은 오류를 피하기 위해 프로그램 내에 NOP를 사용한다.'
        },
        {//
            q : "다음 명령어 형식에 관한 설명의 성격이 다른 것은?",
            q1 : '' ,
            a : ["명령어의 대부분은 기억장치 내용을 오퍼랜드로 직접 동작시킬 수 있다.","8개의 주소 지정방식과 두 가지 명령어 형식 길이를 가지고 있다","명령어 중 몇개는 처리하는데 여러 클록 사이클이 요구하는 복잡한 동작을 수행한다.","각 명령어 형식은 32비트 워드 1개로 구성된다."],
            r : 4,
            img:'',
            summary:'1,2,3번 문항은 CISC구조를 명확하게 식별할 수 있는 특징이며, 4번문항은 RISC에 대한 설명이다. CISC는 복잡한 명령어 세트 컴퓨터 구조로, CPU가 한 번에 복잡한 명령어를 처리할 수 있도록 설계되었습니다.  RISC는 단순한 명령어 세트를 가진 프로세서 구조로, 간단한 명령어를 빠르게 처리할 수 있도록 설계되었습니다'
        },
        {//
            q : "다음의 내용과 관계 깊은 것은?",
            q1 : '어떤 내용이 한번 참조되면, 곧바로 다시 참조되기 쉽다.' ,
            a : ["공간적 지역성","시간적 지역성","내부적 참조성","외부적 참조성"],
            r : 2,
            img:'',
            summary:'컴퓨터 시스템에서 프로그램이 동작하는 방법에는 "지역성의 원리"가 있는데, 이것은 어떤 내용이 한번 참조되면 곧바로 다시 참조되기 쉬운 시간적 지역성과 어떤 내용이 참조되면 그 내용에 가까운 곳에 있는 다른 내용들이 곧바로 참조되기 쉬운 공간적 지역성을 말함'
        },
        {//
            q : "다음의 기억장치를 가장 빠르고 비싼 순서로 나열한 것은?",
            q1 : ' ㄱ : CPU   ㄴ : 캐시기억장치  ㄷ : 주기억장치  ㄹ : 보조기억장치' ,
            a : ["ㄱ-ㄴ-ㄷ-ㄹ","ㄴ-ㄱ-ㄷ-ㄹ","ㄱ-ㄴ-ㄹ-ㄷ","ㄴ-ㄱ-ㄹ-ㄷ"],
            r : 1,
            img:'',
            summary:'컴퓨터 기억장치는 일반적으로 속도가 빠를수록 고가이며, 위 내용을 빠른 순서대로 나열하면 ㄱ ㄴ ㄷ ㄹ 순이다.'
        },
        {//
            q : "다음의 그림이 나타내는 것은?",
            q1 : '' ,
            a : ["연관기억장치","단일모듈기억장치","복수모듈기억장치","캐시기억장치"],
            r : 3,
            img:'컴퓨터구조워크북11.JPG',
            summary:'기억장소와 이에 접근하기 위해 필요한 MAR 와 MBR을 묶어서 기억장치 모듈이라고 하며, 복수모듈기억장치는 기억장치 모듈을 여러개 가지고 있느 ㄴ기억장치이다.  위 그림은 복수모듈기억장치를 나타낸 것이다.'
        },
        {//
            q : "주기억장치와 중앙처리장치의 속도 차이를 보완하고자 하는 목적의 기억장치는?",
            q1 : '' ,
            a : ["연관기억장치","단일모듈기억장치","복수모듈기억장치","캐시기억장치"],
            r : 4,
            img:'',
            summary:'주기억장치의 속도는 중앙처리장치의 속도에 비해 매우 느리다. 이러한 문제점을 해결하기 위한 방법으로 캐시기억장치가 나오게 되었다. 캐시기억장치는 주기억장치보다 속도가 빠른 기억소자들로 구성되어 중앙처리장치와 주기억장치 간의 속도 차이를 줄여주는 역할을 한다.'
        },
        {//
            q : "다음의 단어들과 가장 관계 깊은 기억장치는?",
            q1 : '물리주소, 희생불록, 조각화, 페이지' ,
            a : ["가상기억장치","캐시기억장치","주기억장치","연관기억장치"],
            r : 1,
            img:'',
            summary:'가상기억장치는 주기억장치의 용량이 부족한 점을 개선하기 위한 기법으로, 비트당 가격과 기억용량이 보조기억장치와 같고 속도가 주기억장치와 같은 기억장치를 제공받는 기법이다. 위의 단어들은 가상기억장치 기법에 사용하는 용어이다.'
        },
        {//
            q : "가상기억장치 기법에서 주기억장치의 유휴공간이 없는 상태이며 원하는 데이터가 주기억장치에 없을 경우 어떻게 되는가?",
            q1 : '' ,
            a : ["주기억장치와 상관없이 보조기억장치에서 원하는 데이터를 가져온다","주기억장치에 유휴공간이 생길때 까지 기다린다.","희생블록을 결정하여 보조기억장치에 있는 필요한 데이터와 교환한다.","해당 프로그램이 다시 시작된다."],
            r : 3,
            img:'',
            summary:'가상기억장치에는 원하는 데이터가 주기억장치에 없을 경우, 주기억장치에 있는 블록중 필요없는 블록을 선택하여 보조기억장치의 원하는 데이터가 있는 블록과 교환한 후 주기억장치에 접근한다. 이때 교환되는 블록을 희생블록이라고 한다.'
        },
        {//
            q : "다음중 디스크 접근시간에 해당되지 않는 것은?",
            q1 : '' ,
            a : ["회전지연시간","데이터 전송시간","탐색시간","전송지연시간"],
            r : 4,
            img:'',
            summary:'디스크에 대한 접근시간은 다음과 같은 요소의 합이다. -탐색시간 : 헤드를 트랙까지 이동하는데 소요되는 시간 - 회전지연시간 :  회전하고 있는 디스크의 해당 데이터가 있는 섹터의 시작주소에 헤드가 위치하게 될 때까지의 시간  - 전송시간 : 데이터 전송률에 따른 전송시간'
        },
        {//
            q : "회전속도가 5000rpm , 데이터 전송속도가 4mb/초, 평균탐색시간이 15ms인 이동헤드 디스크의 평균 접근시간은 얼마인가?",
            q1 : '' ,
            a : ["21.128ms","15.128ms","36.666ms","21.333ms"],
            r : 1,
            img:'',
            summary:'평균탐색시간 = 15ms , 데이터 전송시간 = 512바이트 / 4*(10의 6제곱/초) = 0.128 * (10의-3제곱?)초 = 0.128ms  평균 회전지연시간 = 1/2 * 1/5000분 = 6ms    15ms + 6ms +0.128 = 21.128ms '
        },
        {//53
            q : "다음 중 버스의 사용을 중재하는 방식에 해당하지 않는 것은?",
            q1 : '' ,
            a : ["중앙집중식 병렬중재","데이지 체인중재","폴링에 의한 중재","분산중재"],
            r : 4,
            img:'',
            summary:'버스의 사용을 중재하는 방식에는 중앙집중식 병렬중재, 직렬중재 혹은 데이지 체인중재, 폴링에 의한 중재의 세가지 방법이 있다.'
        },
        {//
            q : "버스의 사용을 중재하는 방식 중 한 버스에 하나의 중재 중재기를 사용하는 방식으로 모든 장치가 독립된 버스 요청과 버스 허용회선에 의하여 중재되는 방식은?",
            q1 : '' ,
            a : ["중앙집중식 병렬중재","데이지 체인중재","폴링에 의한 중재","분산중재"],
            r : 1,
            img:'',
            summary:'중앙집중식 병렬중재는 한 버스에 하나의 중재기를 사용하는 방식이다. 중앙집중식 중재기를 사용할 경우 중재기 내에 장치들의 우선순위를 부여하는 논리회로가 있어야 하며, 높은 우선순위의 장치가 버스 사용을 독점하는 것을 방지할 수 있는 알고리즘이 구현되어야 한다.'
        },
        {//
            q : "핸드셰이킹 방식과 관꼐가 적은것은?",
            q1 : '' ,
            a : ["데이터 준비선과 인지 선을 사용한다","인터럽트로 시작되는 데이터 전송에 사용되는 통신방식이다","전송오류가 발생하면 타임아웃 기법으로 검출할 수 있다","송수신 장치의 능동적 참여로 데이터 전송의 신뢰성이 있다."],
            r : 2,
            img:'',
            summary:'2개의 핸드셰이킹선은 송신장치가 발생하는 데이터 준비선과 수신장치가 발생하는 인지 선이다. 그리고 핸드셰이킹은 송수신장치의 능동적 참여로 데이터를 전송하기 때문에 유연성과 신뢰성이 매우 높다. 또한 데이터 전송 오류를 검출하기 위해서 타임아웃 기법을 사용한다.'
        },
        {//
            q : "데이터의 입출력 전송이 직접 주기억장치와 입출력 장치 사이에서 이루어지는 인터페이스를 무엇이라 하는가?",
            q1 : '' ,
            a : ["DMA","캐시","데이지 체인","가상 메모리"],
            r : 1,
            img:'',
            summary:'DMA는 중앙처리장치의 개입없이 주 기억장치에 직접 접근하여 입출력을 가능하게 하는 인터페이스이다. 캐시는 중앙처리장치와 주기억장치 사이에 존재하여 중앙처리장치와 주기억장치 간의 속도 차이를 줄여 주는 역할을 하며 데이지 체인은 여러 장치가 하나의 데이터 전달회선을 사용하기 위한 버스의 중재방식 중 하나이다.'
        },
        {//
            q : "채널에 연결된 입출력장치들이 시분할 공유하여 입출력할 수 있는 장치는?",
            q1 : '' ,
            a : ["선택기 채널","멀티플렉서 채널","서브 채널","크로스바 채널"],
            r : 2,
            img:'',
            summary:'멀티플랙서 채널은 선택기 채널에 대응하는 것으로 멀티플렉서 채널에 연결된 입출력장치들은 채널을 시분할 공유하여 입출력할 수 있다. 멀티플렉서 채널을 이용한 입출력도 하나의 명령어에 의하여 데이터 블록의 입출력이 이루어지므로 멀티플렉스 하고자 하는 입출력 장치마다 채널 제어기를 이용한 입출력에 필요한 데이터 블록의 위치와 크기 등의 정보가 주어져야 되며, 이에 따른 하드웨어가 있어야 한다.'
        },
        {//
            q : "다음 중 중앙처리장치에 의한 입출력으로만 묶인 것은?",
            q1 : '' ,
            a : ["프로그램에 의한 입출력 - 인터럽트에 의한 입출력","프로그램에 의한 입출력 - DMA 입출력","DMA 입출력 - 인터럽트에 의한 입출력","DMA 입출력 - 프로세서 입출력"],
            r : 1,
            img:'',
            summary:'중앙처리장치에 의한 입출력에는 프로그램에 의한 입출력과 인터럽트에 의한 입출력의 두가지가 있다.'
        },
        {//
            q : "플린의 분류법에 따르면 여러개의 처리기에서 수행되는 명령어는 서로 다르지만 전체적으로 하나의 데이터 스트림을 가지고 있는 형태의 컴퓨터 구조는 어디에 속하는가?",
            q1 : '' ,
            a : ["MISD","MIMD","SISD","SIMD"],
            r : 1,
            img:'',
            summary:'플린FLYNN의 분류법은 처리기가 동시에 수행할 수 있는 명령과 데이터의 수에 따라 병렬처리기를 SISD, SIMD, MISD, MIMD 등 네가지로 분류한 것이다. 여기서 S는 단일 M은 다중을 의미하고 I는 명령 스트림 D는 데이터스트림 을 의미한다. 따라서 서로 다른 명령을 같는 데이터에 대해서 처리하는 것은 MISD이다.'
        },
        {//
            q : "다음은 무엇에 의한 컴퓨터의 분류방식인가?",
            q1 : '' ,
            a : ["플린의 분류","펭의 분류","구조에 의한 분류","기억장치에 의한 분류"],
            r : 2,
            img:'컴퓨터구조워크북12.JPG',
            summary:'위의 내용은 펭FENG의 분류방식을 기술한 것이며, 팽은 컴퓨터를 병렬수행의 정도에 따라 분류했다. WSBS 처리는 한번에 한비트씩 처리하는 방식을 의미하며, WPBS처리는 M개의 단어를 묶어서 그중에서 1개의 비트 슬라이스 단위를 순차적으로 처리하는 방식이다 WSBP처리는 한번에 한 단어씩 처리하는 방식으로 가장 많이 사용되며, WPBS처리는 병렬처리의 가능성을 최대로 높인 처리방식이다.'
        },
        {//
            q : "프로그램 수행에 필요한 작업을 시간적으로 중첩하여 수행시키는 처리기는?",
            q1 : '' ,
            a : ["파이프라인 처리기","배열처리기","다중처리기","VLSI 처리기"],
            r : 1,
            img:'',
            summary:'파이프라인 처리기는 프로그램에 내제하는 시간적 병렬성을 활용하기 위하여 프로그램 수행에 필요한 작업을 시간적으로 중첩하여 수행시키는 처리기를 의미한다.'
        },
        {//
            q : "병렬 알고리즘을 직접 하드웨어로 구현하는 새로운 처리기 구조는?",
            q1 : '' ,
            a : ["파이프라인 처리기","배열 처리기","다중처리기","VLSI 처리기"],
            r : 4,
            img:'',
            summary:'최근에 VLSI 기술이 급속도로 발전하면서 병렬 알고리즘을 직접 하드웨어로 구현하는 새로운 처리기 구조가 등장했는데 이를 VLSI처리기라고 한다.'
        },
        {//
            q : "다음 중 병렬처리기를 처리기의 상호연결망 구조에 따라 분류한 것으로 옳은 것은?",
            q1 : '' ,
            a : ["SISD","SIMD","MISD","MIMD"],
            r : 3,
            img:'',
            summary:'1은 플린 분류법 2는 중첩기법 3은 처리기 상호연결망 주소 4는 기억장치 구조에 따라 병렬처리기를 분류한 것이다.'
        },
    ]
    const testunixwork :Testtype[] =[
        {//
            q : "리눅스의 특징으로 볼 수 없는 것은?",
            q1 : '' ,
            a : ["멀티태스킹을 지원한다.","여러종류의 파일 시스템을 지원한다.","대부분 어셈블리어로 작성된다.","소스 코드가 공개된다."],
            r : 3,
            img:''
            ,  summary:'리눅스는 대부분 c언어로 작성되어 있다. 약간의 어셈블리 코드를 포함한다.'
        },
        {//
            q : "리눅스 소프트웨어의 대부분은 어떤 라이선스를 따르고 있는가?",
            q1 : '' ,
            a : ["Apache라이선스","BSD 라이선스","GPL","MPL"],
            r : 3,
            img:''
            ,  summary:'리눅수는 주로 GNU GPL (general public license)를 따르고 있다.'
        },
        {//
            q : "UNIX와 유사한 공개 운영체제를 만들기 위한 프로젝트로 리처드 스톨먼에 의해 시작된 프로젝트는?",
            q1 : '' ,
            a : ["Eclipse 프로젝트","Debian 프로젝트","Fedora 프로젝트","GNU 프로젝트"],
            r : 4,
            img:''
            ,  summary:'GNU프로젝트로 상업적 저작권에 반대하여 공개 소프트웨어 라이센스인 GPL을 발표하였다.'
        },
        {//
            q : "수정된 프로그램의 재배포가 의무사항은 아니라서 소스코드의 비공개가 허용되는 라이선스가 아닌것은?",
            q1 : '' ,
            a : ["BSD라이선스","GPL","MIT 라이선스","Apache라이선스"],
            r : 2,
            img:''
            ,  summary:'GPL, LGPL, MPL등은 해당 라이센스의 소스 코드를 이용하여 개발된 프로그램의 경우 소스코드를 공개해야 하는 카피레프트 라이센스다'
        },
        {//
            q : "UNIX 운영체제에서 CPU, 메모리 등 주요 자원을 관리하며 가장 핵심적인 기능을 수행하는 프로그램은?",
            q1 : '' ,
            a : ["desktop","kernel","shell","vi"],
            r : 2,
            img:''
            ,  summary:'커널이 unix 운영체제의 핵심이다. 데스크톱은 윈도우 관리자나 그래픽 사용자 인터페이스를 제공하는 사용환경이고, shell은 명령어를 통한 대화형 사용자 인터페이스이며, vi는 편집기 프로그램이다.'
        },
        {//
            q : "Red hat 사에서 자사의 상용 리눅스 운영체제인 RHEL에 안정적인 새로운 기능을 추가하기 위해 테스트 베드로 사용함으로써 새로운 버전이 자주 발표된다는 특징을 가지는 리눅스 배포판의 이름은 무엇인가?",
            q1 : '' ,
            a : ["Ubuntu","Slackware","Fedora","CentOS"],
            r : 3,
            img:''
            ,  summary:'Red hat 사는 RHEL을 유료화 하는 대신 무료로 배포하는 Fedora의 버그나 결함을 참조하여 RHEL을 출시하고 있다.'
        },
        {//
            q : "GNU 정신에 가장 충실한 배포판이며, GNU 프로젝트의 공식적인 후원을 받는 유일한 배포판으로서 Ubuntu의 기초가 되었던 배포판은?",
            q1 : '' ,
            a : ["OpenSUSE","Slackware","Debian","CentOS"],
            r : 3,
            img:''
            ,  summary:'데비안 리눅스는 이안 머독의 데비안 프로젝트에서 많은 자원봉사자의 자발적 참여로 개발되었다.'
        },
        {//
            q : "수정 프로그램에 대한 소스코드의 공개를 요구하지 않는 라이선스로 BSD 라이선스와 비슷하나 특허권 등의 법적인 문제를 보완한 소프트웨어 라이선스는?",
            q1 : '' ,
            a : ["MPL","GPL","LQPL","Apache라이선스"],
            r : 4,
            img:''
            ,  summary:'아파치 라이선스는 아파치 웹 서비스를 포함한 아파치 재단 (ASF : apache software foundation)의 모든 소프트웨어에 적용되는 라이선스이다.'
        },
        {//24
            q : "하드디스크를 논리적으로 나눈 구역을 무엇이라 하는가?",
            q1 : '' ,
            a : ["가상 드라이브","논리 드라이브","섹터","파티션"],
            r : 4,
            img:''
            ,  summary:'하드디스크를 논리적으로 나눈 구역은 파티션이다. 최근 논리불륨이라고도 한다.'
        },
        {//
            q : "다음중 리눅스를 하드디스크의 비어있는 파티션에 설치 하는 방법과 관련이 가장 적은것은?",
            q1 : '' ,
            a : ["기존 운영체제에서 사용하지 않는 파티션이 있는지 확인한다.","새로운 하드디스크를 추가하여 파티션을 확보한다,","기존 파티션의 볼륨 축소를 통해 파티션을 확보한다","가상머신 소프트웨어를 이용하여 새 가상 하드디스크를 생성한다,"],
            r : 4,
            img:''
            ,  summary:'리눅스를 설치하려면 별도의 파티션이 필요하다 4는 가상머신에 게스트 운영체재를 설치할때 사용하는 방법이다.'
        },
        {//
            q : "리눅스에서 시스템 환경설정 파일이 주로 위치하는 디렉터리는?",
            q1 : '' ,
            a : ["/","/dev","/etc","/proc"],
            r : 3,
            img:''
            ,  summary:'/etc 디렉터리에 시스템의 중요한 환경설정 파일이 위치한다.'
        },
        {//
            q : "리눅스에서 장치파일이 위치하는 디렉터리는",
            q1 : '' ,
            a : ["/boot","/tmp","/dev","/sys"],
            r : 3,
            img:''
            ,  summary:'/boot에는 커널 이미지와 부트 로더의 설정파일 , /tmp에는 임시파일, /sys에는 시스템 정보가 저장된다.'
        },
        {//
            q : "PC에 장착된 SCSI 하드디스크 중 primary master 드라이브 (또는 첫번째 디스크)의 두번째 파티션을 리눅스의 파일명으로 표시하면",
            q1 : '' ,
            a : ["/dev /hda2","/dev /ide2","/dev /pdm2","/dev /sda2"],
            r : 4,
            img:''
            ,  summary:' scsi 드라이브이므로 장치명은 /dev /sd* 형태이며 첫번째 디스크이므로 a  두번째 파티션이므로 2를 붙여야 한다. '
        },
        {//
            q : "가상머신 소프트웨어를 이용하여 리눅스를 설치할 때 다음 중 가장 먼저 수행해야 하는 것은?",
            q1 : '' ,
            a : ["가상머신 만들기","네트워크 설정하기","Rocky linux 설치 프로그램 시작하기","bios 부팅순서 조정하기"],
            r : 1,
            img:''
            ,  summary:'리눅스가 설치될 가상머신을 먼저 만들고 설치 프로그램을 시작한다.'
        },
        {//
            q : "다음중 디렉터리와 해당 디렉터리의 일반적인 용도에 대한 설명으로 틀린 것은?",
            q1 : '' ,
            a : ["/: 일시적으로 부팅에 필요한 시스템 파일이 위치힌다","/usr : 시스템을 위한 명령, 라이브러리, 매뉴얼 페이지가 들어 있다.","/mnt : 마운트될 파일 시스템의 마운트 포인터가 되는 디렉터리가 존재한다.","/home : 사용자 파일이 저장된다."],
            r : 1,
            img:''
            ,  summary:'루트 디렉터리 (/)는 모든 파일과 디렉터리의 최상위 디렉터리이다.'
        },
        {//
            q : "모든 작업에 우선하여 동작하는 프로그램으로 CPU와 메모리 관리, 파일 시스템 관리, 프로세스 관리, 입출력 장치의 제어 등 운영체제의 핵심 기능을 수행하는 요소를 무엇이라 하는가?",
            q1 : '' ,
            a : ["응용 프로그램","데이터베이스","커널","유틸리티"],
            r : 3,
            img:''
            ,  summary:'원래 리눅스라는 용어는 리눅스 배포판이 사용하는 커널의 이름이다.'
        },
        {//
            q : "시스템 부팅과 함께 자동으로 마운트되어야할 항목과 옵션이 들어있는 곳은?",
            q1 : '' ,
            a : ["/home","/mount","/etc/fstab","/dev"],
            r : 3,
            img:''
            ,  summary:'/etc/fstab은 중요한 설정 파일로서 부팅시 자동으로 마운트 되는 파일 시스템의 목록을 가지고 있다.'
        },
        {//
            q : "부팅될때 필요한 파일을 포함하는 디렉터리로 커널 이미지 (vmlinuz)와 부트 로더의 설정파일이 있는 리눅스 표준 디렉터리는?",
            q1 : '' ,
            a : ["/kernel","/bin 과 /sbin","/etc","/boot"],
            r : 4,
            img:''
            ,  summary:'시스템 부팅과정에서 부트 로더는 /boot 디렉터리에서 필요한 파일을 찾아 부팅 과정을 진행한다.'
        },
        {//38
            q : "rocky linux에서 기본적으로 주어지는 셀의 종류는 무엇인가?",
            q1 : '' ,
            a : ["Bourne shell(sh)","Korn Shell(ksh)","Bash Shell(bash)","C Shell(csh)"],
            r : 3,
            img:''
            ,  summary:'bash는 대부분의 리눅스 배포판에서 기본으로 사용되는 쉘이다.'
        },
        {//
            q : "리눅스 명령어의 이름 개요 옵션 환경과 매개변수 등을 자세히 보여주는 명령어는?",
            q1 : '' ,
            a : ["cat","help","info","man"],
            r : 4,
            img:''
            ,  summary:'리눅스 각 명령어의 이름, 개요, 옵션, 환경과 매개변수 등을 자세히 보여주는 명령어는 man으로 온라인 메뉴얼을 제공한다.'
        },
        {//
            q : "다음 명령의 출력은? 사용자 홈 디렉터리는 /home/linuxuser라 가정한다.",
            q1 : 'echo "\'$Home\'"' ,
            a : ["$HOME","'$HOME'","/home/linuxuser","'/home/linuxuser'"],
            r : 4,
            img:''
            ,  summary:'큰 따옴표 안에서 달라($) 문자는 해석되므로 $변수에서 "변수확장"이 일어난다 . 큰따옴표 안에서 작은 따옴표는 그대로 출력된다.'
        },
        {//
            q : "다음 명령의 실행 결과로 예상되는 것은?",
            q1 : 'echo "Today is \`date\`"' ,
            a : ["Today is 'date'","\"Today is 'date'\"","Today is 2024. 10. 25 (금) 10:56:11 KST","아무것도 출력되지 않는다."],
            r : 3,
            img:''
            ,  summary:'앞서 푼 문제와 유사하게 큰 따옴표 ("") 안에서 역따옴표가(``) 해석되므로 `date`에서 명령 치환이 수행된다. '
        },
        {//
            q : "쉘에서 사용하는 특수문자 중 표준 출력을 파일로 지정하되 파일의 기존 내용에 덧붙여서 출력되도록 하는 것은?",
            q1 : '' ,
            a : [">","<",">>","<<"],
            r : 3,
            img:''
            ,  summary:'command >> file의 형태는 명령어 수행에서 나온 표준출력 결과를 화면으로 보내지 않고 지정된 파일의 끝에 덧붙일때 사용한다.'
        },
        {//
            q : "셀의 명령 행에서 사용하는 특수 문자에 대한 설명으로 옳은 것은?",
            q1 : '' ,
            a : ["& - 명령을 백그라운드로 실행"," ! - 바로 전에 실행한 명령","? - 임의의 문자열 패턴","| - 이전 명령이 실패하면 실행하라는 조건부 실행"],
            r : 1,
            img:'unix워크북.JPG'
            ,  summary:''
        },
        {//
            q : "Bash 쉘의 환경설정 파일 중 로그인할때 실행되는 것은?",
            q1 : '' ,
            a : ["~/.bahsrc","~/.bash_profile","~/.bash_history","~/.bash_logout"],
            r : 2,
            img:''
            ,  summary:'1은 비로그인 쉘이 시작될때 실행되고, 4는 로그아웃을 수행할 때 실행된다.'
        },
        {//51 4장
            q : "파일 목록을 보여주는 ls 명령에서 숨김 파일까지 보여주는 옵션은?",
            q1 : '' ,
            a : ["-a","-i","-l","-F"],
            r : 1,
            img:''
            ,  summary:'파일 이름이 도트(.)로 시작하는 숨김파일까지 보여주는 옵션은 -a 도는 -all이다'
        },
        {//
            q : "ls 명령의 옵션에 관한 설명 중 옳지 않은 것은?",
            q1 : '' ,
            a : ["-t :  파일 목록을 가로 방향으로 나열한다."," -a : 디렉터리 내의 모든 파일을 출력한다.","-l : 라인당 한 파일씩 자세한 정보를 출력한다.","-s : KB 단위로 파일 크기를 출력한다."],
            r : 1,
            img:''
            ,  summary:'-t는 수정시간을 기준으로 최근 파일부터 보여준다.'
        },
        {//
            q : "cd 명령에 관한 설명중 옳은 것은?",
            q1 : '' ,
            a : ["cd ~를 실행하였을 때 사용자의 홈 디렉터리로 이동한다.","cd를 실행하였을 때 현재 디렉터리의 위치를 출력한다.","cd -al 명령을 실행하면 현재 디렉터리에 있는 파일에 관한 모든 정보를 출력한다.","Change Disk의 약자로 CD Disk등을 바꿀때 사용한다."],
            r : 1,
            img:''
            ,  summary:'CD는 change directory의 약자다 틸트(~) 문자는 현재 사용자의 홈 디렉터리를 의미하며, ~user는 지정된 사용자의 홈 디렉터리를 의미한다.'
        },
        {//
            q : "텍스트 파일 memo.txt의 내용을 스페이스바를 누를 때마다 20줄씩 화면에 보여주는 명령어는?",
            q1 : '' ,
            a : ["cat +20 memo.txt","cat -20 memo.txt","more +20 memo.txt","more -20 memo.txt"],
            r : 4,
            img:''
            ,  summary:'more 명령에서 숫자 옵션이 한 화면에 해당하는 라인 수를 지정한다 기본값은 10라인이다. more 명령의  "+" 숫자옵션은 해당 라인부터 보여준다. '
        },
        {//
            q : "현재 디렉터리 아래에 있는 mydir 디렉터리 안에 mydoc 디렉터리만 있고 mydoc디렉터리는 비어있다. mydir 디렉터리와 mydoc 디렉터리를 동시에 삭제할 수 있는 명령어는?",
            q1 : '' ,
            a : ["rmdir -r mydir","rmdir -p mydir","rmdir -r mydir/mydoc","rmdir -p mydir/mydoc"],
            r : 4,
            img:''
            ,  summary:'mydir  디렉터리 아래에 mydoc 디렉터리만 있고 mydoc 디렉터리가 비어있다면 rmdir -p mydir/mydoc 명령으로 둘다 삭제가 가능하다. 비어있지 않은 디렉터리를 삭제하려면 rm -r mydir 명령어를 사용해야 한다.'
        },
        {//
            q : "현재 디렉터리에 있는 test 파일의 접근권한을 소유자는 읽기와 쓰기 권한, 그룹은 읽기 권한, 다른 사용자는 아무 권한이 없도록 설정하는 명령어는?>",
            q1 : '' ,
            a : ["chmod 'u+rw,g+r,o-rwx' test","chmod 640 test","chmod 'ug+r,u+w,o=' test","chmod 755 test"],
            r : 2,
            img:''
            ,  summary:'1과 3은 test 파일의 기존 권한에 소유자의 실행권한 , 그룹의 쓰기와 실행권한이 있었다면 그 권한이 그대로 유지되므로, 문제에서 요구하는 권한으로 설정되지 않을 수 있다. 4번은 소유자는 모든권한이 있지만 그룹과 다른사용자들은 읽기와 실행권한이 있는 상태이다. '
        },
        {//5장 62페이지
            q : "Rocky linux에서 제일 먼저 실행되는 사용자 프로세스 이며, PID가 1인 프로세스로 모든 사용자 프로세스의 최상위 부모 프로세스인것은?",
            q1 : '' ,
            a : ["boot loader","bootstrap loader","systemd","kernel"],
            r : 3,
            img:''
            ,  summary:'PID가 1인 제일먼저 실행되는 프로세스이며 모든 프로세스의 최상위 부모 프로세스인 것은 systemd이다.'
        },
          {//
            q : "시스템마다 약간의 차이는 있으나 전형적인 부팅 절차를 요약하면 다음과 같다 ㄱ에 들어갈 용어는 무엇인가?",
            q1 : '' ,
            a : ["프로세스","마스터 부트 레코드","부트 로더","부트 스트랩"],
            r : 3,
            img:'unix워크북01.JPG'
            ,  summary:'커널을 찾아 로드하는 것이 부트 로더의 역할이다.'
        },
          {//
            q : "위의 문제에서 ㄴ에 들어갈 내용은 무엇인가?",
            q1 : '' ,
            a : ["systemd 데몬","start 데몬","httpd 데몬","cron 데몬"],
            r : 1,
            img:''
            ,  summary:'systemd는 리눅스 운영체제의 시스템과 서비스 관리자로서 기존 init 프로세스가 하던 작업을 수행한다.'
        },
          {//
            q : "systemd가 수행하는 기능으로 옳지 않은 것은?",
            q1 : '' ,
            a : ["압축된 커널 이미지를 메모리에 로드하여 압축을 푼다,","파일 시스템을 마운트 한다","부팅시 구동되어야 할 서비스를 시작시킨다.","로그인 서비스를 시작시킨다."],
            r : 1,
            img:''
            ,  summary:'커널 이미지를 로드하는 것은 부트 로더의 기능이다.'
        },
          {//
            q : "리눅스 시스템의 런레벨에 관한 설명으로 잘못된 것은?",
            q1 : '' ,
            a : ["0 - 시스템 종료","1 - 단일 사용자 모드","3- 네트워크 기능을 지원하는 다중 사용자 모드","5- 시스템 재부팅"],
            r : 4,
            img:''
            ,  summary:'런레벨 5는 그래픽 사용자 환경을 지원하는 다중 사용자 모드이다. 재부팅에 사용되는 런레벨은 6이다.'
        },
          {//
            q : "현재 설정되어있는 기본 타깃을 확인하는 명령은?",
            q1 : '' ,
            a : ["systemctl isolate","systemctl list-dependencies","systemctl get-default","systemctl set-default"],
            r : 3,
            img:''
            ,  summary:'기본 타깃을 다른 타깃 유닛으로 변경하려면 관리자 권한으로 systemctl set default <name target>을 수행하면 된다.'
        },
          {// 31번 파일임
            q : "shutdown 명령을 수행하면 모든 프로세스는 시스템의 종료 소식을 접하면서 '프로세스가 스스로 종료하라'는 시그널을 받는다. 이 시그널은 무엇인가?",
            q1 : '' ,
            a : ["Process aborted(SIGABRT)","Interrupt(SIGINT)","Kill(SIGKILL)","Termination(SIGTERM)"],
            r : 4,
            img:''
            ,  summary:'SIGTERM 시그널을 보내는 것은 프로세스가 스스로 종료하라는 메시지를 보내는 것이다. SIGABRT는 프로세스가 중단(abort)되었다는. 시그널, SIGNT 는 키보드로부터 인터럽트 시그널, SIGKILL은 프로세스 강제종료 시그널이다.'
        },
          {// 
            q : "This System is going down 이라는 메시지를 전달하고 현재로부터 20분 후에 재부팅 하기 위한 명령은?",
            q1 : '' ,
            a : ["shutdown -h now \"This System is going down\"","shutdown -r +20 \"This System is going down\"","shutdown -r \"This System is going down\"","shutdown -c"],
            r : 2,
            img:''
            ,  summary:'shutdown 명령을 수행할 때 c옵션을 사용한 경우가 아니면 항상 인수로 시간을 지정해야 한다. 재부팅 옵션은 r이다.'
        },
          {// 
            q : "다음중 리눅스를 편리하게 사용할 수 있도록 그래픽 사용자 인터페이스와 윈두오 매니저 , 여러가지 유틸리티 프로그램을 통합하여 제공하는 환경은?",
            q1 : '' ,
            a : ["GNU","GNOME","Shell","X Window"],
            r : 2,
            img:''
            ,  summary:'GNOME은 리눅스의 대표적인 데스크톱 환경으로 대부분의 배포판에 포함되어 있다.'
        },
          {// 
            q : "다음과 같은 관리자 명령이 의도하는 것은?",
            q1 : '\> systemctl enable httpd.service' ,
            a : ["중지되었던 웹서버 데몬을 즉시 시작시키려는 것이다.","/user/lib/systemd/system 디렉터리에 httpd를 시작시키는 유닛을 추가하는 것이다.","httpd 서비스 유닛의 동작을 확인한 후 중지 상태라면 시작시킨다.","시스템이 부팅될때 자동으로 httpd 서비스를 시작시키려는 것이다."],
            r : 4,
            img:''
            ,  summary:'웹서버 대몬이 동작 중인지 확인하는 명령은 systemcil is active httpdservice 이다.'
        },
          {// 6장
            q : "리눅스 시스템에서 사용자 계정명, uid, gid 홈 디렉터리, 쉘 종류등 사용자 계정에 대한 자세한 정보가 저장되는 파일은?",
            q1 : '6장' ,
            a : ["/etc/group","/etc/login.defs","/etc/passwd","/ect/shadow"],
            r : 3,
            img:''
            ,  summary:'사용자 계정에 대한 자세한 정보가 저장되는 파일은 /etc/passwd이다'
        },
          {// 
            q : "sudo 명령에 대한 설명으로 옳지 않은 것은?",
            q1 : '' ,
            a : ["관리자 권한으로 명령을 수행하고자 할 때 사용한다.","모든 사용자가 sudo 명령을 수행할 수 있는것은 아니다.","/etc/sudoers 파일은 슈퍼유저 권한이 있어야 편집할 수 있다.","sudo 명령을 사용할 때 사용자는 root사용자의 비밀번호를 알고 있어야 한다."],
            r : 4,
            img:''
            ,  summary:'/etc/sudoers 파일에는 sudo 명령을 사용할 수 있는 사용자와 그 사용자에게 허용된 명령이 기록되어 있다.'
        },
          {// 74 36페이지
            q : "사용자 계정 생성과 관련이 있는 파일이 아닌 것은?",
            q1 : '' ,
            a : ["/etc/passwd","/etc/shadow","/etc/skel","/etc/fstab"],
            r : 4,
            img:''
            ,  summary:'/etc/fstab 파일에 부팅 시 자동으로 마운트 되는 파일 시스템에 대한 정보가 저장되어 있다.'
        },
          {// 
            q : "useradd 명령으로 사용자 계정을 추가하면 /home 디렉터리에 기본 사용자 디렉터리가 생성되고, 환경 설정을 위한 기본 파일이 복사된다. 다음 중 사용자 기본 환경 설정파일을 갖는 디렉터리는?",
            q1 : '' ,
            a : ["/etc/skel","/etc/rc.d","/etc/services","/etc/hosts"],
            r : 1,
            img:''
            ,  summary:'/etc/skel 디렉터리에는 .bashrc, .bach logout, .bash profile 등이 존재한다.'
        },
          {// 
            q : "사용자 계정을 실제로 삭제하지 않고 계정을 잠그는 명령은?",
            q1 : '' ,
            a : ["userdel -r user","userdel -f user","usermod -L user","usermod -U user"],
            r : 3,
            img:''
            ,  summary:'사용자 계정을 삭제할 때  /etc/passwd 파일에서 해당 사용자 계정의 라인만 삭제하고 홈 디렉터리가 그대로 남아 있을 수 있다. 이러한 경우 차후에 새로운 사용자가 삭제된 계정의 UID를 할당 받을 수 있는 무제가 생긴다.'
        },
          {// 
            q : "root 사용자가 사용자 kdhong의 비밀번호 변경에 사용하는 명령은?",
            q1 : '' ,
            a : ["info kdhong","change kdhong","passwd kdhong","chpasswd kdhong"],
            r : 3,
            img:''
            ,  summary:'인수 없이 단순한 passwd  명령을 수행하는 것은 자신의 비밀번호를 바꾸기 위한 것이다.'
        },
          {// 
            q : "사용자 계정과 그룹에 관한 일반적 설명으로 옳지 않은 것은?",
            q1 : '' ,
            a : ["사용자 계정을 생성할 때 기본적으로 사용자 계정과 같은 이름의 그룹(GID도 UID와 같음)이 만들어진다.","사용자 계정은 0개 이상의 부그룹에 속할 수 있다.","모든 사용자는 스스로 다른 부 그룹의 구성원으로 가입 할 수 있다.","모든 사용자 계정은 주 그룹을 가지며, 그것의 구성원이 된다."],
            r : 3,
            img:''
            ,  summary:'사용자 계정을 특정 그룹의 구성원이 되게 하는 작업은 해당 그룹의 비밀번호를 알고 있거나 관리자 권한이 있어야 가능하다.'
        },
          {// 7장 
            q : "vi 편집기로 작업한 뒤 변경된 내용을 저장하고 종료하려고 한다. 명령모드에 있다고 가정하고 다음중 어떠한 키를 입력해야 하는가?",
            q1 : '7장 vi 편집기' ,
            a : [":wq",":save",":q!","zz"],
            r : 1,
            img:''
            ,  summary:'명령 모드에서 바로 대문자 zz를 입력하면 편집중인 파일의 내용을 저장할 수 있다. 또는 명령 모드에서 :를 입력하면 라인모드로 들어간 후 wq를 누른다.'
        },
          {// 
            q : "vi 편집기가 명령 모드에 있을때 문자열 패턴을 검색하는 명령은?.",
            q1 : '' ,
            a : [":pattein","?pattein","!pattein","/pattein"],
            r : 4,
            img:''
            ,  summary:'/를 눌러 라인모드로 들어간 후 찾고자 하는 문자열 패턴을 입력하면 검색할 수 있다.'
        },
          {// 
            q : "vi 편집기의 명령 모드에서 이전 명령을 반복하는 키 입력은?",
            q1 : '' ,
            a : [".","^","+","$"],
            r : 1,
            img:''
            ,  summary:'이전 명령을 반복하는 것은 . 이며 취소하는것은 u 이다.'
        },
          {// 
            q : "vi 편집기의 명령 모드에서 커서가 위치한 단어를 치환하는 명령은?",
            q1 : '' ,
            a : ["dd","d)","cw","yy"],
            r : 3,
            img:''
            ,  summary:'dd 는 한 라인을 삭제하는 것이다. d)는 커서 위치부터 문장의 끝까지 삭제하는 것, yy는 현재 라인을 복사하는 명령어.  명령 모드에서 change word 를 의미하는 cw 는  입력시 커서 위치부터 단어의 끝까지 삭제되고, 입력모드로 전환되며 새로운 단어를 입력할 수 있다.'
        },
          {// 
            q : "vi 편집기의 명령 모드에서 입력 모드로 전환하기 위한 명령어가 아닌 것은?",
            q1 : '' ,
            a : ["a","i","o",":"],
            r : 4,
            img:''
            ,  summary:'a는 커서  다음 위치부터 입력, i는 커서 위치부터 입력, o는 커서 다음 라인에 입력하기 위한 명령이다.'
        },
          {// 
            q : "vi 편집기를 이용할 때 , 명령모드에서 현재 라인을 포함하여 총 10개 라인을 삭제하는 명령으로 알맞은 것은?",
            q1 : '' ,
            a : ["10dw","10x","10dd","d10O"],
            r : 3,
            img:''
            ,  summary:'10dw는 10개의 단어를 삭제하라는 명령이다.  10x는 10개의 문자를 삭제하라는 명령이다  d10G는 현재 라인부터 10번 라인까지 삭제하라는 명령이다.'
        },
          {// 
            q : "vi편집기의 명령모드에서 사용할 수 있는 명령과 그 기능이 잘못 설명된 것은?",
            q1 : '' ,
            a : ["i - 입력모드로 전환하기","u - 커서 이동하기"," d- 삭제","c - 변경"],
            r : 2,
            img:''
            ,  summary:'이전에 수행했던 명령을 취소undo 하려면 명령모드에서 u를 입력한다.'
        },
          {// 
            q : "다음중 vi 편집기의 커서 이동명령으로 알맞은 것은?",
            q1 : '' ,
            a : ["G- 문서의 마지막 라인으로 이동한다","W- 화면을 아래로 내린다 ","ctrl + f - 반페이지 위로 이동한다","/pattein 문자열 - pattein을 역방향으로 검색해 이동한다"],
            r : 1,
            img:''
            ,  summary:'명령모드에서 문자열 패턴을 순방향으로 검색할때 /pattein을 입력하며, 역방향 검색은 ?pattein으로 입력한다.'
        },
          {// 
            q : "find 명령의 사용례를 설명한 것으로 옳지 않은 것은?",
            q1 : '' ,
            a : ["(find /etc -name passwd) 파일이름이 정확히 passwd인 파일을 찾음","(find /usr/share -size +10M) 파일크기가 10M보다 큰 파일을 찾음","(find /home -user chris -ls) 소유자가 chris인 파일을 찾아 파일의 정보를 자세히 보여줌","(find /bin -mtime 644 -ls) 접근권한이 rwxr-xr-x인 파일이나 디렉터리를 찾아 정보를 보여줌"],
            r : 4,
            img:''
            ,  summary:'접근권한을 조건으로 지정하려면 옵션 perm을 사용한다. 또 8진수 표기법 644는 기호표기법으로 rx-r--r-- 이다'
        },
          {// 
            q : "/home 디렉터리와 그 서브디렉터리 구조에서 .bak으로 끝나는 파일을 모두 찾아 강제로 삭제하는 완전한 명령은 무엇인가?",
            q1 : '' ,
            a : ["rm -r /home/*.bak","find . -type f -exec grep '.*.bak' {} \\;","find /home -name '*.bak' -exec rm -f {} \\;","find /home -type '*.bak' -exec rm{} \\;"],
            r : 3,
            img:'',  
            summary:'find 명령은 기본적으로 지정된 디렉터리의 서브디렉터리도 검색한다 . 파일의 강제 삭제 명령은 rm -f file 이다'
        },
          {// 8장 
            q : "리눅스 시스템에서 파일로 취급되지 않는 것은?",
            q1 : '8장' ,
            a : ["inode 테이블","디렉터리","하드디스크 장치","심벌릭 링크"],
            r : 1,
            img:'',  
            summary:'inode 테이블은 파일 시스템에서 중요한 정보를 저장하지만 그 자체가 파일로 취급되는것은 아니다.'
        },
          {// 
            q : "마운트할 파일 시스템의 목록을 가지고 있는 파일은?",
            q1 : '' ,
            a : ["/dev/hda","/dev/mapper","/etc/fstab","/etc/rc.local"],
            r : 3,
            img:''
            ,  summary:'부팅시 자동으로 마운트 되는 파일 시스템의 목록 /etc/fstab에 라인별로 저장되어 있다.'
        },
          {// 
            q : "하드디스크의 파티션을 생성하는 명령어는?",
            q1 : '' ,
            a : ["fdisk","fsck","mkfs","mkswap"],
            r : 1,
            img:''
            ,  summary:'하드디스크 파티션을 생성하는 명령어는 fdisk이다. '
        },
          {// 
            q : "파일 시스템 관리를 위한 명령어가 아닌 것은?",
            q1 : '' ,
            a : ["fsck","fdisk","mkfs","reist"],
            r : 4,
            img:''
            ,  summary:'resist 는 채널링을 최초로 지원하였던 파일 시스템의 이름이다. fsck는 파일시스템을 감시하는 명령이다.'
        },
          {// 
            q : "볼륨 관리에 관한 설명으로 옳지 않은 것은?",
            q1 : '' ,
            a : ["여러 저장장치를 묶어 하나의 볼륨으로 만들 수 있다.","볼륨의 크기가 재조정 될 수 있는 파티션이다","볼륨관리를 위한 도구로 fdisk또는 mkfs를 사용한다 ","논리 볼륨에 파일 시스템을 만들 수 있다."],
            r : 3,
            img:''
            ,  summary:'볼륨 관리를 위한 도구는 LVM이며 볼륨의 생성과 관리를 위한 여러 관련 명령을 포함한다.'
        },
          {// 
            q : "파일 시스템이나 디스크 관리를 위해 사용되는 명령의 일반적 설명으로 옳은 것은?",
            q1 : '' ,
            a : ["df - 사용자의 디스크 사용량 한도를 결정한다.","fdisk - 하드 디스크 파티션을 관리하는 대화식 유틸리티 이다.","fsck - 디스크 파티션에 리눅스 파일 시스템을 생성한다.","umount - 파일 시스템을 디렉터리에 붙여 사용할 수 있게 한다."],
            r : 2,
            img:''
            ,  summary:'df는 파일 시스템의 디스크 공간정보를 보여주는 명령이다. fsck는 파일시스템을 검사하는 명령이다.'
        },
          {// 
            q : "파일에 사용되는 블록 수 를 보여주는 명령어는?",
            q1 : '' ,
            a : ["dc","dd","df","du"],
            r : 4,
            img:''
            ,  summary:'du는 disk usage를 의미하년 명령으로 파일에 사용되는 블록 수를 보여준다.'
        },
          {// 
            q : "변경을 기록하는 로그를 두어 시스템 비정상 종료시 파일 시스템의 복구를 쉽게 하는 방법은 무엇인가?",
            q1 : '' ,
            a : ["단편화","저널링","테일패킹","레이저"],
            r : 2,
            img:''
            ,  summary:'리눅스 기본 파일 시스템중에 ext2는 저널링 기능이 없으며, ext3과 ext4가 저널링 기능을 지원한다.'
        },
          {// 9장 프로세스 관리
            q : "프로세스 컨트롤 블록 (PCB)에 관한 설명으로 옳지 않은 것은?",
            q1 : '9장 프로세스관리' ,
            a : ["PCB에는 프로세스의 PID가 저장된다","PCB의 문맥 교환 정보로 레지스터의 상탯값이 저장된다","PCB에는 프로세스가 하랑받은 자원에 대한 정보가 저장된다.","PCB는 해당 프로세스가 관리하는 메모리 영역중 제일 앞에 위치한다."],
            r : 4,
            img:''
            ,  summary:'PCB는 커널에 의해 관리되고 커널 영역에 위치한다.'
        },
          {// 
            q : "프로세스가 준비상태에서 실행상태로 전이되는 과정인 것은?",
            q1 : '' ,
            a : ["대기(block)","디스패치(dispatch)","선점(preemption)","웨이크업(wakeup)"],
            r : 2,
            img:''
            ,  summary:'디스패치 또는 스케쥴이 준비상태에서 실행상태로 프로세스를 전이시킨다.'
        },
          {// 
            q : "셸에서 포어그라운드로 실행되는 프로세스를 stopped로 전환시키는 키 입력은?",
            q1 : '' ,
            a : ["ctrl + c"," ctrl + d ","ctrl + x","ctrl + z"],
            r : 4,
            img:''
            ,  summary:'ctrl + z로 포어그라운드로 실행되는 프로세스를 멈춤 상태로 전환시킬 수 있고, 이어서 bg명령을 수행하려면 해당 프로세스가 백그라운드로 실행된다. '
        },
          {// 
            q : "백그라운드 프로세스에 관한 설명으로 옳지 않은 것은?",
            q1 : '' ,
            a : ["셸 프롬프트에서 명령 뒤에 &를 입력하면 백그라운드 프로세스로 실행된다.","백그라운드 프로세스는 키보드 입력을 받을 수 없다","백그라운드 프로세스가 종료되어야만 셸이 명령대기상태가 된다","장시간 실행되어야 하는 명령을 실행할때 주로 사용한다."],
            r : 3,
            img:''
            ,  summary:'포어그라운드 프로세스와 다르게 백그라운드 프로세스를 실행시키면 셸은 즉시 명령대기상태가 된다.'
        },
          {// 
            q : "터미널을 빠져나가도 실행중인 프로그램이 종료되지 않고 계속 수행되게 해주는 명령어는?",
            q1 : '' ,
            a : ["exec","fg","nice","nohup"],
            r : 4,
            img:''
            ,  summary:'nohup은 터미널을 빠져나가도 실행중인 프로그램이 종료되지 않고 계속 수행되게 해주는 명령어이다.'
        },
          {// 
            q : "프로세스를 모니터링 하거나 관리하기 위한 명령으로 옳지 않은 것은?",
            q1 : '' ,
            a : ["ps - 실행중인 프로세스에 대한 정보를 보여준다.","top - 프로세스 모니터링과 관리를 위한 대화식 툴이다","kill- 지정된 프로세스를 백그라운드 모드로 전환한다.","nice - 프로세스를 실행할 때 우선순위 값을 설정한다."],
            r : 3,
            img:''
            ,  summary:'kill 은 프로세스에 시그널을 보내는 명령이다.'
        },
          {// 
            q : "다음 crontab 파일의 필드 표현중에 매주 월요이에 한번만 명령을 수행하게 하는 것은?",
            q1 : '' ,
            a : ["****1","1***1","11**1","111*1"],
            r : 3,
            img:''
            ,  summary:'정답 3번은 일, 월에 관계없이 (3~4번째 *) 월요일 (5번째 1)의 1시 1분에 명령을 수행하게 한다.'
        },
          {// 10장
            q : "rpm -qa | grep fire 를 실행하면 현재 시스템에 설치된 모든 패키지중 무엇을 수행하는가?",
            q1 : '10장 소프트웨어관리' ,
            a : ["fire라는 단어가 포함된 패키지만 출력한다.","fire이라는 단어가 포함된 패키지만 삭제한다.","fire이라는 단어가 포함된 패키지만 업그레이드 한다.","fire라는 단어가 포함된 패키지만 설치한다."],
            r : 1,
            img:''
            ,  summary:'rpm -qa는 설치된 모든 패키지를 출력한다.'
        },
          {// 
            q : "아래의 RPM 패키지에 대한 설명으로 옳지 않은 것은?",
            q1 : 'firefox - 102.8.0-2.el9_1.x86_64' ,
            a : ["패키지의 이름은 firefox이다","버전 번호는 102.8.0이다","레드햇 계열 리눅스 배포판에서 사용될 수 있다.","el9_1은 패키지가 설치될 수 있는 아키텍쳐의 종류이다."],
            r : 4,
            img:''
            ,  summary:'패키지 파일의 이름에서 레드햇 계열 리눅스 배포판(el9_1)의 응용 패키지임을 알 수 있다. 설치 가능한 CPU아키텍쳐는 x86_64이다'
        },
          {// 
            q : "아래 명령의 실행결과를 올바르게 설명한 것은?",
            q1 : '' ,
            a : ["의존성 문제로 패키지를 설치할 수 없다.","의존성 문제로 패키지를 삭제할 수 없다.","의존성 문제로 패키지를 업데이트 할 수 없다.","패키지가 삭제되었으나 기존 패키지에 의존성 문제가 발생한다."],
            r : 2,
            img:'unix워크북02.JPG'
            ,  summary:'rpm 명령에서  -e 옵션은 패키지를 삭제하는 것이다. 의존성 문제가 생긴다면 삭제되지 않는다.'
        },
          {// 
            q : "rpm과 비교했을때 dnf를 이용한 패키지 관리의 장점은?",
            q1 : '' ,
            a : ["이미 설치된 패키지를 업그레이드할 수있다.","패키지 변형 여부를 검증할 수 있다.","패키지의 설정 파일을 확인 할 수 있다.","패키지의 의존성 문제를 해결할 수 있다."],
            r : 4,
            img:''
            ,  summary:'DNF는 의존성 문제를 해결해 주는 명령행 기반의 유틸리티 이며 저장소 기반의 패키지 설치기능을 제공하는 고수준의 패키지 관리도구이다,.'
        },
          {// 
            q : "RPM패키지 관리자의 기능을 설명한 것으로 옳지 않은 것은?",
            q1 : '' ,
            a : ["패키지의 설치와 업그레이드 및 삭제 기능을 수행한다.","패키지에 관한 정보 확인 기능을 제공한다.","패키지의 의존성과 관련된 검사를 수행한다.","패키지를 설치할 때, 선행 패키지를 자동으로 설치해 준다."],
            r : 4,
            img:''
            ,  summary:'선행 패키지가 설치되어 있지 않으면 설치가 진행되지 않고 메시지만 출력된다.'
        },
          {// 
            q : "시스템에 센드메일 패키지가 설치되었는지 확인하는 명령어는?",
            q1 : '' ,
            a : ["rpm -qa < grep sendmail","rpm -i sendmail","dnf list --installed | grep sendmail","dnf list --available | grep sendmail"],
            r : 4,
            img:''
            ,  summary:'dnf list -- installed 는 설치되어 있는 패키지 목록을 라인별로 보여주는 명령이며, rpm -qa도 같은 기능을 수행한다.'
        },
          {// 
            q : "두 파일을 각각 압축한 후 연결하며. 압축된 하나의 파일을 만드는 명령이 필요하다. 적당하지 않은 것은?",
            q1 : '' ,
            a : ["gzip file1 file2 > bar.gz","gzip -c file1 > bar.gz;gzip 0c file2 >> bar.gz","gzip -c file1 file2 > baz.gz","cat file1 file2 | gzip > baz.gz"],
            r : 1,
            img:''
            ,  summary:'gzip -c file1 명령은 원본파일은 그대로 둔채 파일의 압축, 결과를 표준 출력으로 내보낸다. 2~4번은 두파일의 내용이 합쳐진 하나의 압축 파일을 만들고 1번은 두 원본파일을 각각 압축하여  각각.gz 파일을 만든다. 화면에 출력되는것이 없으므로 여기서 리다이렉션은 의미가 없다.'
        },
          {// 
            q : "tar 파일로 묶여있는 sensor.tar 아카이브에서 파일 목록을 보고자 할 때 사용하는 것은? ",
            q1 : '' ,
            a : ["tar cvf sensor.tar","tar xvf sensor.tar","tar tvf sensor.tar","tar rvf sensor.tar"],
            r : 3,
            img:''
            ,  summary:'2번은 아카이브에서 파일을 추출하는 명령이다.'
        },
          {// 
            q : "gzip 명령어에서 압축률을 높이기 위한 옵션은?",
            q1 : '' ,
            a : ["-h","-9","-t","-l"],
            r : 2,
            img:''
            ,  summary:'gzip 명령에서 number 옵션을 사용할 수 있는데 , 숫자 1~9는 압축률을 의미하고 9가 압축률이 가장 높으며 기본은 6이다.'
        },
          {// 11 쉘스크립트
            q : "쉘스크립트를 /bin/bah가 해석한다는 의미로, 쉘스크립트 파일의 첫 행에 지정해야하는 내용은?",
            q1 : '11장 쉘스크립트' ,
            a : ["!#/bin/bash","#!/bin/bash","$#/bin/bash","#$/bin/bash"],
            r : 2,
            img:''
            ,  summary:'#!/bin/bash는 쉘스크립트를 /bin/bash가 해석한다는 의미이다.'
        },
          {// 
            q : "다음중 쉘스크립트에서 첮번째 명령 행 인수를 뜻하는 것은?",
            q1 : '' ,
            a : ["$[1]","${1}","%[1]","%{1}"],
            r : 2,
            img:''
            ,  summary:'$1 또는 ${1}이 첫번째 명령행 인수를 의미한다. 변수 이름을 중괄호로 묶으면 뒤따라 나오는 문자를 분리할 수 있다.'
        },
          {// 
            q : "다음 쉘스크립트를 실행하였을때 출력은?",
            q1 : '' ,
            a : ["출력내용 없음","10","25","45"],
            r : 3,
            img:'unix워크북03.JPG'
            ,  summary:'반복문을 해석하면 결과적으로 a = 1 + 3 + 5 + 7 + 9이고 echo명령에 의해 쉘 변수 a의 값인 25가 출력된다.'
        },
          {// 
            q : "쉘에서 사용하는 특수 문자 중 둘러싸인 내용을 전혀 해석하지 말라는 의미를 가진 것은?",
            q1 : '' ,
            a : ["``","''","\"\"","\\\\"],
            r : 2,
            img:''
            ,  summary:'쉘은 작은따옴표로 둘러싸인 내용을 전혀 해석하지 않는다.'
        },
          {// 
            q : "다음은 쉘의 test 명령에서 파일의 상태 검사에 사용되는 연산자이다. 파일의 존재 여부를 확인하는 연산자는?",
            q1 : '' ,
            a : ["-e file","-f file","-n file","-x file"],
            r : 1,
            img:''
            ,  summary:'if 조건문의 조건 검사부분에 test -e file 또는 [ -e file ] 을 사용해 file의 존재 여부를 확인 할 수 있다. -f는 파일이 존재하며 정규파일인지를 확인한다.'
        },
          {// 
            q : "Bash 쉘에서 myScript라는 쉘스크립트를 디버깅 모드에서 실행하는 옵션은?",
            q1 : '' ,
            a : ["bash -d myScript","bash --debug myScript","bash -i myScript","bash -x myScript"],
            r : 4,
            img:''
            ,  summary:'x 옵션을 사용하면 스크립트 안의 각 명령이 실행되기 전에 화면에 표시되어 수행되는 명령을 확인할 수 있다.'
        },
          {// 
            q : "쉘에서 괄호안의 명령을 실행하여 명령의 결과값으로 치환하라는 의미를 가진 것은?",
            q1 : '' ,
            a : ["@(명령)","@{명령}","$(명령)","${명령}"],
            r : 3,
            img:''
            ,  summary:'$(명령)은 명령의 결과값으로 치환된다.'
        },
          {// 
            q : "다음과 같이 입력한 숫자에 맞춰 역삼각형을 출력하는 쉘 스크립트를 작성하라",
            q1 : '' ,
            a : ["정답포함"],
            r : 1,
            img:'unix워크북04.JPG',  
            summary:'입력받은 ㅅ 만큼 반복하되 바깥 반복문 do~done의 내부에서 다시 반복문이 필요하다 내부 반복문에서 반복횟수를 $num부터 시작하여 1만큼 줄여간다'
        },
          {// 
            q : "다음 스크립트의 기능을 설명하라",
            q1 : '' ,
            a : ["첫번째 인자 $1과 두번째 인자 $2를 정수로 가정하고,  $1~$2까지의 합을 구하여 출력한다."],
            r : 1,
            img:'unix워크북05.JPG',  
            summary:'예를들어 source myScriptsh 3 6 을 실행하면 3+4+5+6을 계산하여 18이 출력된다.'
        },
          {// 12장 
            q : "깃은 무엇인가?",
            q1 : '12장 버전관리와 깃' ,
            a : ["버전관리 시스템","프로그래밍 환경","프로그래밍 언어","공유 저장소 서버"],
            r : 1,
            img:'',  
            summary:'깃은 가장 널리 사용되는 대포적인 버전 관리 시스템의 하나이다.'
        },
          {// 
            q : "깃의 파일 상태중 '수정전(unmodified) 상태란'",
            q1 : '' ,
            a : ["파일이 생성되었지만 깃으로 관리하지 않은 파일의 상태","파일 수정작업을 커밋한 이후에 파일이 수정되지 않은 상태","파일을 생성하고 작성한 후 스테이지 영역에 올린 상태","파일을 수정하였지만 스테이지 영역에 올리지 않은 상태"],
            r : 2,
            img:'',  
            summary:'스테이지 영역에 있는 파일을 커밋한 직후에 파일은 수정 전 상태이다.'
        },
          {// 
            q : "깃 저장소의 상태를 확인하는 명령은?",
            q1 : '' ,
            a : ["git check","git status","git state","git log"],
            r : 2,
            img:'',  
            summary:'git state 명령은 작업 디렉터리에서 추적되지 않는 파일 작업 디렉터리와 인덱스간 차이가 있는 파일, 최신 커밋과 인덱스 간 차이가 있는 파일 등을 표시한다.'
        },
          {// 
            q : "깃 저장소를 만들고 초기화 하는 명령은?",
            q1 : '' ,
            a : ["git config","git rum","git init","git start"],
            r : 3,
            img:'',  
            summary:'git init [directory] 명령은 기존 디렉터리를 깃 저장소로 지정하거나 디렉터리가 존재하지 않으면 생성 후 지정하는 명령이다. 디렉터리가 생략되면 현재 디렉터리를 깃 저장소에 지정한다.'
        },
          {// 
            q : "스테이지 영역에 기록된 변경 내용을 깃 저장소에 커밋하는 명령은?",
            q1 : '' ,
            a : ["git commit","git add","git save","git snapshot"],
            r : 1,
            img:'',  
            summary:'커밋은 스테이지 영역에 등록된 변경 내용을 스냅숏으로 기록하는 것으로, 깃 저장소에 저장하여 버전으로 남기는 것이다.'
        },
          {// 
            q : "현재 디렉터리에서 모든 변경내용을 인덱스에 등록하는 명령은?",
            q1 : '' ,
            a : ["git commit","git commit --all","git push"," git add ."],
            r : 4,
            img:'',  
            summary:'수정된 파일은 커밋을 실항하기 전에 먼저 스테이지 영역에 등록되어야 한다.'
        },
          {// 
            q : "깃 저장소에 저장된 커밋 이력을 확인하는 명령으로 커밋당 한 줄의 정보만 출력하는 명령은?",
            q1 : '' ,
            a : ["git status -s","git log --short","git log --oneline","git show --oneline"],
            r : 3,
            img:'',  
            summary:'git show --oneline은 git show HEAD --oneline과 같으며, 최신 커밋의 정보를 한 줄로 출력하고 이전 커밋과 비교도 한다.'
        },
          {// 
            q : "두 커밋 사이에 저장된 파일을 비교하는 명령은?",
            q1 : '' ,
            a : ["git diff HEAD~ HEAD","git diff","git diff --staged","git diff file1 file2"],
            r : 1,
            img:'',  
            summary:'1은 직전 커밋을 기준으로 최신 커밋과 파일의 차이를 비교한다. 2는 스테이지 영역을 기준으로 작업 디렉터리와 비교하고 3은 깃 저장소를 기준으로 스테이지 영역과 비교한다.'
        },
          {// 13강
            q : "깃 저장소에 존재하는 기존 브랜치 이름을 나열하는 명령은?",
            q1 : '' ,
            a : ["git checkout","git branch","git show","git list"],
            r : 2,
            img:'',  
            summary:'git show 는 이전 커밋과 비교를 포함하여 커밋 정보를 자세히 출력한다.'
        },
          {// 
            q : "커밋 이력을 그래프로 표현해주는 명령은?",
            q1 : '' ,
            a : ["git showt --graph","git log -v","git log --graph","git log --online"],
            r : 3,
            img:'',  
            summary:'git log 명령은 현재 브랜치의 커밋 이력을 보여준다. 깃 저장소에 여러 브랜치가 존재하는 경우 git log --all --graph 명령을 사용하면 모든 브런치의 커밋 이력을 그래프로 확인할 수 있다.'
        },
          {// 
            q : "깃에서 사용하는 브랜치 개념이나 사용에 관한 설명으로 옳지 않은 것은?",
            q1 : '' ,
            a : ["브랜치는 독립적으로 수행되는 개발 작업의 흐름을 의미한다.","버그 수정이나 기능 추가 작업을 할 때 브랜치를 새로 만들어 작업한다.","저장소에 존재하는 분리 개발되는 특정 용도의 버전을 의미한다.","새로운 브랜치에서의 수정 작업은 기존 브랜치에서도 계속 영향을 준다."],
            r : 4,
            img:'',  
            summary:'브랜치는 독립적 개발 경로로 특별한 용도의 버전을 관리하기 위한 깃으로 볼 수 있다.'
        },
          {// 
            q : "이미 병합된 브랜치를 삭제하는 명령은?",
            q1 : '' ,
            a : ["git delete branchName","git checkout -d branchName","git switcht -d branchName","git branch -d branchName"],
            r : 4,
            img:'',  
            summary:'git branch 명령에서  -d 옵션은 --delete옵션과 같다'
        },
          {// 
            q : "새로운 브랜치를 생성하지만 head가 이동되지 않는 명령은?",
            q1 : '' ,
            a : ["git switch -c newBranchName","git checkout -d newBranchName","git switch --create newBranchName","git branch newBranchName"],
            r : 4,
            img:'',  
            summary:'1번과 2번은 새로운 브랜치를 생성하고 head를 이동시킴'
        },
          {// 
            q : "브런치와 커밋 이력이 다음 그림과 같다. 아래 명령에서 수행되는 병합방식은 무엇인가?",
            q1 : '' ,
            a : ["fast-forward 병합","2-way병합","3-way병합","cross 병합"],
            r : 1,
            img:'unix워크북06.JPG',  
            summary:'fast-forward 병합은 단순히 현재 브런치(master) 를 자손 브랜치(hotfix)로 이동시키는 것이다 . 자손 브랜치에 모든 커밋이력이 포함된 경우 실행이 가능하다.'
        },
          {// 
            q : "주어진 브랜치 또는 커밋으로 head를 이동시키는 명령이 아닌 것은?",
            q1 : '' ,
            a : ["git merge branch","git switch branch","git checkout commit","git checkout branch"],
            r : 1,
            img:'',  
            summary:'2~4 head가 가리키는 작업 브랜치를 다른 브랜치로 이동시키는 명령이다.'
        },
          {// 
            q : "3-way 병합에 관한 설명으로 옳지 않은 것은?",
            q1 : '' ,
            a : ["독립적 두 브랜치를 하나로 합치는 것이다.","병합이 처리될 때 새로운 커밋은 추가되지 않는다.","충돌이 발생하면 자동 병합은 실패한다.","fast-forward 병합과 마찬가지로 git merge명령을 사용한다."],
            r : 2,
            img:'',  
            summary:'3-way 병합시 병합을 의미하는 새로운 커밋이 생성된다.'
        },
          {// 14장  마지막
            q : "다른 브랜치로 이동하기 전에 변경 작업을 임시 저장하는 명령으로 옳지 않은 것은?",
            q1 : '14쟝 스테시와 버전 되돌리기' ,
            a : ["git stash","git stash save \"message\"","git stash push","git stash push \"message\""],
            r : 4,
            img:'',  
            summary:'스테시에 저장하면서 항목에 메시지를 붙이려면 보기 2 또는 git stash push -m "message"와 같이 관리해야 한다.'
        },
          {// 
            q : "스태시 명령에서 추적되지 않는 파일도 저장하는 옵션을 사용한 것은??",
            q1 : '' ,
            a : ["git stash -a"," git stash -k","git stash -u","git stash -q"],
            r : 3,
            img:'',  
            summary:'스태시 명령으로 추적되지 않는 파일을 저장하려면 -u 또는 --include untracked 옵션을 사용해야한다.'
        },
          {// 
            q : "git stash apply 명령의 기능을 정확히 설명한 것은?",
            q1 : '' ,
            a : ["스태시에서 stash@{0}을 가져와 작업영역에만 적용한다","스태시에서 stash@{0}을 가져와 스테이지 영역에만 적용한다.","스태시에서 stash@{0}을 가져와 작업영역과 스테이지 영역에 적용한다.","스태시에서 stash@{0}을 가져와 추적되지 않는 파일로 복원한다."],
            r : 1,
            img:'',  
            summary:'git stash apply 명령은 기본적으로 작업 영역만 복원하며, 스테이지 영역에 있었던 파일을 자동으로 다시 스테이지에 올라옴(staged) 상태로 만들어주지 않는다.'
        },
          {// 
            q : "스태시에 저장된 항목을 불러와 작업 영역을 복원할 때, 스테이지 영역까지 복원하는 명령어는?",
            q1 : '' ,
            a : ["git stash --index","git stash save --keep-index","git stash apply --keep-index","git stash apply --index"],
            r : 4,
            img:'',  
            summary:'2는 작업 영역을 스태시에 임시 저장하는 명령으로, 스테이지 영역은 그대로 유지하고 스테이지에 저장하지도 않는다.'
        },
          {// 
            q : "스태시 항목을 가져와 작업 영역에 적용하고 스태시 목록에서 제거하는 명령은?",
            q1 : '' ,
            a : ["git stash drop","git stash clear","git stash pop","git stash push"],
            r : 3,
            img:'',  
            summary:'git stash apply 와 git stash drop을 동시에 수행하려면 git stash pop [stash@{n}]과 같이 사용하며, 항목이 지정되지 않으면 최신 항목인 stash@{0}을 적용한다.'
        },
          {// 
            q : "git reset --hard HEAD의 기능을 바르게 설명한 것은?",
            q1 : '' ,
            a : ["마지막 커밋의 상태로 작업 영역과 스테이지 영역을 변경한다.","최신 커밋을 취소하고 그 이전 커밋으로 되돌아간다.","마지막 커밋 이후 수행했던 변경 작업을 임시 저장한다.","최신 커밋을 가리키는 HEAD를 그 이전 커밋으로 이동시킨다."],
            r : 1,
            img:'',  
            summary:'이 명령을 수행하면 작업 폴더가 깨끗한 상태가 되고, 마지막 커밋 이후에 수행했던 변경 작업이 사라지므로 주의해야 한다.'
        },
          {// 
            q : "앞에 나온 실습을 위한 예 또는 교재의 표14-12 깃 명령 실습 예에서 명령 1~7을 순서대로 실행한 직후의 작업 디렉터리, 스테이지 영역 및 깃 저장소의 상태는 다음중 어느 것인가?",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 4,
            img:'unix워크북07.JPG',  
            summary:'명령 1~6을 실행한 직후 보기 3의 상태가 되고 여기서 인덱스 등록과 커밋을 함께 실행하므로 보기 4의 상태가 된다.'
        },
          {// 
            q : "reset과 revert기능 중에서 reset기능에 관한 것은?",
            q1 : '' ,
            a : ["새로운 커밋이 생성된다.","취소된 커밋이 커밋이력에 남아 있다.","작업폴더가 깨끗한 상태라야 실행이 가능하다.","--mixed, --hard, --soft의 세가지 모드가 있다."],
            r : 4,
            img:'',  
            summary:'1,2,3은 revert에 관한 것이다.'
        },
    ]
    const test2017unix : Testtype[] = [
        {
            q : "다음중 GNU 프로젝트와 관련성이 가장 적은 것은?",
            q1 : "",
            a : ["리처드 스톨먼","GPL","Apache 서버","자유 소프트웨어 운동"],
            r : 3,
            img:'',
            summary:'GNU프로젝트로 상업적 저작권에 반대하여 공개 소프트웨어 라이센스인 GPL을 발표하였다.'
        },
        {
            q : "리눅스 표준 디렉터리의 용도에 관한 설명으로 잘못된 것은?",
            q1 : "",
            a : ["/proc - 커널이 사용하는 가상의 파일 시스템","/home - 사용자의 홈 디렉터리가 생성되는 곳","/dev -  시스템 운영 중에 생기는 가변 자료가 저장된는 곳","/etc - 시스템의 중요 환경설정 파일이 위치하는 곳"],
            r : 3,
            img:'',
            summary:''
        },
        {//38
            q : "셸의 명령 행에서 사용하는 특수 문자에 관한 설명이다. 잘못된 것은?",
            q1 : "",
            a : ["| : 특수문자 앞에 붙어 특수문자의 기능을 제거함",">> : 표준 출력을 파일의 끝에 덧붙일 때 사용함"," # : 이후의 문잗르이 주석으로 처리됨","! : 명령 히스토리 기능을 이용할 때 사용함"],
            r : 1,
            img:'',
            summary:' \\ 이게 1번의 답일듯'
        },
        {
            q : "다음 명령의 실행 결고ㅘ로 생각되는 것은? 맨앞의 $는 셸 프롬프트이며 passwd는 비밀번호를 바꿀 때 사용하는 명령이다.",
            q1 : "$ ls $(which passwd)",
            a : ["/etc/passwd","/usr/bin/passwd","which passwd","$(which passwd)"],
            r : 2,
            img:'',
            summary:''
        },
        {//40
            q : "텍스트 파일의 내용을 화면에 출력할 때 사용하는 명령이 아닌 것은?",
            q1 : "",
            a : ["cat","grep","more","less"],
            r : 2,
            img:'',
            summary:''
        },
        {
            q : "그래픽 사용자 환경과 네트워크 서비스 및 다중 사용자 환경을 지원하는 런레벨로 서 최근 리눅스 배포판에서 기본으로 설정된 런 레벨은 무엇인가?",
            q1 : "",
            a : ["3","4","5","6"],
            r : 3,
            img:'',
            summary:''
        },
        {
            q : "웹 서버 데몬인 httpd를 재시작 시키는 명령은?",
            q1 : "",
            a : ["service httpd start","service httpd restart","chkconfig httpd on","chkconfig httpd restart"],
            r : 2,
            img:'',
            summary:''
        },
        {
            q : "sudo 명령은 허가된 사용자로 하여금 관리자 명령을 수행할 수 있게 한다. 이 명령과 깊은 관련이 있는 파일은?",
            q1 : "",
            a : ["/bin/chown","/etc/mtab","/etc/passwd","/etc/sudoers"],
            r : 4,
            img:'',
            summary:''
        },
        {//44
            q : "사용자의 비밀번호 만료에 관한 정보를 변경하기 위한 관리자 명령은 무엇인가?",
            q1 : "",
            a : ["chage","useradd","passwd","userdel"],
            r : 1,
            img:'',
            summary:'sudo chage [옵션] 사용자이름   옵션 -l  사용자 비번만료정보 출력 -E 계정만료일 설정, -M 비밀번호 최대 사용기간 설정 -m 비번 최소 사용기간 설정 -W 비번 만료전에 경고기간 설정'
        },
        {
            q : "vi를 사용한 편집 작업중에 esc키를 두번 치면 어떤 모드로 이동하는가?",
            q1 : "",
            a : ["입력모드","명령모드","라인모드","검색모드"],
            r : 2,
            img:'',
            summary:''
        },
        {///46
            q : "다음 명령이 의미하는 것은?",
            q1 : "$ find /home -user kdhong -ls",
            a : ["디렉터리 /home 에서 이름이 kdhong인 파일을 찾아 출력한다","사용자 kdhong 이 실행시킨 프로세스를 찾아 상태 정보를 /home 에 저장한다","사용자 kdhong 의 홈 디렉터리에 저장된 파일의 목록을 출력한다","디렉터리 /home 에서 사용자 kdhong이 소유하고 있는 파일을 찾아 출력한다."],
            r : 4,
            img:'',
            summary:''
        },
        {
            q : "파일 시스템이나 디스크 관리를 위해 사용되는 명령의 일반적 설명으로 올바른 것은?",
            q1 : "",
            a : ["du - 저장 장치에 파티션을 생성","parted - 마운트 되어 있지 않은 파일 시스템을 검사","mkfs - 파티션이나 논리 볼륨에 파일 시스템을 생성","fdisk -  파일 시스템의 무결성을 검사하고 수정"],
            r : 3,
            img:'',
            summary:''
        },
        {
            q : "다음 명령이 의미하는 것은??",
            q1 : "$ firefox&",
            a : ["firefox를 포어그라운드 프로세스로 실행시킨다","firefox를 백그라운드 프로세스로 실행시킨다","터미널을 종료시켜도 firefox를 계속 수행하게 한다","백그라운드로 실행 중인 firefox를 포어그라운드로 전환시킨다."],
            r : 2,
            img:'',
            summary:''
        },
        {
            q : "cron서비스에 관한 설명으로 올바른 것은?",
            q1 : "",
            a : ["파일 시스템의 복구를 대비해 저널링을 수행한다.","패키지 관리를 위해 저장소 정보를 자동으로 갱신한다.","지정된 시간에 자동으로 작업을 수행하게 한다","전자서명으로 네트워크 연결을 인증한다."],
            r : 3,
            img:'',
            summary:''
        },
        {//50
            q : "RPM과 비교했을 때 YUM을 이용한 패키지 관리의 장점은 무엇인가?",
            q1 : "",
            a : ["이미 설치된 패키지의 업그레이드가 가능하다","패키지의 변형 여부를 검증할 수 있다","패키지의 설정 파일을 확인할 수 있다","패키지 의존성 문제를 해결할 수 있다."],
            r : 4,
            img:'',
            summary:''
        },
        {//51
            q : "다음 명령이 의미하는 것은?",
            q1 : "$ yum list installed",
            a : ["패키지를 설치함","설치되어  있는 패키지 목록을 출력함","패키지의 설명과 요약 정보를 출력함","패키지가 의존하는 요소와 그것을 제공하는 패키지를 나열함"],
            r : 2,
            img:'',
            summary:''
        },
        {
            q : "셸 스크립트 whoson.sh (접근권한은 755 로 가정)를 실행시키기 위한 명령으로 잘못된 것은?",
            q1 : "",
            a : ["bash -x whoson.sh","./whoson.sh","source whoson.sh","builtin whoson.sh"],
            r : 4,
            img:'unix2017.JPG',
            summary:''
        },
        {
            q : "다음 중 셸 스크립트 whoson.sh의 실행결과로 생각되는 것은?",
            q1 : "",
            a : ["Step 1 ","Step1  Step3","2017.12.10 (일) 10:45:04 KST kdhong currently logged on","Step 1 2017.12.10 (일) 10:45:04 KST  kdhong currently logged on Step3"],
            r : 4,
            img:'',
            summary:''
        },
        {
            q : "다음은 셸 스크립트의 일부이다. 밑줄 그은 부분의 의미를 바르게 설명한 것은?",
            q1 : "",
            a : ["/etc/bashrc가 존재하고 정규 파일이면 참","/etc/bashrc가 존재하고 디렉터리이면 참","/etc/bashrc가 실행 가능한 파일이면 참","/etc/bashrc가 존재하지 않으면 참"],
            r : 1,
            img:'unix201701.JPG',
            summary:'쉘 스크립트에서 -f는 파일이 존재하고 일반 파일인지를 확인할 때 사용되는 조건입니다'
        },
        {//55
            q : "네트워크 관련 명령에 관한 일반적 설명으로 잘못된 것은?",
            q1 : "",
            a : ["ping - ICMP를 이용하여 원격 호스트와의 연결 여부를 점검","netstat - DNS 서버를 이용하여 호스트의 IP주소를 확인","traceroute - 현재 호스트에서 특정 호스트까지 통신이 이루어지는 경로를 확인","ifconfig - 네트워크 인터페이스의 MAC 주소나 IP 주소 등을 확인"],
            r : 2,
            img:'',
            summary:'netstat 명령은 리눅스 및 기타 운영 체제에서 네트워크 상태를 확인하는 데 사용되는 도구입니다. 네트워크 연결, 라우팅 테이블, 네트워크 인터페이스 상태, 네트워크 프로토콜 통계 등 다양한 네트워크 정보를 보여줍니다. '
        },
        {//56
            q : "다음 중 네트워크 관련 설정 파일로 볼 수 없는 것은?",
            q1 : "",
            a : ["/etc/sysconfig/network","/etc/resolv.conf","/etc/fstab","/etc/sysconfig/network-scripts/ifcfg-eth()"],
            r : 3,
            img:'',
            summary:''
        },
        {
            q : "다음 중 암호화된 방식으로 데이터를 송수신하는 프로그램은??",
            q1 : "",
            a : ["sftp","rcp","rlogin","telnet"],
            r : 1,
            img:'',
            summary:''
        },
        {
            q : "SSH 서버를 운영하여 서비스를 제공하고자 할 때, 점검해야할 사항과 거리가 먼 것은?",
            q1 : "",
            a : ["방화벽 설정에서 해당 포트를 열어둔다","sshd 프로그램이 실행 중인지 확인한다.","웹 서버가 실행중인지 확인한다","/etc/hosts.allow 와  /etc/hosts.deny 를 확인한다"],
            r : 3,
            img:'',
            summary:''
        },
        {
            q : "Apache 웹 서버의 설정 파일인 httpd.conf 에서 다음 항목이 의미하는 것은 무엇인가?",
            q1 : "DocumentRoot     /var/www/html",
            a : ["설정 파일에서 파일이 참조될때 기준 디렉터리를 설정","웹 서버가 웹 페이지를 찾을때의 루트 디렉터리를 설정","웹 서버 관리자의 이메일 주소를 설정","웹 서버가 사용할 TCOP 포트번호를 설정"],
            r : 2,
            img:'',
            summary:''
        },
        {
            q : "간단히 웹 사이트를 구축하고자 할 때 설치해야하는 프로그램으로 보기 어려운 것은?",
            q1 : "",
            a : ["Apache 웹서버","PHP 스크립트 처리기","MySQL 데이터베이스 관리 시스템","PuTTY 클라이언트 프로그램"],
            r : 4,
            img:'',
            summary:''
        },
    ]
    const test2018unix : Testtype[] = [
        {
            q : "리눅스 커널을 포함하여 리눅스 배포판에서 사용되는 많은 소프트웨어들은 주로 어떤 라이선스를 따르고 있는가?",
            q1 : "",
            a : ["Apache","BSD","GPL","MPL"],
            r : 3,
            img:'',
            summary:'리눅수는 주로 GNU GPL (general public license)를 따르고 있다.'
        },
        {
            q : "다음 중 레드햇 계열의 리눅스 배포판이 아닌 것은?",
            q1 : "",
            a : ["CentOS","RHEL","ubuntu","fedora"],
            r : 3,
            img:'',
            summary:'Red hat 사는 RHEL을 유료화 하는 대신 무료로 배포하는 Fedora의 버그나 결함을 참조하여 RHEL을 출시하고 있다'
        },
        {
            q : "리눅스 시스템에서 표준 디렉터리의 용도에 관한 설명으로 올바른 것은?",
            q1 : "",
            a : ["/etc - 시스템의 주요 환경 설정 파일이 위치하는 디렉터리","/usr- 사용자의 홈 디렉터리가 생성되는 디렉터리","/dev - 이동식 저장장치의 마운트 지점을 제공하는 디렉터리","/var - 커널이 사용하는 가상의 파일 시스템이 위치하는 디렉터리"],
            r : 1,
            img:'',
            summary:'/etc 디렉터리에 시스템의 중요한 환경설정 파일이 위치한다'
        },
        {
            q : "셸의 명령 행에서 사용하는 특수 문자에 관한 설명으로 올바른 것은?",
            q1 : "",
            a : ["| : 특수 문자 앞에 붙어 특수문자의 기능을 제거함",">> : 명령 수행을 위해 파일의 입력이 필요할때 사용함","# : 명령을 백그라운드로 실행할때 사용함","! : 명령 히스토리 기능을 이용할때 사용함"],
            r : 4,
            img:'unix워크북.JPG',
            summary:''
        },
        {//40
            q : "셸에서 사용되는 명령이 어떻게 해석되는지 알기 위해 아래 밑줄 부분에서 사용해야 하는 명령은 무엇인가? $는 셸 프롬프트이며 cd는 셸의 내장 명령이다.",
            q1 : "",
            a : ["alias","type","whereis","man"],
            r : 2,
            img:'unix2018.JPG',
            summary:''
        },
        {
            q : "파일이냐 디렉터리냐에 따라 접근권한의 의미가 약간 다르다. 다음 중 디렉터리의 읽기 권한을 의미하는 설명은?",
            q1 : "",
            a : ["디렉터리에 존재하는 파일의 내용을 읽을 수 있다.","디렉터리에 어떤 파일과 서브 디렉터리가 있는지 목록을 볼 수 있다.","접근권한, 소유자, 크기, 수정 시간 등 디렉터리의 메타 정보를 조회할 수 있다","cd명령을 사용하여 해당 디렉터리로 이동할 수 있다."],
            r : 2,
            img:'',
            summary:''
        },
        {//42
            q : "리눅스 시스템의 런레벨(runlevel)에 관한 설명으로 잘못된 것은?",
            q1 : "",
            a : ["0 - 시스템 종료","1 -  단일 사용자 모드","3 - 네트워크 기능을 지원하는 다중 사용자 모드","5 - 시스템 재부팅"],
            r : 4,
            img:'',
            summary:'런레벨 5는 그래픽 사용자 환경을 지원하는 다중 사용자 모드이다. 재부팅에 사용되는 런레벨은 6이다'
        },
        {//43
            q : "관리자가 사용자 계정을 생성할때, 사용자 계정의 기본적 환경설정이 필요하다. 이때 사용되는 설정 파일(또는 디렉터리)이 아닌 것은?",
            q1 : "",
            a : ["/etc/skel/","/etc/login.defs","/etc/fstab","/etc/default/useradd"],
            r : 3,
            img:'',
            summary:''
        },
        {
            q : "vi를 사용한 편집 작업중에 esc 키를 두번 치면 항상 어떤 모드로 이동하는가",
            q1 : "",
            a : ["입력모드 ","명령모드","라인모드","검색모드"],
            r : 2,
            img:'',
            summary:''
        },
        {//45
            q : "다음 명령이 의미하는 것으로 적당한 것은? $는 셸프롬프트이다",
            q1 : "$ umount -a -t iso9660",
            a : ["해당유형의 모든 파일 시스템이 마운트 가능한지 점검함","/etc/inittab에 나열된 해당 유형의 모든 파일 시스템을 점검한 후 마운트 함","/etc/fstab에 나열된 해당 유형의 파일 시스템을 모두 언마운트함","/etc/fstab에 나열된 모든 파일시스템을 언마운트함"],
            r : 3,
            img:'',
            summary:''
        },
        {
            q : "볼륨 관리에서 사용되는 용어의 설명이다. 잘못된 것은?",
            q1 : "",
            a : ["물리볼륨 (pv) - 하나의 물리적 디스크를 말함","볼륨그룹(vg) - 여러 물리볼륨을 하나로 묶은 것으로 가상의 하드디스크로 생각할 수 있음","논리볼륨(lv) - 볼륨 그룹에서 가용 공간을 분할한 것으로 기존 파티션과 개념적으로 일치함","물리 익스텐드(pe) - 하나의 표준 블록 디바이스로 표현되며 마운트 작업과 파일시스템 검사의 단위가 됨"],
            r : 4,
            img:'',
            summary:''
        },
        {//47
            q : "파일 시스템 유형에 관한 설명으로 잘못된 것은?",
            q1 : "",
            a : ["XFS - 리눅스 차세대 파일 시스템으로 여러 서버에서 동시 마운트와 동시 접근이 가능한 공유파일 시스템이다.","ext2 - 저널링을 지원하지 않으며 100mb 이하의 작은 파티션에 사용하는 것이 좋다","ext4 -  레드햇 계열 리눅스의 기본 파일 시스템으로 범용이며 특별한 이유가 없다면 이것을 사용하면 된다.","vfat - 윈도우 운영체제와 호환되는 파일 시스템으로 USB 에서 주로 사용된다."],
            r : 1,
            img:'',
            summary:''
        },
        {
            q : "다음 명령의 결과를 정확히 설명한 것은? $는 셸 프롬프트이다",
            q1 : "$ ps",
            a : ["현재 터미널과 연결되어 있는 프로세스 중 EUID가 현재 사용자의 UID와 같은 프로세스를 보여준다.","터미널을 종료해도 현재 실행중인 프로그램이 종료되지 않고 계속 수행되게 한다.","현재 사용자가 소유한 모든 프로세스를 출력한다. 데몬프로세스처럼 터미널과 연결되어 있지 않은 프로세스도 출력한다.","모든 사용자의 모든 프로세스를 자세히 보여준다."],
            r : 1,
            img:'',
            summary:''
        },
        {
            q : "특정 작업을 주기적으로 실행시키는 cron 서비스에 관한 설명이다. 잘못된 것은?",
            q1 : "",
            a : ["crond 데몬 프로그램이 1분 간격으로 설정파일을 검사하여 수행한다.","관리자가 시스템 수준의 설정 파일을 수정할때 vi편집기로 편집할 수 없으며 반드시 crontab 명령을 사용해야 한다.","시스템 수준에서 /etc/crontab 파일과 /etc/cron.d/ 디렉터리에 존재하는 파일이 cron 서비스의 작업 설정 파일이다.","일반 사용자도 자신만의 cron 작업을 등록하거나 수정할 수 있다."],
            r : 2,
            img:'',
            summary:''
        },
        {//50
            q : "다음 명령은 /usr/bin/passwd 파일의 자세한 정보를 보여준다. 이 파일에 적용된 특수권한과 관련된 설명 중 잘못된 것은? $는 셸 프롬프트이다.",
            q1 : "",
            a : ["passwd 파일에 특수 권한인 SetUID가 설정되어 있다.","일반 사용자가 passwd 명령을 실행할 때 root 권한으로 실행된다.","일반 사용자 계정으로도 /usr/bin/passwd파일을 vi 편집기로 직접 수정할 수 있다.","일반 사용자가 passwd 명령을 사용하여 암호를 수정할 때, 암호가 저장된 /etc/shadow 파일의 수정이 가능하다."],
            r : 3,
            img:'unix201801.JPG',
            summary:''
        },
        {
            q : "다음은 RPM 패키지 관리에 대한 설명이다. 잘못된 것은?",
            q1 : "",
            a : ["RPM은 레드햇 계열 리눅스에서 패키지 파일의 표준 형식이다","RPM은 RPM 패키지 관리 프로그램(Rpm Package Manager)을 의미한다","rpm 명령을 사용하여 신규로 패키지를 설치하거나 기존 패키지를 업그레이드 할 수 있다.","rpm 명령을 사용하면 설치하고자 하는 패키지의 '선행 패키지'가 필요할때 자동으로 찾아 설치해 준다."],
            r : 4,
            img:'',
            summary:''
        },
        {
            q : "yum 명령의 사용법을 설명한 것이다. 잘못된 것은?",
            q1 : "",
            a : ["yum list installed [패키지명] - 패키지를 설치","yun info [패키지명] - 패키지의 설명과 요약 정보를 출력","yum remove 패키지명 - 패키지를 삭제","yum history - 패키지 설치 이력을 확인"],
            r : 1,
            img:'',
            summary:''
        },
        {//53
            q : "두 파일을 압축하고 연결시켜 하나의 압축파일 (bar.gz)을 만드는 명령으로 적당하지 않은 것은 무엇인가? gzip 명령의 -c 옵션은 결과를 표준 출력으로 내보낸다.",
            q1 : "",
            a : ["cat file1 file2 | gzip > bar.gz","gzip -c file1 > bar.gz; gzip -c file2 >> bar.gz","gzip -c file1 file2 > bar.gz","gzip file1 file2 > bar.gz"],
            r : 4,
            img:'',
            summary:''
        },
        {
            q : "Apache 웹 서버의 설정 파일인 httpd.conf 에서 다음 항목이 의미하는 것은 무엇인가?",
            q1 : "Listen 80  Listen 8080",
            a : ["클라이언트가 보낼 수 있는 최대 요청 수를 설정","웹 서버가 사용할 TCP 포트 번호를 설정","유휴 자식 서버 프로세스 수의 최대값을 설정","동시에 접속 가능한 클라이언트 수의 최대값을 설정"],
            r : 2,
            img:'',
            summary:''
        },
        {//55
            q : "실행 중인 Apache 웹 서버의 설정을 변경한 후에는 프로그램을 다시 시작해야 효력이 발생한다. 이때 적당한 명령을 보기에서 찾으면 무엇인가?",
            q1 : "",
            a : ["chkconfig httpd on","chkconfig --list sshd","service sshd restart","service httpd restart"],
            r : 4,
            img:'',
            summary:''
        },
        {
            q : "2개의 인수가 제공되었는지 확인하기 위해 밑줄 친 ㄱ 에 들어갈 내용으로 적당한 것은?",
            q1 : "",
            a : ["test $* -ne 2;","test $# -eq 2;","[$# -ne 2];","[$# -eq 2];"],
            r : 3,
            img:'unix201802.JPG',
            summary:'$# 에 2개의 인수가 제공되었는지 확인하려면 서로 같지 않아야하기 때문에 -ne가 맞다. -eq는 같을때 ..'
        },
        {
            q : "두 정서의 합을 출력하기 위해 밑줄 친 ㄴ 에 들어갈 내용으로 적당한 것은?",
            q1 : "",
            a : ["\"$1 + $2는 ($1+$2)입니다.\"","\"$1 + $2는 $($1+$2)입니다.\"","'$1 + $2는 $[$1+$2]입니다.'",'\"$1 + $2는 $[$1+$2]입니다.\"'],
            r : 4,
            img:'',
            summary:''
        },
        {//58
            q : "셸 스크립트를 실행하기 위해 밑줄 친 ㄷ 에 들어갈 명령으로 적당한 것은?",
            q1 : "",
            a : ["./intCompare.sh 36 68","script inCompare.sh 36 68","./intCompare 36 68","intCompare 36 68"],
            r : 1,
            img:'',
            summary:''
        },
        {
            q : "네트워크 점검 명령에 관한 일반적 설명으로 잘못된 것은?",
            q1 : "",
            a : ["ifconfig - 네트워크 인터페이스 정보를 확인하거나 설정","nslookup - 네트워크 연결 상태와 사용 현황을 확인","traceroute - 특정 호스트까지 패킷의 통신경로를 확인","route - IP 라우팅 테이블의 설정 또는 확인"],
            r : 2,
            img:'',
            summary:'nslookup 명령은 리눅스와 기타 운영 체제에서 DNS(Domain Name System) 조회를 위해 사용됩니다. nslookup naver.com 입력시 네이버 사이트의 ip 주소를 반환한다.'
        },
        {
            q : "보호된 원격 로그인이나 원격 데이터 통신에 사용되는 프로토콜로서 전자서명으로 연결을 인증하고 패킷을 암호화하여 전송하는 방식은?",
            q1 : "",
            a : ["Telnet","FTP","SSH","SCP"],
            r : 3,
            img:'',
            summary:''
        },
    ]
    const test2019unix : Testtype[] = [
        {
            q : "CentOS 리눅스에서 기본으로 주어지는 쉘의 종류는 무엇인가?",
            q1 : "",
            a : ["Bourne Shell(sh)","Bourne Again Shell(bash)","C Shell(csh)","Korn Shell(ksh)"],
            r : 2,
            img:'',
            summary:''
        },
        {
            q : "셸 프롬프트에서 사용된 명령을 해석할 때 명령의 종류에 해당하지 않는 것은?",
            q1 : "",
            a : ["셸 예약어","셸에서 정의되어 있는 함수 이름","실행 파일이 존재하는 일반 명령","설치되어있는 패키지의 이름"],
            r : 4,
            img:'',
            summary:''
        },
        {
            q : "리눅스 시스템에서 표준 디렉터리의 용도에 관한 설명으로 잘못된 것은?",
            q1 : "",
            a : ["/etc - 시스템의 주요 환경설정파일이 위치하는 디렉터리","/home - 사용자의 홈 디렉터리가 생성되는 디렉터리","/dev - 시스템 운영 중에 생기는 가변 자료가 저장되는 곳","/proc - 커널이 사용하는 가상의 파일 시스템"],
            r : 3,
            img:'',
            summary:''
        },
        {//39
            q : "셸의 명령행에서 사용하는 특수 문자에 관한 설명으로 잘못된 것은?",
            q1 : "",
            a : ["| - 앞 명령의 출력을 다음 명령의 입력으로 연결시킴",">> - 명령의 수행을 위해 파일로부터 입력이 필요할 때 사용함","; - 여러 명령을 순서대로 실행할때 구분을 위해 사용함","! - 명령히스토리 기능을 이용할 때 사용함"],
            r : 2,
            img:'',
            summary:''
        },
        {
            q : "리눅스 명령에 관한 설명이다. 잘못된 것은?",
            q1 : "",
            a : ["type - 텍스트 파일의 내용을 화면에 출력하는 명령","file - 파일의 종류를 알려주는 명령","unmask - 파일 접근권한의 기본 값을 출력하거나 설정하는 명령","ln - 하드 링크나 심볼릭 링크를 만드는 명령"],
            r : 1,
            img:'',
            summary:''
        },
        {
            q : "cd 명령으로 특정 디렉토리로 이동하여 해당 디렉터리에 존재하는 파일의 목록을 ls명령으로 확인하고자 한다. 이 디렉터리에 어떤 권한을 가지고 있어야 가능한가?",
            q1 : "",
            a : ["읽기 권한만 가지고 있어도 가능하다","적어도 읽기와 쓰기 권한을 가지고 있어야 한다","적어도 읽기와 실행권한을 가지고 있어야 한다","반드시 읽기 쓰기 실행권한을 모두 가지고 있어야 한다"],
            r : 3,
            img:'',
            summary:''
        },
        {
            q : "다음 중 관리자가 아닌 일반 사용자도 수행할 수 있는 명령은 무엇인가?",
            q1 : "",
            a : ["useradd","usermod","shutdown","passwd"],
            r : 4,
            img:'',
            summary:''
        },
        {//43
            q : "사용자가 단지 자신의 암호만 아는 상황에서도 sudo 명령을 사용하면 해당 사용자에게 허용된 특별한 명령을 수행할 수 있다. 단 관리자가 '누가 어디서 어떤 명령을 할 수 있는가' 를 설정해야 한다 . 어느 파일에 설정하는가",
            q1 : "",
            a : ["/etc/login.defs","/etc/sudoers","/etc/shodow","/etc/libuser.conf"],
            r : 2,
            img:'',
            summary:''
        },
        {//44
            q : "vl 편집기가 명령 모드에 있을 때, 파일 전체를 대상으로 문자열 패턴을 검색하는 명령키는?",
            q1 : "",
            a : [":pattern(enter)","?pattern(enter)","!pattern(enter)","/pattern(enter)"],
            r : 4,
            img:'',
            summary:''
        },
        {//45
            q : "find 명령의 사용에 관한 설명이다. 잘못된 것은?",
            q1 : "",
            a : ["사용자 홈 디렉터리에서 단순히 find 명령을 실행하면 현재 디렉터리와 서브 디렉터리에 있는 모든 파일과 디렉터리의 이름을 라인 단위로 출력한다","find /etc -name passwd 는 파일의 이름이 문자열 pass 로 시작하는 모든 파일을 /etc에서 찾아 출력한다","find ~ | wc -1은 사용자가 가지고 있는 파일의 총 개수를 출력한다","지정된 디렉터리에 읽기와 실행 권한이 없으면 find 명령은 파일을 검색하지 못한다."],
            r : 2,
            img:'',
            summary:''
        },
        {//46
            q : "보기는 파일 시스템 관리와 관련이 있는 설명이다. 잘못된 것은? ",
            q1 : "",
            a : ["마운트는 파일 시스템을 특정 디렉터리에 붙여서 사용할 수 있게 하는 것이다.","부팅시 자동으로 마운트 되는 파일 시스템이 /etc/fstab 파일에 기록되어 있다.","inode는 파일의 이름을 포함하여 해당 파일의 모든 정보를 가지고 있다","논리 볼륨은 개념적으로 파티션과 일치하나 크기를 조정할 수 있다."],
            r : 3,
            img:'',
            summary:''
        },
        {//47
            q : "보기는 파일 시스템 또는 디스크 관리를 위해 사용되는 명령(또는 도구)에 관한 설명이다. 잘못된 것은?",
            q1 : "",
            a : ["fdisk - 하드 디스크 파티션을 관리하는 대화식 유틸리티","fsck - 사용자의 디스크 사용량을 관리하는 명령","mkfs - 파티션이나 논리 볼륨에 파일 시스템을 만드는 명령","LVM - 물리 볼륨/ 논리 볼륨/ 볼륨 그룹을 관리하기 위한 도구"],
            r : 2,
            img:'',
            summary:''
        },
        {//48
            q : "백그라운드 프로세스의 실행에 관한 설명이다 잘못된 것은?",
            q1 : "",
            a : ["셸 프롬프트에서 명령의 끝에 & 를 추가하여 실행하면 백그라운드 프로세스로 실행된다","입력을 요구하지 않고 장시간 실행되어야 하는 경우에 백그라운드 프로세스로 실행시킨느것이 좋다","백그라운드 프로세스는 터미널 출력은 가능하나 키보드 입력을 받을 수 없다","터미널 창을 종료하더라도 백그라운드 프로세스는 종료되지 않는다."],
            r : 4,
            img:'',
            summary:''
        },
        {//49
            q : "프로세스 관리를 위한 명령이 아닌 것은?",
            q1 : "",
            a : ["rpm","ps","top","nice와 renice"],
            r : 1,
            img:'',
            summary:''
        },
        {//50
            q : "다음 명령의 의미는 무엇인가?",
            q1 : "$ yum list installed | grep sendmail",
            a : ["sendmail 패키지가 설치되어있는지 확인한다.","sendmail 패키지가 설치가 가능한지 확인한다","sendmail 이 의존하고 있는 다른 패키지 목록을 나열한다","sendmail 패키지를 설치하고 요약 정보를 출력한다."],
            r : 1,
            img:'',
            summary:''
        },
        {//51 ???
            q : "다음 명령의 의미는 무엇인가?",
            q1 : "$ tar cvf bar.tar backup/",
            a : ["디렉터리 backup에 있는 파일들을 기존 아카이브 bar.tar의 끝에 추가함","아카이브 bar.tar에 있는 파일 목록과 디렉터리 backup에 있는 파일 목록을 함께 출력함","아카이브 bar.tar에 있는 파일들을 디렉터리 backup에 풀어줌","디렉터리 backup에 있는 파일들을 묶어 새로운 아카이브 bar.tar를 만듦"],
            r : 4,
            img:'',
            summary:`명령은 tar 명령어를 사용하여 backup/ 디렉터리를 bar.tar라는 이름의 tar 파일로 묶는 작업을 수행합니다. 각 부분의 의미는 다음과 같습니다:
            $ tar: tar 명령어는 파일을 묶거나 압축을 해제할 때 사용됩니다.
c: create의 약자로, 새로운 tar 파일을 생성합니다.
v: verbose의 약자로, 실행 중인 작업의 세부 사항을 화면에 출력하여 진행 상황을 보여줍니다.
f: file의 약자로, 결과를 지정한 파일에 저장합니다. 이 옵션 뒤에 나오는 bar.tar가 해당 파일의 이름이 됩니다.
bar.tar: 생성할 tar 파일의 이름입니다.
backup/: tar 파일로 묶을 대상 디렉터리입니다.
            `
        },
        {
            q : "조건 검사를 위해 밑줄 친 ㄱ에 들어가야 할 내용은?",
            q1 : "",
            a : ["test $N -ne 10;","test $N -gt 10;","[$N -le 10]","[$N <= 10 ];"],
            r : 3,
            img:'unix2019.JPG',
            summary:''
        },
        {//53
            q : "합을 계산하기 위한 수식으로 밑줄 친 ㄴ 에 들어가야할 내용은?",
            q1 : "",
            a : ["$($S+$N)","$[S+N]","$[$S+N]","$[$S+$N]"],
            r : 4,
            img:'',
            summary:''
        },
        {//54
            q : "셸스크립트를 실행하기 위해 밑줄 친 ㄷ 에 들어갈 명령으로 적당하지 않은 것은?",
            q1 : "",
            a : [". testWhile.sh","script testWhile.sh","./testWhile.sh","bash testWhile.sh"],
            r : 2,
            img:'',
            summary:''
        },
        {//55
            q : "네트워크 명령에 관한 일반적 설명으로 잘못된 것은?",
            q1 : "",
            a : ["traceroute - 현재 호스트에서 특정 호스트까지 통신이 이루어진 경로를 확인한다.","ping -DNS를 이용하여 호스트의 IP주소를 확인한다","route - IP라우팅 테이블을 설정하거나 확인한다.","netstat - 네트워크 연결 상태, 라우팅 테이블, 네트워크 인터 페이스 통계 등을 확인한다."],
            r : 2,
            img:'',
            summary:''
        },
        {//56
            q : "ifconfig 명령의 기능은?",
            q1 : "",
            a : ["현재 시스템의 TCP/IP 서비스를 이용할 수 있는(혹은 없는) 호스트를 설정한다","ICMP를 이용하여 원격 호스트와 연결 여부를 점검한다.","네트워크 인터페이스 정보를 확인하거나 설정한다.","리스닝 중이거나 연결된 소켓에 대한 정보를 확인한다."],
            r : 3,
            img:'',
            summary:''
        },
        {//57
            q : "시스템을 부팅할때 자동으로 SSH 데몬을 시작하도록 설정하는 명령으로 올바른 것은?",
            q1 : "",
            a : ["chkconfig --list sshd","chkconfig sshd on","service sshd start","service sshd enable"],
            r : 2,
            img:'',
            summary:''
        },
        {//58
            q : "원격 관리 또는 원격 접속을 위한 다음 명령 중 SSH 프로토콜을 사용하지 않아 보안에 취약한 것은?",
            q1 : "",
            a : ["rcp","ssh","sftp","scp"],
            r : 1,
            img:'',
            summary:''
        },
        {//
            q : "아파치 웹 서버의 설정 파일에서 클라이언트가 '.../디렉터리/'와 같이 디렉터리를 요청하는 경우에 기본으로 사용할 웹 페이지의 파일 이름을 설정하는 항목은?",
            q1 : "",
            a : ["ServerRoot","LoadModule","DocumentRoot","DirectoryIndex"],
            r : 4,
            img:'',
            summary:''
        },
        {//
            q : "설정을 변경한 후에 아파치 웹 서버를 다시 시작하는 명령으로 적당한 것은?",
            q1 : "",
            a : ["service httpd status","service httpd restart","chkconfig httpd on","systemctl restart mysqld.service"],
            r : 2,
            img:'',
            summary:''
        },
    ]
    const testsimul2017 :Testtype[] =[
        {//
            q : "다음은 시뮬레이션 모델에 대한 설명이다 보기에서 설명과 이름을 바르게 연결한 것은?",
            q1 : '' ,
            a : ["가-A 나-B 다-C 라 -D","가-A 나-C 다-B 라-D","가-D 나-A 다-C 라-B","가-D 나-B 다-C 라-A"],
            r : 4,
            img:'simul2017.JPG',
            summary:``
        },
        {//
            q : "다음 시뮬레이션 모델에서 확률변수를 사용하지 않는 것은?",
            q1 : '' ,
            a : ["이산형 모델","확률적 모델","결정적 모델","동적 모델"],
            r : 3,
            img:'',
            summary:``
        },
        {//
            q : "토끼와 여우의 관계처럼 천적과 먹이 관계인 두 종족간의 상호작용으로 인한 종족수를 예측해 보는 모델은?",
            q1 : '' ,
            a : ["prey-predator 모델","Vy(t+t_ = Vy(t)+ay*t","저축문제 2","몬테칼로 시뮬레이션"],
            r : 1,
            img:'',
            summary:``
        },
        {//
            q : "다음중 확률적 시뮬레이션에 해당되는 것은?>",
            q1 : '' ,
            a : ["저축문자 1 ","대기행렬문제","공의 탄성문제","population 모델"],
            r : 2,
            img:'',
            summary:``
        },
        {//40
            q : "다음은 시뮬레이션의 특징들이다 잘못 설명된 것은?",
            q1 : '' ,
            a : ["시뮬레이션 모델은 개발 상 많은 비용과시간을 요한다","시뮬레이션에 의해 산출되는 많은 양의 수치들은 연구 결과에 대하여 과잉의 신뢰를 주는 경향이 있다","확률적 시뮬레이션 모델은 정확한 값을 요구하는 시스템 최적화 등에 적합하다","실시스템 실질적인 구축 없이도 평가할 수 있다."],
            r : 3,
            img:'',
            summary:``
        },
        {//41
            q : "일반적인 시뮬레이션 과정 순서가 올바른 것은?",
            q1 : '' ,
            a : ["문제의 정의 -> 모델설계-> 자료수집 -> 모델변환 ->검증 -> 실험","모델설계 ->모델변환 -> 문제의 정의 -> 자료수집 ->검증 ->실험","자료수집 -> 문제의 정의 ->모델설계 ->모델변환 ->검증 ->실험","문제의 정의 ->모델설계 ->모델변환 -> 자료수집- >검증->실험"],
            r : 1,
            img:'',
            summary:``
        },
        {//
            q : "난수의 초기값을 나타내는 변수는?",
            q1 : '' ,
            a : ["tstep","prarr","seed","mean"],
            r : 3,
            img:'simul201701.JPG',
            summary:``
        },
        {//
            q : "고객의 도착 비율을 나타내는 변수는",
            q1 : '' ,
            a : ["tstep","prarr","seed","mean"],
            r : 2,
            img:'',
            summary:``
        },
        {//44
            q : "지금까지 도착한 총 고객의 수를 표현하는 것은?",
            q1 : '' ,
            a : ["queue","totque","totarr","tpump"],
            r : 3,
            img:'',
            summary:``
        },
        {//45
            q : "고객의 봉사시간을 표현하는 것은?",
            q1 : '' ,
            a : ["queue","totque","totarr","tpump"],
            r : 4,
            img:'',
            summary:``
        },
        {//46
            q : "평균 대기행렬의 길이를 구하는 공식으로 빈칸 '가'에 적당한 것은?",
            q1 : '' ,
            a : ["totque/ totarr","totque / arrive","totque /queue","totque / (limit / tstep)"],
            r : 4,
            img:'',
            summary:``
        },
        {//
            q : "평균 대기시간을 구하는 공식으로 빈칸 '나'에 적당한 것은",
            q1 : '' ,
            a : ["totque/ totarr","totque / arrive","totque /queue","totque / (limit / tstep)"],
            r : 1,
            img:'',
            summary:``
        },
        {//
            q : "봉사창구를 2개로 늘리려고 한다 . 다음중 직접 관련되어 알고리즘에서 수정되는 변수는?",
            q1 : '' ,
            a : ["queue","totque","tpump","totarr"],
            r : 3,
            img:'',
            summary:``
        },
        {// 49
            q : "빈칸 가에 알맞은 것은?",
            q1 : '' ,
            a : ["call random(nseed, nmean, U)","call random(nseed, nmean, stdev, liters)","call normal(nseed, nmean, stdev, liters)","call normal(nseed, prarr, stdev, liters)"],
            r : 3,
            img:'simul201702.JPG',
            summary:``
        },
        {//50 
            q : "봉사시간을 나타내는 것은?",
            q1 : '' ,
            a : ["liters","queue","tpump","aveque"],
            r : 3,
            img:'',
            summary:``
        },
        {//51
            q : "빈칸의 도착간격을 구하면?",
            q1 : '' ,
            a : ["1,2,2","2,3,2","3,3,3","9,11,15"],
            r : 2,
            img:'simul201703.JPG',
            summary:``
        },
        {//
            q : "빈칸의 출발시간을 구하면?",
            q1 : '' ,
            a : ["1,2,2","2,3,2","3,3,3","9,11,15"],
            r : 4,
            img:'',
            summary:``
        },
        {//53
            q : "빈칸의 대기시간을 구하면?",
            q1 : '' ,
            a : ["1,2,2","2,3,2","3,3,3,","8,10,14"],
            r : 3,
            img:'',
            summary:``
        },
        {//
            q : "도착사건과 출발사건이 동시에 일어나는 시간은?",
            q1 : '' ,
            a : ["1","3","6","8"],
            r : 3,
            img:'',
            summary:``
        },
        {//55
            q : "다음 이산형 시뮬레이션에 대한 설명 중 틀린 것은?",
            q1 : '' ,
            a : ["종족변수에서의 이산적 변화가 어떤 시간에도 일어날 수 있으면 이산형 모델이 되고, 명시된 순간에만 일어날 수 있으면 연속형 모델이 된다","시뮬레이션 시간에서 종속변수가 사건발생 시간이라고 불리는 특정한 시간에 이산적으로 변화할 경우에 해당한다. 이경우 모델에서 시간벼수는 연속적일 수도 있고 이산적일 수도 있다.","대기행렬 시스템은 이산형 시뮬레이션에 해당된다. 이 예에서 종속변수는 대기행렬 내의 고객수가 된다. 사건발생시간은 시스템에 고객이 도착하는 시간과 떠나는 시간이 된다","일반적으로 이산형 모델의 종속변수의 값은 사건발생시간 사이에는 변하지 않는다."],
            r : 1,
            img:'',
            summary:``
        },
        {//56
            q : "다음 중 연속형 시뮬레이션 모델링인 경우는?",
            q1 : '' ,
            a : ["대기행렬 시스템","미분 방정식처럼 모델이 상태함수들의 도함수로 표시된다","호수에 화학약품을 살포하는 경우 호수에 서식하는 특수한 종류의 수가 순간적으로 감소할 수 있다","우주선이 결합을 완료하면 우주선의 비행을 시뮬레이션 하는 방정식은 결합전의 방정식과는 다르게 바뀌어야 한다."],
            r : 2,
            img:'',
            summary:``
        },
        {//57
            q : "다음 중 가변시간 진행법과 관계없는 것은?",
            q1 : '' ,
            a : ["사건이 발생하면 시간을 진행시킨다.","시뮬레이션 증가시간이 일정하지 않다.","고정시간 진행법과 반대되는 개념이다","최종 시뮬레이션 시간은 고정된다."],
            r : 4,
            img:'',
            summary:``
        },
        {//
            q : "종료조건으로 처리를 해야 할 총 고객수는?",
            q1 : '' ,
            a : ["totarr","timing",'next',"nseed"],
            r : 1,
            img:'simul201704.JPG',
            summary:``
        },
        {//59
            q : "빈칸 가에 알맞은 것은?",
            q1 : '' ,
            a : ["call expon(seed, marrvt, e_arr)","call expon(seed, mservt, e_arr)","call expon(seed, marrvt, tne[1])","call expon(seed, mservt, tne[1])"],
            r : 1,
            img:'',
            summary:``
        },
        {//60
            q : "빈칸 나에 알맞은 것은?",
            q1 : '' ,
            a : ["call expon(nseed, marrvt , tne[2])",'call expon(nseed, mservt, tne[2])',"call expon(nseed, marrvt, e_dep)","call expon(nseed, mservt, e_dep)"],
            r : 4,
            img:'',
            summary:``
        },
        {//61
            q : "다음 중 시뮬레이션 전용언어가 아닌 것은?",
            q1 : '' ,
            a : ["AweSim","ProModel","AutoMod","Visual C++"],
            r : 4,
            img:'',
            summary:``
        },
        {//
            q : "다음은 시뮬레이션 언어에 대한 설명이다. 틀린 것은?",
            q1 : '' ,
            a : ["시뮬레이션 모델을 설계하기 위한 일반화된 구조를 제시한다.","시뮬레이션 모델을 다시 컴퓨터 프로그램으로 바꾸는 신속한 기능을 제시한다","시뮬레이션 모델의 변경이 용이하고 이와 같은 변경이 프로그램으로 즉시 적용될 수 있게 한다","산출되는 출력보고서의 형태를 자유롭게 작성할 수 있다."],
            r : 4,
            img:'',
            summary:``
        },
        {//
            q : "컴퓨터를 이용하여 난수를 발생하는 경우 갖추어야 할 점이 아닌 것은?",
            q1 : '' ,
            a : ["반복발생이 불가능해야 한다.","상관관계가 없어야 한다","난수의 발생속도가 빨라야 한다.","[0,1) 범위에어 일양분포를 만족해야 한다."],
            r : 1,
            img:'',
            summary:``
        },
        {//64
            q : "X0=5 일때 x1을 구하면?",
            q1 : '' ,
            a : ["3","5","6","9"],
            r : 1,
            img:'simul201705.JPG',
            summary:`2*5 + 3 (mod 10) = 13 (mod 10) = 3`
        },
        {//65
            q : "계속해서 X2를 구하면?",
            q1 : '' ,
            a : ["3","5","6","9"],
            r : 4,
            img:'',
            summary:``
        },
        {// 66
            q : "주기는?",
            q1 : '' ,
            a : ["3","4","5","6"],
            r : 2,
            img:'',
            summary:`x0 = 5  x1 = 3 x2 = 9  x3 = 1  x4 = 5  동일한 값이 나오기 까지 0 1 2 3 => 4회가 주기임`
        },
        {//67
            q : "자유도는?",
            q1 : '' ,
            a : ["99","100","101","102"],
            r : 1,
            img:'simul201706.JPG',
            summary:``
        },
        {//
            q : "구간별 기대값인 n/k 의 값은?",
            q1 : '' ,
            a : ["30","40","50","60"],
            r : 4,
            img:'',
            summary:``
        },
        {//69
            q : "다음은 지수 확률변수를 발생시키는 과정이다. 역함수를 이용하는  이 방법의 이름은?",
            q1 : '' ,
            a : ["역변환법","합성법","결합법","채택기각법"],
            r : 1,
            img:'simul201707.JPG',
            summary:``
        },
        {//
            q : "다음은 시뮬레이션의 응용사례들이다. 시뮬레이션 목적이 나머지 셋과 가장 다른 것은?",
            q1 : '' ,
            a : ["일기예보","자동차 드라이빙 시뮬레이터","원자력 발전소 시뮬레이터","파일러트(조종사) 시뮬레이션"],
            r : 1,
            img:'',
            summary:``
        },
    ]
    const testsimul2018 :Testtype[] =[
        {//
            q : "다음은 시뮬레이션 모델의 이용 범주에 대한 설명이다. 틀린 것은?.",
            q1 : '' ,
            a : ["시스템이나  문제를 정의하고 이해를 주는 설명적 기능","미래의 개발 계획을 예측하고 도와주는 예측적인 도구","실 시스템을 수리적인 공식으로 표현하는 해석적 기능","제안된 해결방안을 종합하고 평가하는 설계평가 도구"],
            r : 3,
            img:'',
            summary:``
        },
        {//
            q : "다음은 시스템에 대한 설명이다 . 설명이 틀린 것은?",
            q1 : '' ,
            a : ["관심의 대상이 되는 실세계의 부분집합","어느 목적을 위하여 하나 이상 서로 관련 있는 구성요소가 결합된 것","특별한 대상들의 집합은 하위 시스템이 될 수 있다.","모든 외적요인들은 함수식으로 명시된다."],
            r : 4,
            img:'',
            summary:``
        },
        {//
            q : "다음은 시스템 모델링이 어려운 경우에 대한 설명이다 .괄호 안에 들어갈 내용을 올바르게 나열한 것은?",
            q1 : '' ,
            a : ["의사결정, 랜덤한, 기본규칙, 정량화","기본규칙, 정량화, 의사결정, 랜덤화","기본규칙, 의사결정, 랜덤규칙, 정량화","의사결정, 정량화 된 , 기본규칙, 랜덤화"],
            r : 1,
            img:'simul2018.JPG',
            summary:``
        },
        {// 39
            q : "시뮬레이션 모델을 분류하는 방법은 여러 형태가 있다. 다음중 상태변수가 확률변수를 사용하는지의 여부에 따라 분류하는 방법은?",
            q1 : '' ,
            a : ["결정적 모델과 확률적 모델","정적모델과 동적 모델","이산모델과 연속 모델","물리적 모델과 수리적 모델"],
            r : 1,
            img:'',
            summary:``
        },
        {//40
            q : "다음 중 발생시킨 2차원 난수의 개수로 값이 50,000 인 변수는?",
            q1 : '' ,
            a : ["U","limit","count","s"],
            r : 2,
            img:'simul201801.JPG',
            summary:``
        },
        {//
            q : "다음 중 알고리즘에서 A의 면적을 나타내는 것은?",
            q1 : '' ,
            a : ["가","나","다","라"],
            r : 3,
            img:'',
            summary:``
        },
        {//42
            q : "다음 중 시뮬레이션의 장점은?",
            q1 : '' ,
            a : ["시뮬레이션 모델은 개발 상 많은 비용과 시간을 요한다","시뮬레이션에 의해 산출되는 많은 양의 수치들은 연구 결과에 대하여 과잉의 신뢰를 주는 경향이 있다.","확률적 시뮬레이션 모델은 정확한 값을 요구하는 시스템 최적화 등에 부적합하다","실시스템의 실질적인 구축 없이도 시뮬레이션을 이용하여 예측 평가할 수 있다."],
            r : 4,
            img:'',
            summary:``
        },
        {//
            q : "다음은 시뮬레이션 과정에 대한 설명이다 . 틀린 것은?",
            q1 : '' ,
            a : ["문제의 정의 : 시스템을 수학적이고 논리적인 관계로 추상화 한다","모델변환 :  컴퓨터에서 처리에 적절하게 모델을 준비함","타당성 : 시뮬레이션 모델이 실시스템을 정확히 표현했는지 일치하는지를 분석하는 단계","검증 :  모델이 의도한 대로 컴퓨터 프로그램이 수행될 수 있도록 준비함"],
            r : 1,
            img:'',
            summary:``
        },
        {//
            q : "다음중 prarr의 초기값은?",
            q1 : '' ,
            a : ["1/2","1/3","1/4","1/5"],
            r : 1,
            img:'simul201802.JPG',
            summary:``
        },
        {//45
            q : "다음 중 tlimit의 초기값은?",
            q1 : '' ,
            a : ["5","30","100","12345"],
            r : 3,
            img:'',
            summary:``
        },
        {//
            q : "다음중 seed 의 초기값은?",
            q1 : '' ,
            a : ["5","30","100","12345"],
            r : 4,
            img:'',
            summary:``
        },
        {////47
            q : "빈칸 '가'에 적당한 것은?",
            q1 : '' ,
            a : ["totque = totarr + tpump(i)","totque = totque+totarr","totque = totque + tstep","totque = totque + queue"],
            r : 4,
            img:'',
            summary:``
        },
        {//48
            q : "평균 대기시간을 구하는 공식을 만들려고 한다. 가장 적당한 것은?",
            q1 : '' ,
            a : ["totque / totarr","totque /arrive","totque / queue","totque/ (tlimit / tstep)"],
            r : 1,
            img:'',
            summary:``
        },
        {//
            q : "고객들에 대한 도착시간을 순서대로 나열한 것은?",
            q1 : '' ,
            a : ["1,2,3,5,8","1,2,3,5,9","3,5,6,7,8","4,6,7,8,9"],
            r : 2,
            img:'simul201803.JPG',
            summary:``
        },
        {//50
            q : "고객들의 도착시간 간격을 순서대로 구한 것은?",
            q1 : '' ,
            a : ["0,1,1,2,4",'1,2,3,5,9',"3,5,6,9,10","3,5,5,3,9"],
            r : 1,
            img:'',
            summary:``
        },
        {//51
            q : "고객들에 대한 봉사시간을 순서대로 구한 것은?",
            q1 : '' ,
            a : ["0,1,1,2,4","1,2,3,5,9","3,5,6,9","3,5,5,3,9"],
            r : 4,
            img:'',
            summary:``
        },
        {//
            q : "4번 고객까지 출발시간을 순서대로 구한 것은?",
            q1 : '' ,
            a : ["1,2,3,4","3,4,7,9","4,7,9,10","5,6,10,12"],
            r : 3,
            img:'',
            summary:``
        },
        {//53
            q : "TIME = 11 시점에서 고객들의 총 대기시간은?",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 3,
            img:'',
            summary:``
        },
        {//54
            q : "다음 중 정규확률변수의 평균 값으로 연료탱크의 평균을 나타내는 것은?",
            q1 : '' ,
            a : ["liters","nseed","nmean","stdev"],
            r : 3,
            img:'simul201804.JPG',
            summary:``
        },
        {//55
            q : "다음중 정규 확률변수의 표준편차를 나타내는 것은?",
            q1 : '' ,
            a : ["liters","nseed","nmean","stdev"],
            r : 4,
            img:'',
            summary:``
        },
        {//56
            q : "다음은 무엇에 관한 설명인가?",
            q1 : '' ,
            a : ["시스템","시뮬레이터","월드뷰","확률변수"],
            r : 3,
            img:'simul201805.JPG',
            summary:``
        },
        {//
            q : "다음 중 고정시간법의 특징은?",
            q1 : '' ,
            a : ["사건중심으로 진행하는 경우 효율적이다","처리 고객수를 미리 알 수 있다","언제 끝날지 종류시간을 미리 알수 없다","1분 1시간등 고정시간 단위로 진행한다."],
            r : 4,
            img:'',
            summary:``
        },
        {//
            q : "시뮬레이션 종료 조건으로 처리해야할 총 고객 수는?",
            q1 : '' ,
            a : ["totarr","timing","next","marrvt"],
            r : 1,
            img:'simul201806a.JPG',
            summary:``
        },
        {//
            q : "현재 고객의 봉사시간을 구하려고 한다. 관계 없는 것은?",
            q1 : '' ,
            a : ["nseed","e_dep","marrvt","mservt"],
            r : 3,
            img:'',
            summary:``
        },
        {//60
            q : "다음에 도착하는 고객의 시간은?",
            q1 : '' ,
            a : ["e_arr","e_dep","tne[1]","tne[2]"],
            r : 3,
            img:'',
            summary:``
        },
        {//
            q : "다음 중 시뮬레이션 전용언어가 아닌 것은?",
            q1 : '' ,
            a : ["OPNET","AweSim","ProModel","JAVA"],
            r : 4,
            img:'',
            summary:``
        },
        {//
            q : "다음은 범용언어와 시뮬레이션 언어에 대한 설명들이다 틀린 것은?",
            q1 : '' ,
            a : ["시뮬레이션 언어는 모델을 설계하기 위한 일반화된 구조를 제시한다.","시뮬레이션 언어는 프로그래밍 시간이 길고 출력 보고서의 형태도 자유롭게 작성할 수 있다.","시뮬레이션 언어는 모델 설계 및 변경이 용이하고 이와 같은 변경이 기계어 프로그램으로 즉시 적용될 수 있게 한다","범용언어는 C, JAVA, BASIC 등으로 사용자가 사용하기 쉽고 융통성이 많다. 또한 거의 모든 컴퓨터에서 쉽게 이용이 가능하다."],
            r : 2,
            img:'',
            summary:``
        },
        {//63
            q : "U[0,1) 의 난수를 발생시키는데 사용되는 분포는",
            q1 : '' ,
            a : ["정규분포","일양분포","포아송분포","지수분포"],
            r : 2,
            img:'',
            summary:``
        },
        {//64
            q : "이 방법의 이름은?",
            q1 : '' ,
            a : ["중앙 이승법","shift 연산법","승산식 합동법","혼합식 합동법"],
            r : 4,
            img:'simul201807.JPG',
            summary:``
        },
        {//65
            q : "X0=1 를 대입하여 x1을 구하면?",
            q1 : '' ,
            a : ["3","5","8","10"],
            r : 3,
            img:'',
            summary:``
        },
        {//
            q : "주기는?",
            q1 : '' ,
            a : ["2","3","4","5"],
            r : 1,
            img:'',
            summary:`x0 = 1 x1= 8 x2 = 3  x3= 8   x가 x0 x1 x2  (3개로 반복됨)`
        },
        {//67
            q : "자유도는?",
            q1 : '' ,
            a : ["99","100","101","102"],
            r : 1,
            img:'simul201808.JPG',
            summary:`???`
        },
        {//
            q : "구간별 기대값이 n/k의 값은?",
            q1 : '' ,
            a : ["20","40","50","60"],
            r : 4,
            img:'',
            summary:``
        },
        {//69
            q : "난수의 검정에서 독립성을 검정하는 것은?",
            q1 : '' ,
            a : ["x^2 검정","연속형 검정","Run-up 검정","Kolmogorov-Smirnov 검정"],
            r : 3,
            img:'',
            summary:``
        },
        {//
            q : "다음은 시뮬레이션의 응용사례들이다. 다음 중 나머지 셋과는 목적이 다르며 예측용 시뮬레이션인 것은?",
            q1 : '' ,
            a : ["원자력 발전소 시뮬레이터","운전연습 시뮬레이터","일기예보 시뮬레이션","파일러트(조종사) 시뮬레이션"],
            r : 3,
            img:'',
            summary:``
        },
       
    ]
    const testsimul2019 :Testtype[] =[
        {//
            q : "시뮬레이션 모델은 다음과 같은 4가지 수준에서 이용될 수 있다. 이중에서 공장의 제조겅정이나 물류 시스템을 분석하고 개선점을 찾는 시뮬레이션과 관련이 있는 것은?",
            q1 : '' ,
            a : ["시스템이나 문제를 정의하는 설명적 장치","한계적 구성요소를 결정하는 분석 도구","제안된 해결방안을 종합하고 평가하는 설계평가 도구",'해석적 문제를 풀이하고 해를 구하는 계산 도구'],
            r : 3,
            img:'',
            summary:``
        },
        {// 
            q : "다음은 시스템에 대한 설명이다. 설명이 틀린 것은?",
            q1 : '' ,
            a : ["관심의 대상이 되는 실세계의 부분집합","어느 목적을 위하여 하나 이상 서로 관련있는 구성요소가 결합된 것","따라서 이러한 시스템은 상대적인 것이 된다","범위를 고려할 때 모든 외적 요인들은 입력 데이터가 된다."],
            r : 4,
            img:'',
            summary:``
        },
        {//
            q : "다음 중 모델링을 하기 쉬운 경우는?",
            q1 : '' ,
            a : ["인간의 의사결정이 시스템의 절대적인 부분을 차지한다.","시스템에 부수되는 물리적인 규칙이 이용 가능하다","랜덤한 구성요소들이 중요한 요인이 된다.","이용 가능한 기본 규칙이 거의 없다."],
            r : 2,
            img:'',
            summary:``
        },
        {//39
            q : "다음 중 특정 시각에서의 시스템 표현으로 몬테칼로 시뮬레이션 등과 관계있는 모델은?",
            q1 : '' ,
            a : ["결정적 모델","정적 모델","이산 모델","수리적 모델"],
            r : 2,
            img:'',
            summary:``
        },
        {//40
            q : "난수 U는 총 몇개 발생되는가?",
            q1 : '' ,
            a : ["30,000","50,000","100,000","150,000"],
            r : 3,
            img:'simul2019.JPG',
            summary:``
        },
        {//41
            q : "원 안에 들어가는 점의 갯수를 나타내는 변수는>",
            q1 : '' ,
            a : ["s","y","limit","count"],
            r : 4,
            img:'',
            summary:``
        },
        {//
            q : "시뮬레이션의 장점들이다 관계가 없는 것은?",
            q1 : '' ,
            a : ["실시스템의 실질적인 구축 없이도 평가할 수 있다","확률적 시뮬레이션은 정확한 값이 아니라 추정량을 산출한다","실시스템이 위험성을 내포한 경우 시뮬레이션이 유용하다","실현 불가능한 경우도 시뮬레이션으로 실험 및 평가가 가능하다"],
            r : 2,
            img:'',
            summary:``
        },
        {////43
            q : "다음은 시뮬레이션 과정에 대한 설명이다 틀린 것은?",
            q1 : '' ,
            a : ["문제의 정의 : 문제 해결의 목적을 포함하여 연구하고자 하는 문제를 정의함","모델 설계 :  문제의 정의에 따라서 시스템을 수학적이고 논리적인 관계로 추상화 함","모델 변환 :  컴퓨터에서의 처리에 적절하게 모델을 변환 함.","타당성 검토 :  모델이 의도한 대로 컴퓨터 프로그램이 수행 될 수 있도록 준비함"],
            r : 4,
            img:'',
            summary:``
        },
        {//
            q : "35213을 초기값으로 갖는 변수는?",
            q1 : '' ,
            a : ["tlimit","prarr","seed","mean"],
            r : 3,
            img:'simul201901.JPG',
            summary:``
        },
        {//45
            q : "0.25를 초기값으로 갖는 변수는?",
            q1 : '' ,
            a : ["tstep","prarr","seed","mean"],
            r : 2,
            img:'',
            summary:``
        },
        {//
            q : "150을 초기값으로 갖는 변수는?",
            q1 : '' ,
            a : ["tlimit","prarr","seed","mean"],
            r : 1,
            img:'',
            summary:``
        },
        {//
            q : "5를 초기값으로 갖는 변수는?",
            q1 : '' ,
            a : ["tlimit","prarr","seed","mean"],
            r : 4,
            img:'',
            summary:``
        },
        {//
            q : "현재 봉사하려는 고객의 봉사시간을 구한 것은?",
            q1 : '' ,
            a : ["p","queue","prarr","totque"],
            r : 1,
            img:'',
            summary:``
        },
        {//
            q : "평균 대기행렬 길이는?",
            q1 : '' ,
            a : ["aveque","queue","prarr","tpump"],
            r : 1,
            img:'',
            summary:``
        },
        {//50
            q : "평균 대기시간을 구하는 공식을 만들려고 한다. 가장 적당한 것은?",
            q1 : '' ,
            a : ["totque / totarr"," totque / arrive","totque / queue","totque / (tlimit / tstep)"],
            r : 1,
            img:'',
            summary:``
        },
        {//
            q : "고객들에 대한 도착시간을 순서대로 나열한 것은?",
            q1 : '' ,
            a : ["1,2,4,6,8","1,2,3,5,9","3,5,6,7,8","4,6,7,8,9"],
            r : 1,
            img:'simul201902.JPG',
            summary:``
        },
        {//
            q : "고객들의 도착시간 간격을 순서대로 구한 것은?",
            q1 : '' ,
            a : ["0,1,2,2,2","1,1,2,2,2","1,1,1,2,3","1,1,2,3,2"],
            r : 1,
            img:'',
            summary:``
        },
        {//53
            q : "고객들에 대한 봉사시간을 순서대로 구한 것은?",
            q1 : '' ,
            a : ["4,2,4,4,6","4,3,4,3,6","4,5,4,3,6","4,4,4,5,6,"],
            r : 3,
            img:'',
            summary:``
        },
        {//
            q : "4번 고객까지 출발 시간을 순서대로 구한 것은?",
            q1 : '' ,
            a : ["1,4,6,8","4,6,8,9","5,7,9,10","5,6,10,12"],
            r : 3,
            img:'',
            summary:``
        },
        {//55
            q : "단일 창구 대기행렬 시뮬레이션에서 봉사시간에 다음과 같은 조건을 추가하였다.",
            q1 : '' ,
            a : ["liters","nseed","nmean","stdev"],
            r : 3,
            img:'simul201903.JPG',
            summary:``
        },
        {//56
            q : "다음 중 모델링 월드뷰에 대한 설명 중 틀린 것은?",
            q1 : '' ,
            a : ["시뮬레이션 모델 개발에 있어서 분석가는 모델 대상이 되는 시스템을 설명하기 위하여 개념적인 기본구조(frame work) 를 갖고 있어야 한다","이 기본구조는 시스템의 기능적인 관계를 잘 이해해서 그것을 표현할 수 있는 전체적인 시각인 월드뷰(world view)에 의하여 결정된다.","만일 모델 작성자가 시뮬레이션 언어를 사용한다면 기본 구조는 언어에 의해 자연히 암시적으로 표현된다.","혼합형 시뮬레이션 모델링의 경우 사건중심 진행방법, 액티비티 관찰중심방법, 프로세스 중심 진행방법들이 있다."],
            r : 4,
            img:'',
            summary:``
        },
        {//
            q : "다음 중 고정시간법의 특징은?",
            q1 : '' ,
            a : ["사건중심으로 진행하는 경우 효율적이다.","종료조건을 봉사 고객수로 한다","종료조건을 처리 시간으로 한다","언제 끝날지 종료 시간을 미리 알 수 없다"],
            r : 3,
            img:'',
            summary:``
        },
        {//58
            q : "고객의 평균 도착시간 간격을 나타내는 변수는?",
            q1 : '' ,
            a : ["marrvt","mservt","totarr","numcus"],
            r : 1,
            img:'simul201904.JPG',
            summary:``
        },
        {//
            q : "고객의 평균 봉사시간을 나타내는 변수는?",
            q1 : '' ,
            a : ["marrvt","mservt","totarr","numcus"],
            r : 2,
            img:'',
            summary:``
        },
        {//60
            q : "시뮬레이션 종료조건으로 총 고객 수를 나타내는 변수는",
            q1 : '' ,
            a : ["totarr","timing",'next',"marrvt"],
            r : 1,
            img:'',
            summary:``
        },
        {//61
            q : "다음 중 네트워크 설계 및 성능평가, 네트워크상의 문제해결, 응용프로그램 성능 분석 및 진단 등 네트워크 전반에 걸쳐서 활용되는 네트워크 시뮬레이션 전용언어는?",
            q1 : '' ,
            a : ["Riverbed Modeler (OPNET)","AweSim","ProModel","SLAM"],
            r : 1,
            img:'',
            summary:``
        },
        {//
            q : "다음 중 시뮬레이션에서 범용언어를 사용하는 경우의 장점은?",
            q1 : '' ,
            a : ["시뮬레이션 모델 설계에 일반화된 구조를 제공한다","사용자가 사용하기 쉽고 융통성이 많다","모델링과 프로그래밍 시간이 적게 걸린다","출력결과를 다양한 그래픽과 애니메이션으로 표현한다."],
            r : 2,
            img:'',
            summary:``
        },
        {//
            q : "컴퓨터를 이용하여 난수를 발생하는 경우 갖추어야 할 점이 아닌 것은?",
            q1 : '' ,
            a : ["반복발생이 가능해야 한다","상관관계가 없어야 한다","난수들 상호간에 종속적이어야 한다","[0,1) 범위에서 일양분포를 만족해야 한다."],
            r : 3,
            img:'',
            summary:``
        },
        {//
            q : "이 방법의 이름은?",
            q1 : '' ,
            a : ["중앙 이승법","shift 연산법","승산식 합동법","혼합식 합동법"],
            r : 4,
            img:'simul201905.JPG',
            summary:``
        },
        {//
            q : "X0 = 3을 대입하여 X1을 구하면?",
            q1 : '' ,
            a : ["1","3","5","9"],
            r : 4,
            img:'',
            summary:`2*3 + 3 = 9 (mod 10)  = 9`
        },
        {//66
            q : "계속해서 X2를 구하면?  ",
            q1 : '' ,
            a : ["1","3","5","9"],
            r : 1,
            img:'',
            summary:`X1 = 9    2*9 +3 =21   (mod 10 ) = 1`
        },
        {//67
            q : "주기는?",
            q1 : '' ,
            a : ["3","4","5","6"],
            r : 2,
            img:'',
            summary:`x1~> 계속 대입해서 반복이 발생할때까지... 계산해보라 그 횟수임 x0 =3  x1 = 9  x2= 1  x3 = 5  x4 = 3   반복이 나오게됨 x0 x1 x2 x3 이후 반복이니 4번이 주기임  `
        },
        {//68
            q : "구간별 기대값이 n/k인 값은?",
            q1 : '' ,
            a : ["30","40","50","60"],
            r : 4,
            img:'simul201906.JPG',
            summary:``
        },
        {//
            q : "계속해서 2차원 연속형 검정을 하려고 한다. 같은 수의 난수 6000개로 2차원 x,y난수를 만들고 100(10*10)개의 2차원 구간을 선정하였다. 기대값 n/k2은?",
            q1 : '' ,
            a : ["30","40","50","60"],
            r : 1,
            img:'',
            summary:``
        },
        {//
            q : "다음은 시뮬레이션의 응용사례들이다. 시뮬레이션 목적이 미래를 예측하는 것으로 나머지 셋과 가장 관련이 없는 것은?",
            q1 : '' ,
            a : ["원자력 발전소 시뮬레이터","운전연습 시뮬레이터","성형 시뮬레이션","파일러트 (조종사) 시뮬레이션"],
            r : 3,
            img:'',
            summary:``
        },
    ]
    const testsimulwork :Testtype[] =[
        {//1장 개념이해문제 -> 시험범위는 2장부터 8장2절까지임
            q : "시뮬레이션의 특징과 관계가 없는 것은?",
            q1 : '' ,
            a : ["실시스템의 실질적인 구축 없이도 평가할 수 있다","반복실험으로 인하여 비용을 절감한다.","위험성을 내포한 경우 유용하다.","해석적인 해를 구하기 어려운 경우 사용한다."],
            r : 2,
            img:'',
            summary:'시뮬레이션은 초기의 모델링 작업이라던지 , 그 후 모델에 대한 많은 반복실험등으로 인해 비용이 많이듬. 그러나 비용이 많이들지만 실제 시스템을 그대로 실험하는 경우에 비해서 경제적이라 할 수 있음 (비행기 조종사 훈련을 생각해봐라) 전쟁같은 실제 실험이 어려운 경우 효율적이다.'
        },
        {//
            q : "시뮬레이션을 행하는 이유이다. 관계가 없는 것은?",
            q1 : '' ,
            a : ["해석적 모델이 가능한 경우","직접적인 실행이 불가능한 경우","위험부담이 많은 경우","함수관계가 복잡한 경우"],
            r : 1,
            img:'',
            summary:'시뮬레이션은 해석적 방법이 어려운 경우 사용하는 실험적 방법임'
        },
        {//
            q : "다음중 시뮬레이션의 기본 요소가 아닌 것은?",
            q1 : '' ,
            a : ["실시스템","시뮬레이션 언어","모델","시뮬레이터"],
            r : 2,
            img:'',
            summary:'시뮬레이션의 세가지 기본 요소 :  실시스템 , 모델, 시뮬레이터'
        },
        {//
            q : "다음 중 시뮬레이션에 관련된 설명중 틀린 것은?",
            q1 : '' ,
            a : ["실제 시스템의 성질을 나타내는 모델을 만들고 그 모델을 실험한다.","실제 시스템을 구현하기 어려운 경우 시뮬레이션을 통해 분석하거나 예측할 수 있다.","수학적인 수식으로 모델을 작성하여 그것을 해법에 따라 해를 구한다.","기본요소로는 실시스템, 모델, 시뮬레이터 등이 있다."],
            r : 3,
            img:'',
            summary:'시뮬레이션은 해석적 방법 (수학적인 수식으로 모델을 작성하여 그것을 해법에 따라 해를 구하는 방법)이 어려운 경우 사용하는 실험적 방법이다.'
        },
        {//
            q : "다음은 시뮬레이션을 수행하기 어려운 이유들이다. 틀린 것은?",
            q1 : '' ,
            a : ["대형 시스템의 경우 복잡한 모델과 그에 따른 시뮬레이션 프로그램을 작성하기 매우 어렵다.","실제 시스템으로 부터 타당한 모델을 얻기가 어렵다. ","확률변수의 사용으로 많은 컴퓨터 시간과 비용이 요구된다.","주로 경험에 의한 모델의 설계 코딩 결과를 얻기 위한 프로그램 수행 등으로 구성되어 있다."],
            r : 3,
            img:'',
            summary:'시뮬레이션은 많은 컴퓨터 시간과 비용이 요구된다. 이유는 모델을 설계하고 구현하고 나서도 안정적인 값을 얻을 때 까지 반복수행 실험등을 하기 때문임 확률번수 사용 때문만이라고 할 수 없다.'
        },
        {//
            q : "시뮬레이션의 특징과 관계없는 것은?",
            q1 : '' ,
            a : ["실 시스템의 실질적인 구축 없이도 평가할 수 있다."," 정확한 해를 구하려 하는 경우 사용한다.","위험성을 내포한 경우 유용하다.","해석적인 해를 구하기 어려운 경우 사용한다."],
            r : 2,
            img:'',
            summary:'시뮬레이션은 모델에 대한 많은 반복실험등으로 인해 추정치를 구한 후 통계적인 방법을 사용하여 결과분슥을 한다. 따라서 정확한 해를 구할 수 없는 방법이다.'
        },
        {//20페이지 
            q : "시뮬레이션 모델은 다음과 같은 네가지 수준에서 이용될 수 있다. 설명이 틀린 것은?",
            q1 : '' ,
            a : ["시스템이나 문제를 정의하는 설명적 장치","한계적 구성요소를 결정하는 분석도구  ","제안된 해결방안을 종합하고 평가하는 설계평가 도구","해석적 문제를 풀이하고 해를 구하는 계산도구"],
            r : 4,
            img:'',
            summary:'시뮬레이션은 해석적 방법이 어려운 경우 사용하는 실험적 방법이다.'
        },
        {//
            q : "다음은 시뮬레이션에 대한 설명이다 틀린 것은?",
            q1 : '' ,
            a : ["모델의 대상이 되는 실제 대상을 실 시스템이라 한다.","정확하게 모델링한 것을 타당하다고 한다.","모델을 실험하는 기계를 시뮬레이터라고 한다.","시뮬레이터는 컴퓨터를 뜻한다."],
            r : 4,
            img:'',
            summary:'시뮬레이터는 모델을 실험할 수 있는 기계나 도구이다. 따라서 반드시 컴퓨터일 필요는 없다. 예를들면 모델하우스 같은경우 또는 민방위 훈련같은 경우는 모두 시뮬레이션이지만 컴퓨터를 사용하는것이 아니다.'
        },
        {//
            q : "다음 설명중 틀린 것은?",
            q1 : '' ,
            a : ["실 시스템 : 시뮬레이션 하고자 하는 실제 시스템"," 시뮬레이션 :ㅣ 시뮬레이터 위에서 실험하는 행위"," 모델 : 실시스템을 흉내내는 수학적 공식이나 실험절차","시뮬레이터 :모델을 실험하는 컴퓨터"],
            r : 4,
            img:'',
            summary:'시뮬레이터는 모델을 실험할 수 있는 기계나 도구이다. 따라서 반드시 컴퓨터일 필요 없음'
        },
        {// 1-2결정적 시뮬레이션
            q : "다음 중 은행이율을 나타내는 변수는?",
            q1 : '' ,
            a : ["savings","salary","perint","perinc"],
            r : 3,
            img:'시뮬레이션00.JPG',
            summary:'은행이율은 저축액에 대하여만 적용된다  저축액을 나타내는 공식은 savings = savings + (perint * savings + 0.10 * salary) 이다 . 이 식으로 부터 은행이율을 나타내는 변수는 perint임을 알 수 있다.'
        },
        {//
            q : "위 사진에서 연봉 인상율을 나타내는 변수는?",
            q1 : '' ,
            a : ["savings","salary","perint","perinc"],
            r : 4,
            img:'',
            summary:'연봉 인상율은 매년 10% 라 가정하였다. 그리고 조건에서 보면 연봉을 나타내는공식은 salary = salary + perinc * salary이다. 이 식으로부터 연봉의 인상률을 나타내는 변수는 perinc임을 알 수 있다.'
        },
        {//확률적 시뮬레이션
            q : "다음 확률적 시뮬레이션에 대한 설명중 틀린 것은?",
            q1 : '' ,
            a : ["probabilistic 또는 stochastic simulation이라고 한다.","결정적 시뮬레이션보다 효율적이다.","확률변수는 난수와 확률분포를 이용하여 발생할 수 있다.","(0, 1) 사이의 난수 u에다 적당한 변형식을 적용하여 원하는 확률변수를 발생시킨다."],
            r : 2,
            img:'',
            summary:'상황에 따라 다름, 상상 효율적이라 말할수 없다.'
        },
        {//
            q : "다음 중 확률적 시뮬레이션과 관계없는 것은?",
            q1 : '' ,
            a : ["난수발생기","연속형 확률변수","공의 탄성문제","이산사건 모델"],
            r : 3,
            img:'',
            summary:'결정적 시뮬레이션은 확률변수를 사용하지 않는 경우이다. 따라서 문제에서 다른 것은 모두 확률변수와 관련이 있지만 공의 탄성문제는 확률변수를 전혀 사용하지 않고 있으므로 결정적 시뮬레이션이다.'
        },
        {//
            q : "연봉을 나타내는 변수는?",
            q1 : '' ,
            a : ["perlow","perhig","perint","salary"],
            r : 4,
            img:'시뮬레이션01.JPG',
            summary:'savings = savings + (perint * savings + 0.10 * salary)    salary = salary + perinc * salary 로부터 알 수 있다.'
        },
        {//
            q : "위 사진을 참고하여 은행의 복리 이율을 나타내는 변수는?",
            q1 : '' ,
            a : ["perlow","perhig","perint","salary"],
            r : 3,
            img:'',
            summary:''
        },
        {//
            q : "가 에 알맞은 것은?",
            q1 : '' ,
            a : ["perlow","perhig","perint","salary"],
            r : 4,
            img:'',
            summary:'연봉의 10%를 저축한다는 초기 조건과 savings = savings + (perint * savings + 0.10 * salary) 로부터 알 수 있다.'
        },
        {//
            q : "나 에 알맞은 것은?",
            q1 : '' ,
            a : ["perlow","perhig","perint","salary"],
            r : 1,
            img:'',
            summary:'0 ~ 10% 의 일양확률변수이므로 다음과 같다. perhig = 10.0  perlow = 0.0  call random(seed,  u)  perinc = int(u * (perhig + 1 - perlow) + perlow)  perinc = perinc * 0.01'
        },
        {//
            q : "연봉의 인상률로 다 에 알맞은 것은?",
            q1 : '' ,
            a : ["perlow","perhig","perint","perinc"],
            r : 4,
            img:'',
            summary:'perinc = int(U * (perhig + 1 - perlow ) + perlow)  salary = salary + perinc * salary 등으로 부터 알 수 있다.'
        },
        {//
            q : "다음 중 난수의 발생과 관련 없는 것은?",
            q1 : '' ,
            a : ["seed","n","U","year"],
            r : 4,
            img:'',
            summary:'call random (seed , U), subprogram random(n, U) 등으로부터 seed, n, U 는 모두 관련이 있다.'
        },
        {//
            q : "난수의 초기값을 변화시키면 영향을 받게 되는 변수는?",
            q1 : '' ,
            a : ["perlow","perhig","perint","perinc"],
            r : 4,
            img:'',
            summary:''
        },
        {//
            q : "시뮬레이션에 대해 잘못 지적한 것은?",
            q1 : '' ,
            a : ["결정적 시뮬레이션이 확률적 시뮬레이션보다 현실상황에 맞아 많이 사용한다.","날씨 예측, 경제 시스템 등 분석하거나 예측할 때 자주 사용한다.","대형 시스템의 시뮬레이션 시에는 전용언어를 사용하는 것이 좋다","반복수행 등의 실험 등으로 많은 컴퓨터 시간이 요구된다."],
            r : 1,
            img:'',
            summary:'상황에 따라 확률변수가 필요하면 확률적 시뮬레이션이 되고, 확률변수가 필요없으면 결정적 시뮬레이션이 된다. 어느것이 더 상황에 맞다고 단정할 수는 없다.'
        },
        {//
            q : "다음 중 결정적 시뮬레이션은?",
            q1 : '' ,
            a : ["난수발생기","연속형 확률변수","공의 탄성문제","대기행렬 문제"],
            r : 3,
            img:'',
            summary:'공의 탄성문제는 물리학의 공식을 적용하여 시뮬레이션하는 데 확률변수를 사용하지 않는다. 난수발생기, 연속형 확률변수, 대기행렬 문제는 모두 확률변수와 관련이 있다.'
        },
        {//
            q : "다음중 결정적 시뮬레이션은?",
            q1 : '' ,
            a : ["주사위 문제","대기행렬 문제","공의 탄성 문제","π를 구하는 문제"],
            r : 3,
            img:'',
            summary:'공의 탄성문제는 물리학의 공식을 적용하여 시뮬레이션 하는데 확률변수를 사용하지 않는다.  주사위 문제 , 대기행렬문제, π 구하는 문제는 모두 확률변수를 사용한다.'
        },
        {//
            q : "주사위 문제를 시뮬레이션 하려고 한다. 이를 위하여 [0,1) 사이의 범위를 갖는 난수를 [1,6] 사이의 이산적 수로 변경해야 한다 다음 중 올바른 것은?",
            q1 : '' ,
            a : ["call random(seed. U)  side <- int(U*6) +1","call random (seed, U)  side <- U * 6 + 1","call random(seed, U)   side <- int( U * 5 ) + 1","call random(seed, U)   side <- U * 5  + 1"],
            r : 1,
            img:'',
            summary:'call random(seed, U)   side = int(U*6) +1 여기서 int는 정수형 변환함수임 side의, 범위는 다음과 같이 풀이된다.  int(U * 6 ) +1  U의 범위는 [0,1])  =int (0,6) + 1    (U*6의 범위는 [0,6])   = [0,5] + 1  여기에서 int는 정수형 변환 함수   = [1, 6]  이것은 이산형으로 바뀐 형태이므로 이 구간이 의미하는 것은 1,2,3,4,5,6이라는 의미가 된다.'
        },
        {//
            q : "다음중 일양확률변수 만을 사용하는 시뮬레이션은?",
            q1 : '' ,
            a : ["주사위 문제","연속형 확률변수","공의 탄성 문제","대기행렬문제"],
            r : 1,
            img:'',
            summary:'주사위 문제는 난수만을 사용하며, 난수는 일양확률변수이다. 연속형 확률변수에는 일양확률변수 뿐만아니라 지수확률변수, 정규확률변수 등 여러가지가 있다.  공의 탄성문제에서는 확률변수를 사용하지 않으며. 대기행렬 문제에서는 난수 외에 포아송 확률변수도 사용한다.'
        },
        {//
            q : "빈칸 가에 적당한 것은?",
            q1 : '' ,
            a : ["call random(seed, U)","perinc = perinc * 0.01","salary = salary + perinc * salary","perinc = int(U*(perhig + 1 - perlow) + perlow)"],
            r : 1,
            img:'시뮬레이션02.JPG',
            summary:'주어진 조건을 보면 연봉의 인상률이 0~ 10% 의 범위를 갖는 일양분포이다. 따라서 연봉의 인상률이 확률변수로 표현되어야 하므로 가장 먼저 해야 할 일은 일양확률변수인 난수를 발생해야 한다.  call random(seed, U)'
        },
        {//
            q : "빈칸 나에 적당한 것은?",
            q1 : '' ,
            a : ["call random(seed, U)","perinc = perinc * 0.01","salary = salary + perinc * salary","perinc = int(U*(perhig + 1 - perlow) + perlow)"],
            r : 4,
            img:'',
            summary:'구해진 난수 U는 범위가 [0,1]이다. 이를 0~ 10%의 범위를 갖는 일양확률변수로 변환해야 한다.  perinc = int(U * (perhig + 1 - perlow) + perlow)'
        },
        {//
            q : "빈칸 다에 적당한 것은?",
            q1 : '' ,
            a : ["call random(seed, U)","perinc = perinc * 0.01","salary = salary + perinc * salary","perinc = int(U*(perhig + 1 - perlow) + perlow)"],
            r : 2,
            img:'',
            summary:'앞에서 구해진 perinc는 범위가 0~10인 일양확률변수이다. 계산을 위해 이를 0~10%에 해당하는 0.0 ~ 0.10 으로 변환해야 한다, 따라서 perinc = perinc * 0.01'
        },
        {//
            q : "빈칸 라에 적당한 것은?",
            q1 : '' ,
            a : ["call random(seed, U)","perinc = perinc * 0.01","salary = salary + perinc * salary","perinc = int(U*(perhig + 1 - perlow) + perlow)"],
            r : 3,
            img:'',
            summary:'다음 순서는 앞에서 구해진 perinc를 이용하여 연봉의 인상률을 계산하기만 하면 된다. salary = salary + perinc * salary'
        },
        {//
            q : "문제가 변경되면서 알고리즘에 추가된 변수가 아닌 것은?",
            q1 : '' ,
            a : ["perlow","perhig","seed","perinc"],
            r : 4,
            img:'',
            summary:'확률변수를 구하기 위하여 추가된 변수는 perlow = 0.0   perhig = 10.0  call random(seed, U) 등이다. 그러나 perinc는 연봉의 인상률을 나타내는 변수로 새로 추가된 변수가 아니다.'
        },
        {//확률변수의 발생
            q : "한 서비스 회사에서 전화질외에 데이터 수집하였는데 다음과 같은 특징을 갖고있다. 어느 분포로 가정하는것이 적당하겠는가?",
            q1 : '사건은 연속된 시간 구간에 발생된 이산사건이며, 사건 간에는 전혀 영향이 없고 0의 발생확률이 매우 높다. 그리고 구간별 평균 발생값이 매우 작다.' ,
            a : ["일양분포","지수분포","이향분포","포아송분포"],
            r : 4,
            img:'',
            summary:'포아송분포의 특징을 나타냄'
        },
        {//
            q : "다음중 지수분포의 확률변수 발생식은?",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 2,
            img:'시뮬레이션03.JPG',
            summary:'확률변수 유도공식 지수확률변수 : X = -mlogU... m은 평균임'
        },
        {//
            q : "위에서 제시된 지수분포 확률변수 공식을 유도하려 한다. 가장 적당한 방법은",
            q1 : '' ,
            a : ["역변환법","합성법","결합법","채택-기각법"],
            r : 1,
            img:'',
            summary:'확률변수 x가 모수 m을 갖는 지수분포를 한다면 그 분포함수는... '
        },
        {//
            q : "창구가 2개 있는 우체국이 있다. 손님들이 도착해서 봉사를 받고 나면 우체국을 떠난다. 이때 손님들의 평균 대기시간을 시뮬레이션을 통하여 구해보려고 한다. 대부분의 손님들은 5분 이내에 봉사를 마친다고 한다. 다음 중 봉사시간에 적당한 확률분포는?",
            q1 : '' ,
            a : ["포아송 분포","지수분포","정규분포","일양분포"],
            r : 2,
            img:'',
            summary:'은행이나 우체국 등에서의 대기시간은 지수분포로 표현된다.'
        },
        {//
            q : "다음 중 포아송 확률변수의 발생공식은?",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 4,
            img:'시뮬레이션04.JPG',
            summary:''
        },
        {//
            q : "다음 빈칸에 알맞은 것은?",
            q1 : '' ,
            a : ["정규분포, 일양분포","일양분포, 포아송분포","지수분포, 정규분포","포아송분포, 지수분포"],
            r : 3,
            img:'시뮬레이션05.JPG',
            summary:'지수분포와 정규분포의 특징이다.'
        },
        {//
            q : "일양분포의 확률변수식은?",
            q1 : '' ,
            a : ["가","나","다","라"],
            r : 4,
            img:'시뮬레이션06.JPG',
            summary:'연속형 일양확률변수 : X = a + (b-a) U'
        },
        {//
            q : "정규분포의 확률변수식은?",
            q1 : '' ,
            a : ["가","나","다","라"],
            r : 3,
            img:'',
            summary:'정규확률변수'
        },
        {//
            q : "U[0,1]의 난수를 발생시키는데 사용되는 분포는?",
            q1 : '' ,
            a : ["일양분포","이항분포","정규분포","지수분포"],
            r : 1,
            img:'',
            summary:'U([0,1] 는 0과 1 사이의 범위의 일양분포를 만족하는 일양확률변수이다.'
        },
        {//
            q : "시행횟수를 나타내는 변수는?",
            q1 : '' ,
            a : ["nrolls","seed","U","side"],
            r : 1,
            img:'시뮬레이션07.JPG',
            summary:'알고리즘 형태를 보면 while i < nrolls do {  }   형태다 따라서 nrolls이다.' 
        },
        {//
            q : "빈칸 가에 적당한 식은?",
            q1 : '' ,
            a : ["(U * 6 )"," (U * 6 ) + 1","int( U * 6)","int (U * 6 ) +1"],
            r : 4,
            img:'',
            summary:'U[0,1]을 구했는데 이는 연속형 값을 갖는다. 이를 주사위의 숫자를 나타내는 이산형으로 변형해야한다. int(U*6)+1 ->  int[0,6) + 1  -> [0, 5] + 1  -> [1 , 6]  이것은 이산형으로 바뀐 형태이므로 이 구간은 1,2,3,4,5,6이라는 의미가 됨'
        },
        {//
            q : "결과가 다음과 같다. 이 결과와관련이 있는 것은?",
            q1 : '' ,
            a : ["일양분포","독립성","반복성","효율성"],
            r : 1,
            img:'시뮬레이션0.JPG',
            summary:'결과를 보면 주사위의 각 면이 출현할 숫자가 정확하게 일치하지 않지만. 대략 500에 근접하고 있음을 알 수 있다. 즉 일양분포의 성격을 나타내는 것이다.'
        },
        {//대기행렬
            q : "도착한 총고객의 수를 나타내는 것은?",
            q1 : '' ,
            a : ["prarr","seed","tpump","totarr"],
            r : 4,
            img:'시뮬레이션08.JPG',
            summary:'고객의 도착상황을 나타내는 부분은 arrive =1 .... totarr = totarr + 1 고객이 도착할 때마다 1씩 증가하는 변수  totarr이다.'
        },
        {//
            q : "고객의 봉사시간을 나타내는 것은?",
            q1 : '' ,
            a : ["prarr","seed","tpump","totarr"],
            r : 3,
            img:'',
            summary:'고객의 봉사시간은 tpump이다.'
        },
        {//
            q : "고객의 도착확률을 나타내는 것은?",
            q1 : '' ,
            a : ["prarr","seed","tpump","totarr"],
            r : 1,
            img:'',
            summary:''
        },
        {//
            q : "난수의 초기값을 나타내는 것은?",
            q1 : '' ,
            a : ["prarr","seed","tpump","totarr"],
            r : 2,
            img:'',
            summary:'call random(seed, U) 로부터 초기값을 나타내는 변수는 seed임을 알 수 있다.'
        },
        {//
            q : "",
            q1 : '' ,
            a : ["prarr","arrive","tpump","queue"],
            r : 4,
            img:'',
            summary:'대기행렬은 고객이 도착한 후 봉사를 받을 수 없으면 기다리는 줄을 의미한다. 도착상황을 나타내는 부분을 살펴보면 queue임을 알 수 있다.'
        },
        {//
            q : "대기시간의 총합(면적)을 나타내는 것은?",
            q1 : '' ,
            a : ["p","queue","totque","aveque"],
            r : 3,
            img:'',
            summary:'while문의 구성을 보면 마지막에 totque를 이용하여 누적계산하는 과정이 나오고 while문을 마친 후에 평균대기행렬 계산에 사용된다  따라서 totque가 됨'
        },
        {//
            q : "평균 대기행렬 길이는?",
            q1 : '' ,
            a : ["p","queue","totque","aveque"],
            r : 4,
            img:'',
            summary:'평균 대기행렬 길이는 전체 대기시간의 총 합을 시간으로 나눈 것이 된다. 따라서 aveque가 된다.'
        },
        {//
            q : "포아송 확률변수 값은?",
            q1 : '' ,
            a : ["p","queue","totque","aveque"],
            r : 1,
            img:'',
            summary:'포아송 확률변수는 다음의 알고리즘으로부터 p임을 쉽게 알 수 있다 all poissn(seed, mean, p)  tpump = p'
        },
        {// 2장
            q : "다음은 시뮬레이션 모델에 대한 설명이다. 괄호안에 알맞은 것을 순서대로 나열한 것은?",
            q1 : '2장 모델링과 시뮬레이션 --- 여기부터 시험범위' ,
            a : ["설계 평가도구, 분석도구, 설명적 장치, 예측도구","분석도구, 설계평가도구, 설명적 장치, 예측도구","설명적 장치, 분석도구, 설계평가도구, 예측도구","분석도구, 설계평가 도구, 예측도구, 설명적 장치"],
            r : 3,
            img:'시뮬레이션09.JPG',
            summary:''
        },
        {//
            q : "다음은 시뮬레이션 모델에 대한 설명이다 보기에서 설명과 이름을 바르게 연결한 것은?",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 4,
            img:'시뮬레이션10.JPG',
            summary:''
        },
        {//
            q : "시뮬레이션 모델이 이용되는 것이 아닌 것은?",
            q1 : '' ,
            a : ["시스템이나 문제를 정의하는 설명적 장치","한계적 구성요소를 결정하는 분석도구","미래의 개발을 예측하는 예측도구","시스템의 맹세를 구현하는 구현도구"],
            r : 4,
            img:'',
            summary:'시뮬레이션 모델은 설명적 장치, 분석도구, 설계평가도구, 예측도구 등에 이용된다. 시스템의 명세를 구현하는 구현도구는 아니다.'
        },
        {//
            q : "시뮬레이션 모델은 다음 네가지 수준에서 이용될 수 있다. 설명이 틀린 것은?",
            q1 : '' ,
            a : ["시스템이나 문제를 정의하는 설명적 장치"," 한계적 구성요소를 결정하는 분석도구","제안된 해결방안을 종합하고 평가하는 설계평가 도구","해석적 문제를 풀이하고 해를 구하는 계산도구"],
            r : 4,
            img:'',
            summary:'시뮬레이션은 해석적 방법이 어려운 경우 사용하는 실험적 방법이다.'
        },
        {//
            q : "시뮬레이션 모델은 다음 네가지 수준에서 이용될 수 있다. 이 중에서 공장의 물류 시스템을 분석하고 개선점을 찾는 시뮬레이션과 관련이 있는 것은?",
            q1 : '' ,
            a : ["시스템이나 문제를 정의하는 설명적 장치"," 한계적 구성요소를 결정하는 분석도구","제안된 해결방안을 종합하고 평가하는 설계평가 도구","해석적 문제를 풀이하고 해를 구하는 계산도구"],
            r : 2,
            img:'',
            summary:'공장의 물류시스템을 분석하고 개선점을 찾는 시뮬레이션은 모두 비효율적인 부분을 찾아내어 효율화하는, 즉 제안된 해결방안을 종합하고 평가하는 설계평가 도구에 해당된다. 최적 자동창고, 공장설비 진단, 제조공정 시뮬레이션 등이 있다.'
        },
        {//06
            q : "다음은 시뮬레이션 모델에 대한 설명이다 괄호안에 알맞은 내용을 순서대로 나열한것은?",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 3,
            img:'시뮬레이션11.JPG',
            summary:''
        },
        {//
            q : "다음은 시뮬레이션 모델이 사용되는 것에 대한 설명이다 틀린 것은?",
            q1 : '' ,
            a : ["시스템이나 문제를 정의하고 이해를 주는 설명적 장치","미래의 개발계획을 예측하고 도와주는 예측도구","제안된 해결방안을 종합하고 평가하는 설계평가 도구","실시스템을 수리적인 공식으로 표현하는 해석적 기능"],
            r : 4,
            img:'',
            summary:'시뮬레이션은 해석적 방법이 어려운 경우 사용하는 실험적 방법임'
        },
        {// 시스템
            q : "어느 목적을 위하여 하나 이상 서로 관련있는 구성요소가 결합된 것으로 실세계의 부분집합인 것은?",
            q1 : '' ,
            a : ["시스템","모델","상태변수","시스템변수"],
            r : 1,
            img:'',
            summary:'시스템이란 관심의 대상이 되는 실세계의 제한된 부분에 속해 있는 관련된 요소들의 집합이다. 좀더 자세히 정의하면 어느 목적을 위하여 하나 이상 서로 관련있는 구성요소가 결합된 것으로 실세계의 부분집합이다.'
        },
        {//
            q : "다음은 시스템에 대한 설명이다 . 틀린것은?",
            q1 : '' ,
            a : ["관심의 대상이 되는 실세계의 부분집합이다.","어느 목적을 위하여 하나 이상 서로 관련있는 구성요소가 결합된 것이다.","시스템은 상대적인 것이다.","범위를 고려할 때 모든 외적 요인들은 입력 데이터가 된다."],
            r : 4,
            img:'',
            summary:'시스템 정의를 확장시켜 외적 요인을 포함하기도 하고 또는 무시하기도 한다.'
        },
        {//
            q : "다음은 시스템에 대한 설명이다 틀린 것은?",
            q1 : '' ,
            a : ["관심의 대상이 되는 실세계의 부분집합이다.","어느 목적을 위하여 하나 이상 서로 관련있는 구성요소가 결합된 것이다.","특별한 대상들의 집합은 하위 시스템이 될 수 있다.","모든 외적 요인들은 함수식으로 명시된다."],
            r : 4,
            img:'',
            summary:'입력 데이터로 하는 경우도 있지만. 시스템 정의를 확장시켜 외적 요인을 포함하기도 하고 또는 무시하기도 한다. 외적 요인들이 시스템에 포함되는 경우는 함수식으로 명시된다.'
        },
        {//
            q : "관심의 대상이 되는 실세계의 부분집합으로 그 속에 관련된 요소들이 어느 목적을 위하여 결합된 것은?",
            q1 : '' ,
            a : ["모델","시스템","프로세스","사건"],
            r : 2,
            img:'',
            summary:'시스템이란 관심의 대상이 되는 실세계의 부분집합으로 그 속에 관련된 요소들이 어느 목적을 위하여 결합된 것이다.'
        },
        {//
            q : "어느 목적을 위하여 하나 이상 서로 관련있는 구성요소가 결합된 것으로 실세계의 부분집합인 것은?",
            q1 : '' ,
            a : ["설계대안","시스템","액티비티","시뮬레이터"],
            r : 2,
            img:'',
            summary:'시스템이란 관심의 대상이 되는 실세계의 제한된 부분에 속해 있는 관련된 요소들의 집합니다. 좀더 자세히 정의하면 어느 목적을 위하여 하나 이상 서로 관련있는 구성요소가 결합된 것으로 실세계의 부분집합이다.'
        },
        {// 모델
            q : "다음은 시스템 모델링이 어려운 경우에 대한 설명이다. 괄호안에 들어갈 내용을 올바르게 나열한 것은?",
            q1 : '' ,
            a : ["의사결정, 랜덤한, 기본규칙, 정량화","기본규칙, 정량화, 의사결정, 랜덤화","기본규칙, 의사결정, 랜덤규칙, 정량화","의사결정, 정량화, 기본규칙, 랜덤화"],
            r : 1,
            img:'시뮬레이션12.JPG',
            summary:''
        },
        {//39쪽
            q : "시뮬레이션을 하기 위하여 실제 대상 시스템의 행위를 흉내내는 수학적 공식등을 유도하는 것은?",
            q1 : '' ,
            a : ["실시스템","모델","시뮬레이터","시뮬레이션 언어"],
            r : 2,
            img:'',
            summary:'모델은 시뮬레이션을 하기 위하여 실제 대상 시스템의 행위를 흉내내는 수학적 공식 등을 유도하는 것이다.'
        },
        {//
            q : "다음은 모델링에 대한 설명이다 . 빈칸에 적당한 것은?",
            q1 : '' ,
            a : ["모델의 출력","성능평가","설계대안","시스템의 영역"],
            r : 4,
            img:'시뮬레이션13.JPG',
            summary:'시뮬레이션 접근방법의 첫번째 단계는 서술된 문제나 프로젝트목적에 근거한 모델링 목적의 수립이다. 이 목적에 근거하여 시스템영역과 모델링의 상세성 정도가 작성되어야 한다. 이와같은 추상화의 결과로 모델이 생성되는데 이 모델에서는 실제 시스템에서 잘 정의되지 않은 모호한 부분들이 정확히 표현된다.'
        },
        {//
            q : "다음 중 모델링을 하기가 쉬운 경우는?",
            q1 : '' ,
            a : ["인간의 의사결정이 시스템의 절대적인 부분을 차지한다.","시슽템에 대한 도형적 표현이 가능하다","랜덤한 구성요소들이 중요한 요인이 된다.","이용 가능한 기본 규칙이 거의 없다."],
            r : 2,
            img:'',
            summary:'시스템에 대한 도형적 표현이 가능하다면 모델링이 쉽다.'
        },
        {//
            q : "다음중 모델링을 하기가 쉬운 경우는?",
            q1 : '' ,
            a : ["인간의 의사결정이 시스템의 절대적인 부분을 차지한다","시스템에 부수되는 물리적인 규칙이 이용 가능하다","랜덤한 구성요소들이 중요한 요인이 된다.","이용가능한 기본규칙이 거의 없다"],
            r : 2,
            img:'',
            summary:'물리적인 규칙이 이용 가능하면 모델을 만들기 쉽다.'
        },
        {//
            q : "다음중 모델링에 대한 설명으로 가장 올바른 것은?",
            q1 : '' ,
            a : ["실제 대상 시스템의 행위를 흉내내는 것으로 주로 수리적으로 유도하여 컴퓨터에서 실험한다.","시스템에 부수되는 물리적인 규칙이 이용 가능한 경우는 모델링이 쉽다","랜덤한 구성요소들이 중요한 요인이 된다면 모델링이 어렵다","위의 설명이 모두 맞다"],
            r : 4,
            img:'',
            summary:'모든 설명이 올바르다'
        },
        {//2.4 시뮬레이션 모델의 분류
            q : "시뮬레이션 모델을 분류하는 바업은 여러 형태가 있다. 다음 중 특정 시각에서의 시스템 표현이나 변화하는 시간에서의 시스템 표현 등과 관계있는 모델 분류방법은?",
            q1 : '' ,
            a : ["결정적 모델과 확률적 모델","정적 모델과 동적 모델","이산 모델과 연속 모델","물리적 모델과 수리적 모델"],
            r : 2,
            img:'',
            summary:'정적 모델(특정 시각에서의 시스템 표현)과 동적 모델(변화하는 시간에서의 시스템 표현)에 대한 설명이다.'
        },
        {//
            q : "다음중 특정 시각에서의 시스템 표현으로 몬테칼로 시뮬레이션 등과 관계있는것은?",
            q1 : '' ,
            a : ["결정적 모델","정적 모델","이산 모델","수리적 모델"],
            r : 2,
            img:'',
            summary:'정적 모델은 특정 시각에서의 시스템 표현으로 몬테칼로 시뮬레이션등이 있다.'
        },
        {//
            q : "다음 시뮬레이션 모델에서 확률변수를 사용하지 않는 것은?",
            q1 : '' ,
            a : ["정적 모델","결정적 모델","이산 모델","수리적 모델"],
            r : 2,
            img:'',
            summary:'결정젹 모델은 확률변수를 사용하지 않는 것이다.'
        },
        {//
            q : "다음은 시뮬레이션 모델을 분류한 것이다. 아파트 모델하우스는 어디에 속하는가?",
            q1 : '' ,
            a : ["결정적 모델과 확률적모델","정적 모델과 동적 모델","이산 모델과 연속 모델","물리적 모델과 수리적 모델"],
            r : 4,
            img:'',
            summary:'아파트 모델하우스는 물리적 모델에 속한다.'
        },
        {//
            q : "다음중 확률적 시뮬레이션에 해당하는 것은?",
            q1 : '' ,
            a : ["저축문제 1","저축 문제 2","공의 탄성문제","population 모델"],
            r : 2,
            img:'',
            summary:'저축문제 2에서는 연봉의 인상률을 실제 상황과 같게 하기 위하여 확률변수를 사용한다.'
        },
        {//
            q : "다음중 확률적 시뮬레이션에 해당하는 것은?",
            q1 : '' ,
            a : ["저축문제 1","대기행렬 문제","공의 탄성문제","population 모델"],
            r : 2,
            img:'',
            summary:'대기 행렬 문제에서는 고객의 도착과 봉사시간을 정하는 데 일양확률변수와 포아송 확률변수를 사용한다.'
        },
        {//
            q : "다음은 시뮬레이션 모델을 분류하는 방법에 대한 설명이다. 틀린 것은?",
            q1 : '' ,
            a : ["상태변수가 확률변수를 사용하는지의 여부에 따라 정적 모델과 동적 모델로 구분한다.","상태변수가 연속인지 불연속인지의 여부에 따라 이산 모델과 연속 모델로 나뉜다.","아파트 모델하우스나 축소된 자동차. 배 등은 물리적 모델에 속한다.","사건의 발생시점에서 시뮬레이션을 진행하는 경우는 이산 모델에 속한다."],
            r : 1,
            img:'',
            summary:'시간 진행 없이 특정 시각에서만 실험하면 정적모델이고, 시간이 변화하면서 전개되면 동적 모델이다.'
        },
        {//
            q : "다음은 시뮬레이션 모델을 분류하는 방법에 대한 설명이다. 틀린 것은?",
            q1 : '' ,
            a : ["상태변수가 확률변수를 사용하는 지의 여부에 따라 확률적 모델과 결정적 모델로 구분한다.","상태변수가 연속인지의 여부에 따라 이산 모델과 연속 모델로 나뉜다.","물리학의 공식을 사용하는 경우 물리적 모델이라고 한다.","사건의 발생시점에서 시뮬레이션을 진행하는 경우는 이산 모델에 속한다."],
            r : 3,
            img:'',
            summary:'물리적 모델이란 아파트 모델하우스와 같이 수리적인 방법을 사용하지 않고 물리적으로 모델을 구성하는 경우를 의미한다.'
        },
        {//
            q : "다음 발생시킨 2차원 난수의 개수로 값이 50,000인 변수는?",
            q1 : '' ,
            a : ["U","limit","count","s"],
            r : 2,
            img:'시뮬레이션14.JPG',
            summary:'limit를 발생시키는 총난수의 개수이므로 50,000'
        },
        {//
            q : "알고리즘에서 A의 면적을 나타내는 것은?",
            q1 : '' ,
            a : ["가","나","다","라"],
            r : 3,
            img:'',
            summary:'A = count/ 50,000   이므로 s=count / limit와 같다.'
        },
        {//
            q : "난수 U는 총 몇번 발생되는가?",
            q1 : '' ,
            a : ["31,415","50,000","100,000","200,000"],
            r : 4,
            img:'시뮬레이션15.JPG',
            summary:'limit = 100,000 이고 while문에서 두번 발생시키므로 200,000번 발생된다.'
        },
        {//
            q : "점(좌표)는 총 몇개 발생되는가",
            q1 : '' ,
            a : ["31,415","50,000","100,000","200,000"],
            r : 3,
            img:'',
            summary:'limit - 100,000 이므로 200,000개의 난수가 발생하지만 하나는 x좌표, 다른 하나는 y좌표가 되어 2차원 좌표를 생성한다. 따라서 100,000 개의 2차원 좌표가 생성된다.'
        },
        {//
            q : "원 안에 들어가는 점의 개수를 나타내는 변수는?",
            q1 : '' ,
            a : ["s","y","limit","count"],
            r : 4,
            img:'',
            summary:'원안에 들어가는 점들은 다음의 조건 if x2 + y2 <= 1 then  count = count + 1   i= i + 1  을 만족시켜야 한다. 따라서 count가 된다.'
        },
        {//
            q : "구해진 π값에 근사한 값은?",
            q1 : '' ,
            a : ["s","y","limit","count"],
            r : 1,
            img:'',
            summary:'s = count / limit는 (1/4)π 의 근사값이다. 따라서 s= s * 4 가 π값에 근사한 값이다.'
        },
        {// 2.5 시뮬모델
            q : "다음 중 한 종족의 수를 예측해 보는 모델과 관련이 있는 것은?",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 3,
            img:'시뮬레이션16.JPG',
            summary:'population 모델은 한 종족의 수를 예측해 보는 모델이다. 여기서 모델변수로 출산율, 사망률 다른 개체의 존재 외부한경 등이다.'
        },
        {//
            q : "토끼와 여우의 관계처럼 천적과 숙주 두 종족간의 상호작용으로 인한 종족 수를 예측해 보는 모델은?",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 1,
            img:'시뮬레이션17.JPG',
            summary:'population 모델과 관련하여 천적과 숙주 두 종족간의 상호작용으로 인한 종족 수를 예측하는 모델로 prey - predator모델이 있다. prey 토끼 - 최대  predator 여우 - 최소...'
        },
        {// 2.6 시뮬 특징
            q : "다음중 시뮬레이션의 단점이 아닌 것은?",
            q1 : '' ,
            a : ["많은 비용과 시간이 필요하고 프로그램이 어렵다","주로 해석적 방법이 불가능한 경우이다.","확률적 시뮬레이션은 단지 추정량을 산출한다.","과잉의 신뢰를 주는 경향이 있다."],
            r : 2,
            img:'',
            summary:'해석적 방법이 불가능한 경우 시뮬레이션으로 해결하므로 장점이다.'
        },
        {//
            q : "다음은 시뮬레이션의 특징이다. 시뮬레이션이 시스템 최적화에 적합하지 않은 이유에 해당하는 것은?",
            q1 : '' ,
            a : ["시뮬레이션 모델은 개발상 많은 비용과 시간을 요한다.","확률적 시뮬레이션 모델의 수행은 특정 입력 매개변수의 집합에 대하여 단지 모델의 특성에 대한 추정량을 산출한다.","시뮬레이션에 의해 산출되는 많은 양의 수치들은 연구 결과에 대하여 과잉의 신뢰를 주는 경향이 있다.","시뮬레이션은 그 복잡성에도 불구하고 컴퓨터 프로그래밍의 연습에 불과하다는 인상을 주기가 쉽다."],
            r : 2,
            img:'',
            summary:'확률적 시뮬레이션 모델의 수행은 특정 입력 매개변수의 집합에 대하여 단지 모델의 특성에 대한 추정량을 산출하므로 정확한 값을 요구하는 최적화에는 적합하지 않다.'
        },
        {//
            q : "다음은 시뮬레이션 장점들이다. 관계없는 것은?",
            q1 : '' ,
            a : ["실시스템의 실질적인 구축 없이도 평가할 수 있다.","반복실험으로 인하여 비용을 절감한다.","위험성을 내포한 경우 유용하다","실현불가능한 경우도 실험 가능하다."],
            r : 2,
            img:'',
            summary:'시뮬레이션은 타당한 모델 설계와 구현 그리고 다양한 시나리오별 시뮬레이션과 안정적인 결과를 얻기 위하여 여러번 반복실험하므로 해석적인 방법보다는 비용과 시간이 많이 드는 방법이다. 그러나 직접 실험하는 것보다는 비용이 훨씬 적게들고 위험부담이 없는 방법이다.'
        },
        {//
            q : "다음은 시뮬레이션의 장점들이다. 관계없는 것은?",
            q1 : '' ,
            a : ["실시스템의 실질적인 구축 없이도 평가할 수 있다.","모델의 특성에 대한 추정량을 산출한다.","위험성을 내포한 경우 유용하다","실현 불가능한 경우도 실험 가능하다."],
            r : 2,
            img:'',
            summary:'확률적 시뮬레이션 모델의 수행은 특정 입력 매개변수의 집합에 대하여 단지 모델의 특성에 대한 추정량을 산출한다. 이러한 단점으로 인하여 시뮬레이션이 시스템 최적화에 적합하지 않다.'
        },
        {//
            q : "다음은 시뮬레이션의 특징이다. 잘못 설명된 것은?",
            q1 : '' ,
            a : ["시뮬레이션 모델은 개발상 많은 비용과 시간을 요한다.","시뮬레이션에 의해 산출되는 많은 양의 수치들은 연구결과에 대하여 과잉의 신뢰를 주는 경향이 있다.","확률적 시뮬레이션 모델은 정확한 값을 요구하는 시스템 최적화 등에 적합하다.","실시스템의 실질적인 구축 없이도 평가할 수 있다."],
            r : 3,
            img:'',
            summary:'확률적 시뮬레이션 모델의 수행은 특정 입력 매개변수의 집합에 대하여 단지 모델의 특성에 대한 추정량을 산출하므로 정확한 값을 요구하는 최적화에는 적합하지 않다.'
        },
        {//2.7
            q : "시뮬레이션에서 작성된 모델이 실제 시스템을 정확히 표현하는지 검토하는 과정은?",
            q1 : '' ,
            a : ["문제의 정의","모델 정의","타당성","검증"],
            r : 3,
            img:'',
            summary:'모델이 실제 시스템을 정확히 표현하는것을 타당성이라 한다.'
        },
        {//
            q : "일반적인 시뮬레이션 과정 순서가 올바른 것은?",
            q1 : '' ,
            a : ["문제정의 -> 모델설계 -> 자료수집 -> 모델변환 -> 검증 -> 실험","모델설계 -> 모델변환 -> 문제정의 -> 자료수집 -> 검증 -> 실험","자료수집 -> 문제 정의 -> 모델설계 -> 모델 변환 -? 검증 -> 실험","문제정의 -> 모델 설계 -> 모델변환 -> 자료 수집 -> 검증-> 실험"],
            r : 1,
            img:'',
            summary:`시뮬레이션 과정
            문제의 정의 :  문제해결의 목적을 포함하여 연구하고자 하는 문제를 정의한다
            모델 설계 : 문제의 정의에 따라 시스템을 수학적이고 논리적인 관계로 추상화 한다
            자료수집 : 자료를 파악하고 수집한다
            모델변환 :  컴퓨터에서 처리에 적절하게 모델을 변환한다
            검증 : 시뮬레이션 모델이 표현한 것을 정확하게 컴퓨터 프로그램으로 바꾸어 제대로 수행되는지 확인
            타당성 검토 :  시뮬레이션 모델과 실시스템의 관계가 일치하는가를 검토
            실험계획 수립 :  모델을 실험하기 위한 제반 계획읠 수립
            실험 : 실험결과를 얻기 위해 시뮬레이션 모델을 수행
            결과분석 : 문제해결에 대한 추론을 얻고 권고안을 작성하기 위해 시뮬레이션 실험결과를 분석
            구현과 문서화 : 시뮬레이션 결과로부터 도출되는 결정을 구현하고 모델과 모델이용에 대하여 문서화
            `
        },
        {//
            q : "시스템을 수학적이고 논리적인 관계로 추상화하는 단계와 관계가 있는것은?",
            q1 : '' ,
            a : ["가","나","다","라"],
            r : 2,
            img:'시뮬레이션18.JPG',
            summary:'모델 설계 : 문제의 정의에 따라 시스템을 수학적이고 논리적인 관계로 추상화한다.'
        },
        {//
            q : "시뮬레이션 모델이 실시스템을 정확히 표현했는지를 분석하는 단계는?",
            q1 : '' ,
            a : ["다","라","마","사"],
            r : 3,
            img:'',
            summary:`검증 : 시뮬레이션 모델이 표현한 것을 정확하게 컴퓨터 프로그램으로 바꾸어 제대로 수행되는지 확인
            타당성 검토 :  시뮬레이션 모델과 실시스템의 관계가 일치하는가를 검토`
        },
        {//
            q : "다음은 시뮬레이션 과정에 대한 설명이다. 틀린 것은?",
            q1 : '' ,
            a : ["문제의 정의: 시스템을 수학적이고 논리적인 관계로 추상화","모델변환 :  컴퓨터에서 처리에 적절하게 모델을 변환한다","타당성 검토 :  시뮬레이션 모델과 실시스템의 관계가 일치하는가를 검토","검증 : 시뮬레이션 모델이 표현한 것을 정확하게 컴퓨터 프로그램으로 바꾸어 제대로 수행되는지 확인"],
            r : 1,
            img:'',
            summary:'문제의 정의 :  문제해결의 목적을 포함하여 연구하고자 하는 문제를 정의한다'
        },
        {//
            q : "다음은 시뮬레이션 과정에 대한 설명이다. 틀린것은?",
            q1 : '' ,
            a : ["문제의 정의(formulation) : 문제 해결의 목적을 포함하여 연구 하고자 하는 문제를 정의한다","모델설계 : 컴퓨터에서의 처리에 적절하게 모델을 변환한다","검증 : 시뮬레이션 모델이 표현한것을 정확하게 컴퓨터 프로그램으로 바꾸어서 제대로 수행 되는지 확인한다","타당성 검토 : 시뮬레이션 모델과 실시스템의 관계가 일치하는가를 검토한다"],
            r : 2,
            img:'',
            summary:'2번은 모델변환에 대한 설명이다 '
        },
        {//
            q : "다음은 시뮬레이션 과정에 대한 설명이다. 틀린것은?",
            q1 : '' ,
            a : ["문제의 정의(formulation) : 문제 해결의 목적을 포함하여 연구 하고자 하는 문제를 정의한다","모델설계 : 컴퓨터에서의 처리에 적절하게 모델을 변환한다","모델변환: 컴퓨터 에서의 처리에 적절하게 모델을 변환한다.","타당성 검토 : 모델이 의도한 대로 컴퓨터 프로그램이 수행될 수 있도록 준비한다"],
            r : 4,
            img:'',
            summary:'타당성 검토 : 시뮬레이션 모델과 실 시스템의 관계가 일치하는가를 검토함'
        },
        {//
            q : "다음은 시뮬레이션 과정에 대한 설명이다. 보기의 가 나 다 라와 관련된 용어를 순서대로 나열한 것은?",
            q1 : '' ,
            a : ["문제의 정의, 모델의 설계, 검증, 타당성 검토","모델의 설계, 문제의 정의, 검증 ,타당성 검토","검증, 모델설계, 문제의 정의, 타당성 검토","타당성 검토, 문제의 정의, 모델설계 , 검증"],
            r : 1,
            img:'시뮬레이션19.JPG',
            summary:''
        },
        {//
            q : "다음은 시뮬레이션 과정에 대한 설명이다. 어느 단계를 설명하는 것인가?",
            q1 : '' ,
            a : ["모델 설계","문제의 정의","모델 변환","자료 수집"],
            r : 1,
            img:'시뮬레이션20.JPG',
            summary:'모델 설계에 관한 설명이다.'
        },
        {//
            q : "다음은 시뮬레이션 과정에 대한 설명이다 어느 단계를 설명하는 것인가?",
            q1 : '이 단계는 점전적인 성질이 있기 때문에 연구과정 동안 계속 변화된다. 추가적인 안목이 생기고 추가적인 질문이 관심사가 되면 새로 개조된다.' ,
            a : ["모델설계","문제 정의",'모델변환',"자료 수집"],
            r : 2,
            img:'',
            summary:'첫번째 단계인 문제의 정의에 관한 설명이다.'
        },
        {//
            q : "다음중 시뮬레이션 모델과 실 시스템의 관계가 일치하는가를 검토하는 것과 관련이 있는 것은?",
            q1 : '' ,
            a : ["문제의 정의","모델 구축","검증","타당성 검토"],
            r : 4,
            img:'',
            summary:'타당성 검토에 대한 설명임'
        },
        {// 3장 대기행렬문제
            q : "주유대가 봉사하고 있는지 점검하는 것은?",
            q1 : '' ,
            a : ["가","나","다","라"],
            r : 3,
            img:'시뮬레이션21.JPG',
            summary:'if(tpump(i) >0.0 ) then  봉사시간이 0보다 크다는 것은 봉사시간이 남았다는 뜻이 되고 주유대가 아직 봉사중이라는 것을 나타낸다. 만일 0보다 크지 않다면 주유대가 쉬고 있다는 뜻이다.'
        },
        {//
            q : "고객의 도착을 점검하는 것은?",
            q1 : '' ,
            a : ["가","나","다","라"],
            r : 2,
            img:'',
            summary:'prarr은 도착확률이므로 이 문장은 고객이 도착하는 조건을 나타내고 있다.'
        },
        {//
            q : "봉사를 마치고 새 고객을 맞을 수 있는지 점검하는 것은?",
            q1 : '' ,
            a : ["가","나","다","라"],
            r : 4,
            img:'',
            summary:'주유대에서 봉사시간이 0 (tpump(i)= 0.0 )이라는 것은 봉사를 마치고 주유대가 비어 있다는 뜻이고, 대기행렬이 0이 아니라는 것은 (queue != 0) 기다리는 고객이 있다는 뜻이 된다.'
        },
        {//
            q : "현재 대기행렬에서 대기하고 있는 고객의 수는?",
            q1 : '' ,
            a : ["aveque","queue","prarr","tpump"],
            r : 2,
            img:'',
            summary:'queue=queue + arrive 로부터 알 수 있다. 즉 고객이 도착할때마다 1명씩 추가하므로 기다리고 있는 고객의 수가 된다.'
        },
        {//
            q : "평균 대기행렬 길이는?",
            q1 : '' ,
            a : ["aveque","queue","prarr","tpump"],
            r : 1,
            img:'',
            summary:'aveque = totque / (tlimit/tstep) 로부터 알 수 있다. 즉 총대기시간/ 시뮬레이션 시간이다.'
        },
        {//
            q : "현재 봉사하려는 고객의 봉사시간을 구한 것은?",
            q1 : '' ,
            a : ["P","queue","prarr","totque"],
            r : 1,
            img:'',
            summary:'call poissn(seed, mean, p) tpump(i) = p'
        },
        {//
            q : "다음중 prarr의 초기 값은?",
            q1 : '' ,
            a : ["1/3","2","4","20"],
            r : 1,
            img:'시뮬레이션22.JPG',
            summary:'초기 조건에 보면 고객은 시간당 20명이 도착한다 따라서 20/60 = 1/3이다'
        },
        {//
            q : "다음중 mean의 초기값은?",
            q1 : '' ,
            a : ["1/3","2","4","20"],
            r : 3,
            img:'',
            summary:'봉사시간은 평균(mean) 4분의 포아송분포이며 call poissn(seed, mean, p)로부터 알 수 있다.'
        },
        {//
            q : "다음중 tlimit의 초기값은?",
            q1 : '' ,
            a : ["4","20","300","23057"],
            r : 3,
            img:'',
            summary:'시뮬레이션 시간 =  300으로부터 알 수 있다.'
        },
        {//
            q : "다음 중 seed의 초기값은?",
            q1 : '' ,
            a : ["4","20","300","23057"],
            r : 4,
            img:'',
            summary:'난수의 초기값 = 23057'
        },
        {//
            q : "빈칸 가에 적당한 것은?",
            q1 : '' ,
            a : ["1","2","4","20"],
            r : 2,
            img:'',
            summary:'봉사창구 = 2 로부터 알 수 있다.'
        },
        {//
            q : "위 프로그램에서 평균 대기시간을 구하는 공식을 만들려고 한다 가장 적당한 것은?",
            q1 : '' ,
            a : ["totque/totarr","totque/arrive","totque/queue","totque/(tlimit/tstep)"],
            r : 1,
            img:'',
            summary:'평균 대기시간은 총대기시간 (totque)를 도착한 총고객수 (totarr)로 나눈 값이다.'
        },
        {//
            q : "12345를 초기값으로 갖는 변수는?",
            q1 : '' ,
            a : ["tlimit","prarr","seed","mean"],
            r : 3,
            img:'시뮬레이션23.JPG',
            summary:'난수의 초기값은 seed다 '
        },
        {//
            q : "0.5를 초기값으로 갖는 변수는",
            q1 : '' ,
            a : ["tstep","prarr","seed","mean"],
            r : 2,
            img:'',
            summary:'prarr이 도착확률임을 알수있다 . 고객은 시간당 30명이 도착하며 따라서 prarr = 30 / 60 = 0.5이다'
        },
        {//
            q : "200을 초기값으로 갖는 변수는?",
            q1 : '' ,
            a : ["tlimit","prarr","seed","mean"],
            r : 1,
            img:'',
            summary:'tlimit은 시뮬레이션 시간으로 while time<tlimit do로 알수있다.'
        },
        {//
            q : "3을 초기값으로 갖는 변수는?",
            q1 : '' ,
            a : ["tlimit","prarr","seed","mean"],
            r : 4,
            img:'',
            summary:'포아송 평균이 mean임을 알 수 있다.'
        },
        {//
            q : "현재 봉사하려는 고객의 봉사시간을 구한 것은?",
            q1 : '' ,
            a : ["p","queue","prarr","totque"],
            r : 1,
            img:'',
            summary:'포아송 확률변수 리턴값이 p임을 알수있으며 p는 고객의 봉사시간을 나타내는 포아송 확률변수이다.'
        },
        {//
            q : "평균 대기행렬 길이는?",
            q1 : '' ,
            a : ["aveque","queue","prarr","tpump"],
            r : 1,
            img:'',
            summary:'평균 대기행렬은 총대기시간 totque를 시뮬레이션한 전체 시간 tlimit 으로 나눈 값으로  totque/(tlimit/tstep)  여기서 tstep은 시뮬레이션 진행시간 단위인데 1분이므로 이 식에 영향을 미치지 못함'
        },
        {//
            q : "앞의 프로그램에서 평균 대기시간을 구하는 공식을 만들려고 한다. 가장 적당한 것은?",
            q1 : '' ,
            a : ["totque/totarr","totque/arrive","totque/queue","totque/(tlimit/tstep)"],
            r : 1,
            img:'',
            summary:'평균 대기시간은 총대기시간을totque 를 지금까지 도착한 총 고객 수 totarr로 나눈 값이다'
        },
        {//
            q : "35213을 초기값으로 갖는 변수는?",
            q1 : '' ,
            a : ["tlimit","prarr","seed","mean"],
            r : 3,
            img:'시뮬레이션24.JPG',
            summary:'난수의 초기값은 seed 이다.'
        },
        {//
            q : "0.25를 초기값ㅇ로 갖는 변수는?",
            q1 : '' ,
            a : ["tstep","prarr","seed","mean"],
            r : 2,
            img:'',
            summary:'초기 조건에서 보면 고객은 시간당 15명이 도착한다 . 따라서  15/60 = 1/4 = 0.25.'
        },
        {//
            q : "150을 초기 값으로 갖는 변수는?",
            q1 : '' ,
            a : ["tlimit","prarr","seed","mean"],
            r : 1,
            img:'',
            summary:'tlimit 은 시뮬레이션 시간이다.'
        },
        {//
            q : "5를초기 값으로 갖는 변수는",
            q1 : '' ,
            a : ["tlimit","prarr","seed","mean"],
            r : 4,
            img:'',
            summary:'봉사시간은 평균 5분의 포아송분포이다.'
        },
        {//
            q : "현재 본사하려는 고갱의 봉사시간을 구한 것은?",
            q1 : '' ,
            a : ["seed","mean","U","P"],
            r : 4,
            img:'',
            summary:'P는 포아송 확률변수 리턴값이다/ p는 고객의 봉사시간을 나타내는 포아송 확률변수임'
        },
        {//3.3 봉사시간의 변화
            q : "nmean의 값은?",
            q1 : '' ,
            a : ["1/10","3","21","25"],
            r : 3,
            img:'시뮬레이션25.JPG',
            summary:'연료탱크 = 평균 21l인 정규분포로 알수있음'
        },
        {//
            q : "stdev의 값은?",
            q1 : '' ,
            a : ["1/10","3","21","25"],
            r : 2,
            img:'',
            summary:'표준편차 3인 정규분포'
        },
        {//
            q : "tlimit의 값은",
            q1 : '' ,
            a : ["3","21","25","120"],
            r : 4,
            img:'',
            summary:'종료시간 = 120'
        },
        {//
            q : "위 프로그램에서 평균 대기시간을 구하는 공식을 만들려고 한다 가장 적당한 것은?",
            q1 : '' ,
            a : ["totque / totarr"," totque /arrive","totque/queue","totque/(tlimit/tstep)"],
            r : 1,
            img:'',
            summary:'평균 대기시간은 총 대기시간을 도착한 총고객수로 나눈값임'
        },
        {//
            q : "시뮬레이션 동안 한 변수의 값을 수집하여 도수분포표를 만들어 막대그래프로 표현해 보니 다음과 같은 모습이 되었다. 가장 관계 깊은 변수는?",
            q1 : '' ,
            a : ["nseed","nmean","stdev","liters"],
            r : 4,
            img:'시뮬레이션26.JPG',
            summary:'정규분포의 그림이다. liters는 정규확률변수이므로 그 값을 수집하여 도수분포표로 구성하여 막대그래프로 나타내면 정규분포와 비슷하게 된다.'
        },
        {//
            q : "다음중 봉사시간을 나타내는 변수는?",
            q1 : '' ,
            a : ["nseed","mean","stdev","tpump"],
            r : 4,
            img:'',
            summary:'tpump = 1.0 + 1.0 / 10 * liters에서  tpump가 봉사시간임을 알수있다.'
        },
        {//
            q : "prarr의 값은?",
            q1 : '' ,
            a : ["0.25","3","20","100"],
            r : 1,
            img:'시뮬레이션27.JPG',
            summary:'if ( U < (prarr * tstep)) then 에서 prarr은 시간당 평균 15대의 도착확률이므로 15/60 = 0.25이다.'
        },
        {//
            q : "nmean의 값은?",
            q1 : '' ,
            a : ["0.25","3","20","100"],
            r : 3,
            img:'',
            summary:'nmean은 정규분포의 평균'
        },
        {//
            q : "stdev의 값은?",
            q1 : '' ,
            a : ["0.25","3","20","100"],
            r : 3,
            img:'',
            summary:'stdev는 정규분포의 표준편차임을 알수있다.'
        },
        {//
            q : "tlimit의 값은?",
            q1 : '' ,
            a : ["0.25","3","20","100"],
            r : 4,
            img:'',
            summary:'tlimit은 종료시간이다.'
        },
        {//
            q : "난수의 초기값을 나타내는 변수는",
            q1 : '' ,
            a : ["tstep","prarr","seed","mean"],
            r : 3,
            img:'',
            summary:'seed가 난수의 초기값이다.'
        },
        {//
            q : "지금까지 도착한 총고객의 수를 표현하는 것은?",
            q1 : '' ,
            a : ["queue","totque","totarr","tpump"],
            r : 3,
            img:'',
            summary:''
        },
        {//
            q : "평균 대기시간을 구하는 것은?",
            q1 : '' ,
            a : ["totque","totarr","aveque","avgwt"],
            r : 4,
            img:'',
            summary:'평균 대기시간은 총대기시간을 도착한 총 고객수로 나눈 값이다.  totque/ totarr'
        },
        {//
            q : "다음 중 연료탱크의 크기를 나타내는 변수는?",
            q1 : '' ,
            a : ["nseed","nmean","stdev","liters"],
            r : 4,
            img:'',
            summary:'call normal(nseed, nmean, stdev, liters) 에서 liters는 연료탱크의 크기를 나타내는 변수임을 알 수 있다.'
        },
        {//3.4 대기시간
            q : "난수의 초기값을 나타내는 변수는?",
            q1 : '' ,
            a : ["tstep","prarr","seed","mean"],
            r : 3,
            img:'시뮬레이션28.JPG',
            summary:'난수의 초기값은 seed 이다.'
        },
        {//
            q : "고객의 도착 비율을 나타내는 변수는?",
            q1 : '' ,
            a : ["tstep","prarr","seed","mean"],
            r : 2,
            img:'',
            summary:'초기조건에 고객은 시간당 15명이도착함  15/60 = 0.25다'
        },
        {//
            q : "지금까지 도착한 총고객의 수를 표현하는 것은?",
            q1 : '' ,
            a : ["queue","totque","totarr","tpump"],
            r : 3,
            img:'',
            summary:'알고리즘을 보면 queue = queue + arrive  totarr = totarr + 1'
        },
        {//
            q : "totque를 가장 잘 설명한 것은",
            q1 : '' ,
            a : ["도착한 총 고객수","봉사를 마치고 출발한 총고객 수","매분 대기행렬의 길이를 누적한 값","매분 대기시간들을 누적한 값"],
            r : 3,
            img:'',
            summary:'알고리즘을 보면 매 tstep(=1분) 마다 queue(=대기행렬의 길이)를 더해주고있다.'
        },
        {//
            q : "현재 고객의 남은 봉사시간을 표현하는 것은?",
            q1 : '' ,
            a : ["queue","totque","totarr","tpump"],
            r : 4,
            img:'',
            summary:'알고리즘을 보면 tpump'
        },
        {//
            q : "고객의 도착비율을 구하기 위하여 일양확률변수를 발생하는 것은?",
            q1 : '' ,
            a : ["call random(Seed, U)","queue =queue + arrive","tpump = tpump - tstep","call poissn(seed, mean, p)"],
            r : 1,
            img:'',
            summary:'call random(seed, U)에서 볼 수 있듯이 U는 일양혹률변수이다.'
        },
        {//
            q : "고객의 봉사시간을 구하기 위해 포아송 확률변수를 ㅂ라생하는 것은?",
            q1 : '' ,
            a : ["call random(Seed, U)","queue =queue + arrive","tpump = tpump - tstep","call poissn(seed, mean, p)"],
            r : 4,
            img:'',
            summary:'p는 봉사시간을 나타내는 포아송 확률변수 값이다.'
        },
        {//
            q : "평균 대기행렬의 길이를 구하는 공식으로 빈칸 가에 적당한 것은?",
            q1 : '' ,
            a : ["totque / totarr"," totque/arrive","totque/queue","totque/(limit/tstep)"],
            r : 4,
            img:'',
            summary:'평균 대기행렬의 길이는 총대기시간을 시뮬레이션 시간으로 나눈 값이다. totque / (tlimit / tstep)'
        },
        {//
            q : "평균 대기시간을 구하는 공식으로 빈칸 나에 적당한 것은?",
            q1 : '' ,
            a : ["totque / totarr"," totque/arrive","totque/queue","totque/(limit/tstep)"],
            r : 1,
            img:'',
            summary:'평균 대기시간은 총대기시간을 도착한 총고객 수로 나눈 값이다.'
        },
        {//
            q : "봉사창구를 2개로 늘리려고 한다. 다음중 직접 관련되는 변수는?",
            q1 : '' ,
            a : ["queue","totque","tpump","totarr"],
            r : 3,
            img:'',
            summary:'tpump는 봉사창구가 하나인 경우 봉사시간을 나타내고, 창구가 2개가 된다면 tpump[1] tpump[2]등의 배열로 처리해야 한다.'
        },
        {//
            q : "첫번째 고객이 도착한 봉사시간은?",
            q1 : '' ,
            a : ["3","4","6","8"],
            r : 4,
            img:'시뮬레이션29.JPG',
            summary:'결과를 보면 11분에 첫 고객이 도착했고 봉사시간 tpump를 보면 8분임을 알 수 있다.'
        },
        {//
            q : "두번째 고객의 대기시간은?",
            q1 : '' ,
            a : ["3","4","5","6"],
            r : 3,
            img:'',
            summary:'두번째 고객은 14분에 도착했지만 앞서 고객이 봉사중이고 앞의 고객은 19분이 되어서야 봉사가 끝난다. 두번째 고객은 19분에 봉사를 시작하게 되므로 대기시간은  (앞고객 출발시간 - 두번째 고객 도착시간 ) 19-14 = 5 가된다.'
        },
        {//
            q : "처음으로 출발사건이 발생한 시간은",
            q1 : '' ,
            a : ["10","11","18","19"],
            r : 4,
            img:'',
            summary:'첫 고객은 11분에 도착해 8분간 봉사 받은 후에 출발하는데 그 시간은 결과로 보듯 19분이다.'
        },
        {//
            q : "출발사건과 도착사건이 동시에 발생한 시간은?",
            q1 : '' ,
            a : ["11","14","19","25"],
            r : 3,
            img:'',
            summary:'앞의 결과를 보면, 19분이 되었을 때 고객은 출발하고 queue에서 대기하던 고객이 봉사를 받게 되므로 queue가 0이 되어야 한다. 그런데 arrive값이 1로 되어있어 새로운 고객이 도착했다는걸 알 수 있다.'
        },
        {//
            q : "고객들에 대한 도착사건 발생시간을 구할 수가 있다. 순서대로 모두 구한 것은?",
            q1 : '' ,
            a : ["43, 46, 48","45, 47, 48","44, 45, 47, 51","44, 46, 49, 51"],
            r : 3,
            img:'시뮬레이션30.JPG',
            summary:'arrive에 1이 발생한 시간을 순서대로 찾으면 된다.'
        },
        {//
            q : "고객들에 대한 출발사건을 시간을 순서대로 모두 구한것은?",
            q1 : '' ,
            a : ["46,49","46, 49, 51","46, 49, 50, 52","46, 49, 51, 52"],
            r : 4,
            img:'',
            summary:'출발시간은 현재 고객의 봉사시간이 1씩 줄어들다가 0인 경우이며 이때 대기행렬에 기다리는 고객이 있으면 그 고객의 새로운 봉사시간으로 채워진다. 따라서 아래와 같다.'
        },
        {//
            q : "고객들에 대한 도착시간을 순서대로 구하면?",
            q1 : '' ,
            a : ["1,3,2,8","1,3,5,9","1,4,9,13","1,4,4,10"],
            r : 3,
            img:'시뮬레이션31.JPG',
            summary:'다음과 같이 arrive =1 인 경우를 찾으면 된다.'
        },
        {//
            q : "고객들에 대한 도착 간격을 순서대로 구하면",
            q1 : '' ,
            a : ["0,3,2,2","0,3,5,4","1,4,9,13","6,4,4,5"],
            r : 2,
            img:'',
            summary:'도착간격은  첫고객은 도착간격을 0으로 잡고 (뒷고객 도착시간 - 앞선 고객도착시간) =  도착간격 '
        },
        {//
            q : "고객들에 대한 봉사시간을 순서대로 구하면 ",
            q1 : '' ,
            a : ["0,3,2,2","0,3,5,4","1,4,9,13","6,4,4,5"],
            r : 4,
            img:'',
            summary:'출력결과에서 TPUMP에 나와있다. 봉사시간이 1분 지날때마다 tpump도 1분씩 감소하며 tpump가 0이된다는것은 봉사를 마치고 봉사창구를 출발했다는것이다. '
        },
        {//
            q : "고객들에 대한 출발시간을 순서대로 구하면",
            q1 : '' ,
            a : ["0,3,2,2","0,3,5,4","1,4,9,13","7,11,15,20"],
            r : 4,
            img:'',
            summary:'출발시간 공식은  =  봉사시작한 시간(앞선고객의 출발시간) + 봉사시간'
        },
        {//
            q : "고객들에 대한 대기시간을 순서대로 구하면",
            q1 : '' ,
            a : ["0,3,2,2","0,3,5,4","1,4,9,13","6,4,4,5"],
            r : 1,
            img:'',
            summary:'대기시간 공식 =  앞의고객 출발시간 -  지금고객 도착시간'
        },
        {// 4장 시뮬레이션 모델링 -> 개요
            q : "다음은 무엇에 관한 설명인가?",
            q1 : '' ,
            a : ["시스템","시뮬레이터","월드뷰","확률변수"],
            r : 3,
            img:'시뮬레이션32.JPG',
            summary:'모델링 월드뷰에 관한 설명이다.'
        },
        {// 모델링 월드뷰
            q : "다음은 이산형 시뮬레이션에 대한 설명중 틀린 것은?",
            q1 : '' ,
            a : ["시뮬레이션 시간에서 종속변수가 사건발생시간이라고 불리는 특정한 시간에 이산적으로 변화할 경우에 해당한다. 이 경우 모델에서 시간변수는 연속적일 수도 있고 이산적일 수도 있다.","주요 종속변수에서의 이산적 변화가 어떤 시간에도 일어날 수 있으면 이산형 모델이 되고, 명시된 순간에만 일어날 수 있으면 연속형 모델이 된다.","대기행렬 시스템은 이산형 시뮬레이션에 해당된다. 이 예에서 종속변수는 대기행렬 내의 고객 수가 된다. 사건발생시간은 시스템에 고객이 도착하는 시간과 떠나는 시간이 된다.","일반적으로 이산형 모델의 종속변수 값은 사건발생시간 사이에는 변하지 않는다."],
            r : 2,
            img:'',
            summary:'종속변수에서의 이산적 변화가 어떤 시간에도 일어날 수 있으면 연속형 모델이 되고 명시된 순간에만 일어날 수 있으면 이산형 모델이 된다.'
        },
        {//4.3 이산형 시뮬레이션 모델링
            q : "정의된 형태에서 발생하는 요소들의 순서에 의하여 모델링 하는 방법은?",
            q1 : '' ,
            a : ["사건중심","프로세스 중심","액티비티 관찰중심","시스템 접근"],
            r : 2,
            img:'',
            summary:'프로세스 중심 진행방법에서 시뮬레이션 모델물은 정의된 형태에서 발생하는 요소들의 순서를 포함한다. 예를 들어 봉사 프로세스를 기다리는 엔티티들의 대기열은 이러한 요소들의 순서로 볼 수 있다. 이러한 사건들의 순서와 관련된 논리는 일반화 될 수 있고, 하나의 문장에 의하여 정의될 수 있다.'
        },
        {//
            q : "이산형 시뮬레이션 모델링에 대한 세가지 월드뷰이다 관계없는 것은?",
            q1 : '' ,
            a : ["사건중심","프로세스 중심","액티비티 관찰중심","시스템접근"],
            r : 4,
            img:'',
            summary:'모델링에 대한 세가지 월드 뷰 :  사건중심 , 프로세스 중심, 액티비티 관찰중심'
        },
        {//
            q : "이산형 시뮬레이션 모델링에 대한 세가지 월드뷰이다 관계없는 것은?",
            q1 : '' ,
            a : ["사건중심 진행","프로세스 중심","액티비티 관찰중심","채택 - 기각법"],
            r : 4,
            img:'',
            summary:'채택 기각법은 확률변수 발생방법이다.'
        },
        {//
            q : "이산형 시뮬레이션 모델링에 대해 잘못 설명한 것은?",
            q1 : '' ,
            a : ["시스템 상태는 사건 발생시간에만 변할 수 있다.","모델들은 상탭녀수들의 도함수로 표현된다.","액티비티의 시작과 끝나는 시점에 사건이 발생한다.","프로세스는 시간에 따라 정렬된 사건들의 순서이다."],
            r : 2,
            img:'',
            summary:'연속형 시뮬레이션 모델링에서 모델들은 상태변수들의 도함수로 표현된다.'
        },
        {//
            q : "대기행렬 문제에서 고객의 도착이나 출발과 관계있는 것은?",
            q1 : '' ,
            a : ["사건","프로세스","액티비티","애트리뷰트"],
            r : 1,
            img:'',
            summary:'대기행렬 문제는 사건중심이다. 고객의 도착사건과 출발사건이 중심이 된다.'
        },
        {//
            q : "사건중심 방법으로 진행하는 경우 고객이 도착했을 때의 논리와 관계없는 것은?",
            q1 : '' ,
            a : ["다음 도착사건 계획","봉사자가 쉬는 상태이면 바쁜 상태로 전환한다","대기열에 있는 고객 수를 하나 제외한다","봉사자가 쉬는 상태이면 봉사시간을 계획한다"],
            r : 3,
            img:'',
            summary:'봉사창구에 있는 고객에 대한 봉사시간이 완료되면 그 고객은 출발한다. 즉 출발사건이 발생한다. 이때 봉사창구는 비어 있게 되므로 대기행렬을 살펴보고 기다리고 있는 고객이 있으면 대기행렬에서 고객 수를 하나 제외하고 그 고객에 대한 봉사가 시작된다.'
        },
        {//
            q : "다음 이산형 시뮬레이션에 대한 설명 중 틀린 것은?",
            q1 : '' ,
            a : ["종속변수에서의 이산적 변화가 어떤 시간에도 일어날 수 있으면 이산형 모델이 되고 , 명시된 순간에만 일어날 수 있으면 연속형 모델이 된다.","시뮬레이션 시간에서 종속변수가 사건발생시간이라고 불리는 특정한 시간에 이산적으로 변화할 경우에 해당한다. 이 경우 모델에서 시간변수는 연속적일 수도 있고 이산적일 수도 있다.","대기행렬 시스템은 이산형 시뮬레이션에 해당된다. 이 예에서 종속변수는 대기행렬 내의 고객 수가 된다. 사건발생시간은 시스템에 고객이 도착하는 시간과 떠나는 시간이 된다.","일반적으로 이산형 모델의 종속변수 값은 사건발생시간 사이에는 변하지 않는다"],
            r : 1,
            img:'',
            summary:'종속변수에서의 이산적 변화가 어떤 시간에도 일어날 수 있으면 연속형 모델이 되고 명시된 순간에만 일어날 수 있으면 이산형 모델이 된다.'
        },
        {//4.4 연속형 시뮬레이션 모델링
            q : "시스템의 모델이 상태변수들의 도함수로 표현되는 것과 가장 관계가 있는 것은?",
            q1 : '' ,
            a : ["연속형 모델","이산형 모델","혼합형 모델","확률적 모델"],
            r : 1,
            img:'',
            summary:'연속형 시뮬레이션 모델에서 시스템 상태는 시간에 따라 연속적으로 변하는 종속변수에 의해 표현된다.'
        },
        {//
            q : "다음중 연속형 시뮬레이션 모델링인 경우는?",
            q1 : '' ,
            a : ["대기행렬 시스템","화학공종에서 반응물질의 농도나 우주선의 위치와 속도를 모델링 하는 경우","호수에 화학약품을 살포하는 경우 호수에 서식하는 특수한 종류의 수가 순간적으로 감소할 수 있다.","우주선이 결합을 완료하면 우주선의 비행을 시뮬레이션 하는 방정식은 결합 전의 방정식과는 다르게 바뀌어야 한다."],
            r : 2,
            img:'',
            summary:'화학공정에서 반응물질의 농도나 우주선의 위치와 속도에서 종속변수는 연속적으로 변화하는 농도나 공의 움직임이므로 연속형이다.'
        },
        {// 4.5 혼합형 시뮬레이션 모델링
            q : "다음 모델링 월드뷰에 대한 설명중 틀린 것은?",
            q1 : '' ,
            a : ["시뮬레이션 모델을 설계할 때 설계자는 모델 대상이 되는 실시스템을 잘 표현하기 위하여 개념적인 기본구조(frame work)를 갖고 있어야 한다.","이 기본구조는 실시스템의 기능적인 관계를 잘 이해해서 그것을 표현할 수 있는 전체적인 시각인 월드뷰 에 의하여 결정된다.","만일 모델 설계자가 시뮬레이션 언어를 사용한다면 기본구조는 시뮬레이션 언어에 의해 자연스럽게 표현된다. ","혼합형 시뮬레이션 모델링의 경우 사건중심 진행방법, 액티비티 관찰중심방법, 프로세스 중심 진행방법들이 있다."],
            r : 4,
            img:'',
            summary:'이산형 시뮬레이션 모델링의 경우  -> 사건중심 진행방법, 액티비티 관찰중심 진행방법, 프로세스 중심 진행방법들이 있다.'
        },
        {//
            q : "다음중 혼합형 시뮬레이션 모델링에 속하는 것은?",
            q1 : '' ,
            a : ["미분방정식으로 표현된다","은행 문제에서 고객의 대기시간을 측정하는 문제","공을 던졌을때 튀는 과정을 표현하는 문제","생태계로 공해물질이 방출되면 서식하는 개체군의 성장률을 변화시킨다"],
            r : 4,
            img:'',
            summary:'생태계 개체군의 성장률은 연속형으로 늘어나거나 줄어든다. 공해물질이 방출되면, 즉 성장률의 공식이 연속형으로 진행되다가 순간적으로 이산적인 변화를 가져오고 그 후 다시 새로운 변화된 공식에 의해서 연속형 성장률을 갖게 된다.'
        },
        {//
            q : "다음중 혼합형 시뮬레이션 모델링이 아닌 경우는?",
            q1 : '' ,
            a : ["대기행렬 시스템에서 창구가 2개로 늘어나는 경우","화학공정에서 반응물질의 농도가 규정된 수준에 도달한 경우","호수에 화학약품을 살포하는 경우 호수에 서식하는 특수한 종류의 수가 순간적으로 감소할 수 있다.","우주선이 결합을 완료하면 우주선의 비행을 시뮬레이션 하는 방정식은 결합 전의 방적식과는 다르게 바뀌어야 한다."],
            r : 1,
            img:'',
            summary:'대기행렬 시스템은 이산형모델로 창구가 늘어나도 마찬가지이다.'
        },
        {//5장 이산사건 시뮬레이션 84페이지 - 132
            q : "다음중 고정시간 진행법의 특징은?",
            q1 : '' ,
            a : ["이산사건 시뮬레이션에 적당하다","처리 고객 수를 미리 알 수 없다","처리 시간 수를 미리 알 수 없다","마지막 고객에 의하여 종료된다."],
            r : 2,
            img:'',
            summary:'고정시간 진행법에서는 시뮬레이션 종료 조건을 시간으로 준다. 따라서 처리 고객 수를 미리 알 수 없다.'
        },
        {//
            q : "다음 중 다음사건시간 진행법과 관계없는 것은?",
            q1 : '' ,
            a : ["사건이 발생하면 시간을 진행시킨다.","최종 시뮬레이션 시간은 고정된다.","고정시간 진행법과 반대되는 개념이다","시뮬레이션 증가시간이 일정하지 않다."],
            r : 2,
            img:'',
            summary:'다음사건시간 진행법은 마지막 고객의 도착이나 처리 등으로 종료조건을 정한다. 그러므로 시간을 미리 알 수 없어, 최종 시뮬레이션 시간을 정할 수 없는 것이다.'
        },
        {//
            q : "다음은 시간 진행법에 대한 설명이다. 틀린 것은?",
            q1 : '' ,
            a : ["다음사건시간 진행법에서는 사건이 발생하면 시간을 진행시킨다.","고정시간 진행법에서는 종료조건으로 처리 고객 수가 정해진다","고정시간 진행법에서는 고정된 시간만큼 시계를 진행시킨다","다음사건시간진행법에서는 시뮬레이션 증가시간이일정하지 않다."],
            r : 2,
            img:'',
            summary:'고정시간 진행법에서는 종료조건으로 종료시간이 정해진다.'
        },
        {//
            q : "다음은 시간 진행법에 대한 설명이다 틀린 것은?",
            q1 : '' ,
            a : ["다음 사건시간 진행법에서는 사건이 발생하면 시간을 진행시킨다. ","고정시간 진행법에서는 종료조건으로 시간이 정해진다","고정시간 진행법에서는 고정된 시간만큼 시계를 진행시킨다","이산사건 모델링은 고정시간 진행법을 사용한다."],
            r : 4,
            img:'시뮬레이션33.JPG',
            summary:'이산사건 모델링은 사건중심이므로 사건이 일어날 때마다 시뮬레이션이 진행되는 다음사건시간 진행법을 사용하게 된다. '
        },
        {//5.4 이산사건 시뮬레이션의 예
            q : "빈칸의 도착간격을 구하면?",
            q1 : '' ,
            a : ["1,2,2","1,2,3","2,1,4","2,3,7"],
            r : 3,
            img:'시뮬레이션34.JPG',
            summary:'도착간격은 앞사람과의 시간간격임 내 도착시간 - 앞사람도착시간 '
        },
        {//
            q : "빈칸의 출발시간을 구하면?",
            q1 : '' ,
            a : ["5,5,9","8,10,12","7,10,17","10,13,15"],
            r : 2,
            img:'',
            summary:''
        },
        {//
            q : "빈칸의 대기시간을 구하면?",
            q1 : '' ,
            a : ["3,5,3","5,8,10","6,7,5","6,9,8"],
            r : 1,
            img:'',
            summary:''
        },
        {//
            q : "빈칸의 도착간격을 구하면",
            q1 : '' ,
            a : ["2,3,2","2,3,3","3,3,5","9,13,15"],
            r : 1,
            img:'시뮬레이션35.JPG',
            summary:'도착간격 =  내 도착시간 - 앞 고객도착시간 '
        },
        {//
            q : "빈칸의 출발시간을 구하면?",
            q1 : '' ,
            a : ["8,11,13","9,12,14","9,13,15","9,13,16"],
            r : 2,
            img:'',
            summary:''
        },
        {//
            q : "빈칸의 대기시간을 구하면",
            q1 : '' ,
            a : ["3,3,3","3,3,4","3,3,5","3,4,6"],
            r : 2,
            img:'',
            summary:''
        },
        {//
            q : "도착사건과 출발사건이 동시에 일어나는 시간은?",
            q1 : '' ,
            a : ["6","9","13","15"],
            r : 1,
            img:'',
            summary:'시간 = 6일때 고객 1의 출발사건이 일어난다 그리고 고객 3의 도착사건이 동시에 발생함'
        },
        {//
            q : "빈칸의 출발시간을 구하면?",
            q1 : '' ,
            a : ["7,9,12","9,15,18","10,13,15","10,15,18"],
            r : 1,
            img:'시뮬레이션36.JPG',
            summary:'출발시간은 도착시간에 봉사시간을 더하면 됨. 앞의 고객이 대기하고 있으면 이들이 모두 봉사를 마칠때까지 기다려야함  이경우 앞의 고객 출발시간에 자기 봉사시간을 더한다.'
        },
        {//
            q : "현재시간 9에서 평균 대기행렬의 길이를 구하면?",
            q1 : '' ,
            a : ["1/4","1/3","5/9","1/2"],
            r : 3,
            img:'',
            summary:'평균 대기행렬 길이는 총대기시간/ 시간 = 5/9    위 문제에서 모든 고객의 대기시간을 구해야한다.   모든 고객의 대기시간을 더하면 5가 나옴'
        },
        {// 5.5 전체 알고리즘 97쪽
            q : "시뮬레이션 종료조건으로 처리해야할 총 고객 수는?",
            q1 : '' ,
            a : ["totarr","timing","next","numcus"],
            r : 1,
            img:'시뮬레이션37.JPG',
            summary:'totarr는 처리해야 할 총고객 수로 종료조건이다. 참고로 numcus는 지금까지 봉사를 시작한 총 고객 수이다.'
        },
        {//
            q : "현재 고객의 봉사시간을 구하려고 한다. 관계 없는 것은?",
            q1 : '' ,
            a : ["nseed","e_dep","marrvt","mservt"],
            r : 3,
            img:'',
            summary:'봉사시간과 관계있는 변수는 call expon(nseed, mservt, e_dep)으로부터 알 수 있다. marrvt는 도착간격을 구할때 사용하는 평균값이다.'
        },
        {//
            q : "다음에 도착하는 고객의 시간은?",
            q1 : '' ,
            a : ["e_arr","e_dep","tne[1]","tne[2]"],
            r : 3,
            img:'',
            summary:'tne[1] = time + e_arr   로부터 알수있다. 고개의 도착간격시간을 구한것이 e_arr이므로 현재시간 time에다 더해주면 다음 고객의 도착시간이 구해진다.'
        },
        {//
            q : "대기시간 계산을 위하여 직전사건시간을 나타내며, 다음 사건 발생 시 대기시간 계산을 위하여 현재사건시간을 저장하는 변수는?",
            q1 : '' ,
            a : ["totque","tlevnt","tne[2]","e_dep"],
            r : 2,
            img:'시뮬레이션38.JPG',
            summary:'tlevnt = time 으로부터 알 수 있다.'
        },
        {//
            q : "고객의 평균 봉사시간이 지수확률변수로 나타내진다. 지수확률변수의 평균은?",
            q1 : '' ,
            a : ["time","queue","mservt","e_dep"],
            r : 3,
            img:'',
            summary:'call expon(nseed, mservt, e_dep) 으로부터 mservt를 알 수 있다.'
        },
        {//
            q : "평균 도착간격 시간을 나타내는 변수는?",
            q1 : '' ,
            a : ["marrvt","mservt","totarr","numcus"],
            r : 1,
            img:'시뮬레이션39.JPG',
            summary:'marrvt = 5 평균 도착간격시간   mservt =2.5  평균 봉사시간'
        },
        {//
            q : "난수의 초기값을 설정해주는 곳은?",
            q1 : '' ,
            a : ["init","timing","arrive","depart"],
            r : 1,
            img:'',
            summary:'부프로그램 init은 사용되는 변수들에 대한 초기값을 설정한다.'
        },
        {//
            q : "현재까지 봉사를 시작한 고객의 수는?",
            q1 : '' ,
            a : ["totarr","timing","next","numcus"],
            r : 4,
            img:'',
            summary:'totarr는 처리해야할 총고객수로 종료조건이고, numcus는 지금까지 봉사를 시작한 총 고객수다.'
        },
        {//
            q : "다음에 도착하는 고객의 시간을 나타내는 변수는?",
            q1 : '' ,
            a : ["tne[1]","tne[2]","e_arr","e_dep"],
            r : 1,
            img:'시뮬레이션40.JPG',
            summary:'call expon(seed, marrvt, e_arr) tne[1] = time + e_arr  로부터 알 수 있듯 고객의 도착간격시간을 구한것이 e_arr이므로 현재시간에다 더해주면 다음 고객의 도착시간이 구해짐'
        },
        {//
            q : "현재 고객의 출발시간을 나타낸느 변수는?",
            q1 : '' ,
            a : ["tne[1]","tne[2]","e_arr","e_dep"],
            r : 2,
            img:'',
            summary:'고객의 봉사시간을 구한것이 e_dep이므로 , 현재시간 time에다 더해주면 고객의 출발시간이 구해짐'
        },
        {//
            q : "바로 직전에 사건이 일어난 시간을 나타내는 변수는?",
            q1 : '' ,
            a : ["tne[1]","tne[2]","tlevnt","time"],
            r : 3,
            img:'',
            summary:'tlevnt는 바로 직전에 일어난 도착 또는 출발사건 시간을 저장하는 변수이다. 다음과 같이 총대기시간을 계산하는데 사용된다 totque = totque + queue * (time - tlevnt)'
        },
        {// 102페이지 52파일임
            q : "고객의 출발 사건을 처리하는 부프로그램은?",
            q1 : '' ,
            a : ["init","time","arrive","depart"],
            r : 4,
            img:'시뮬레이션41.JPG',
            summary:'if(next=1) then call arrive  else  call depart 로부터 알수 있음'
        },
        {//
            q : "평균 봉사시간을 나타내는 변수는?",
            q1 : '' ,
            a : ["marrvt","mservt","totarr","numcus"],
            r : 2,
            img:'',
            summary:'mservt = 2.5 평균 봉사시간'
        },
        {//
            q : "프로그램 종료조건으로 총 고객수를 나타내는 변수는?",
            q1 : '' ,
            a : ["totarr","timing","next","numcus"],
            r : 1,
            img:'',
            summary:'totarr는 처리해야 할 총고객 수로 종료조건이다 참고로 numcus는 지금까지 봉사를 시작한 총 고객 수읻.'
        },
        {//15번문제임
            q : "다음에 도착하는 고객의 도착간격시간을 나타내는 변수는?",
            q1 : '' ,
            a : ["tne[1]","tne[2]","e_arr","e_dep"],
            r : 3,
            img:'시뮬레이션42.JPG',
            summary:'call expon(seed, marrvt, e_arr)로 알수있다.'
        },
        {//
            q : "현재 고객의 봉사시간을 나타내는 변수는?",
            q1 : '' ,
            a : ["tne[1]","tne[2]","e_arr","e_dep"],
            r : 4,
            img:'',
            summary:'call expon(nseed. mservt, e_dep)로부터 알 수 있다.'
        },
        {//
            q : "고객의 도착사건을 처리하는 부프로그램은?",
            q1 : '' ,
            a : ["init","time","arrive","depart"],
            r : 3,
            img:'시뮬레이션43.JPG',
            summary:'arrive에서도착사건을 처리한다.'
        },
        {//
            q : "시뮬레이션 변수들에 대한 초기화를 하는 부프로그램은?",
            q1 : '' ,
            a : ["init","time","arrive","depart"],
            r : 1,
            img:'',
            summary:'init에서 모든 변수에 대한 초기화를 한다.'
        },
        {//
            q : "지금까지 봉사를 시작한 총 고객 수는?",
            q1 : '' ,
            a : ["totarr","timing","next","numcus"],
            r : 4,
            img:'',
            summary:'totarr는 처리해야할 총 고객 수로 종료조건 , numcus는 지금까지 봉사를 시작한 총 고객 수이다.'
        },
        {//6장 시뮬레이션 언어
            q : "다음중 시뮬레이션 전용 언어가 아닌 것은?",
            q1 : '' ,
            a : ["GASP","DYNAMO","SLAM","Visual Basic"],
            r : 4,
            img:'',
            summary:'비쥬얼 베이직은 윈도우 프로그램 언어로 범용언어이다.'
        },
        {//
            q : "다음중 시뮬레이션 전용언어가 아닌 것은?",
            q1 : '' ,
            a : ["JAVA","SIMSCRIPT","AutoMod","ProModel"],
            r : 1,
            img:'',
            summary:'JAVA는 범용언어이다.'
        },
        {//
            q : "다음중 시뮬레이션 전용 언어가 아닌 것은?",
            q1 : '' ,
            a : ["AweSim","ProModel","AutoMod","Visual C++"],
            r : 4,
            img:'',
            summary:'Visual c++은 윈도우 프로그래밍 언어로 범용언어다.'
        },
        {//
            q : "대기행렬 시스템을 시뮬레이션 언어를 이용하여 시뮬레이션 하려고 한다. Create노드 await노드 Resource 노드 Fee노드 Collect 노드 등을 이용하여 아래와 같이 설계했다. 다음중 관계있는 시뮬레이션 언어는?",
            q1 : '' ,
            a : ["AweSim","GASP","OPNET","GPSS"],
            r : 1,
            img:'시뮬레이션44.JPG',
            summary:'Awesim은 slam의 상위버전으로 대기행렬 시스템 설계에 create노드 awaite노드 resource노드 free노드 collect노드 등의 그래픽 노드를 제공하는 언어이다.'
        },
        {//
            q : "시뮬레이션 언어 중에서 FORTRAN 부 프로그램의 확장으로 이루어진 것은?",
            q1 : '' ,
            a : ["GASP","DYNAMO","SLAM","SIMSCRIPT"],
            r : 1,
            img:'',
            summary:'GASP는 fortran으로 짜였기 때문에 fortran 컴파일러를 가진 거의 모든 컴퓨터에서 이용이 가능하다. gasp는 23개의 fortran 서브루틴과 함수로 구성되는 사건중심 시뮬레이션 언어이다. '
        },
        {//
            q : "대규모 경제 시스템을 시뮬레이션 하는데 적당한 것은?",
            q1 : '' ,
            a : ["GASP","DYNAMO","SLAM","SIMSCRIPT"],
            r : 2,
            img:'',
            summary:'Dynamo 는 phyllis fox와 a L Pugh가 mit에서 미분방적식의 집합에 의해 묘사될 수 있는 어떤 동적 정보귀환 시스템을 시뮬레이션 할 목적으로 만들어 낸 특수목적 시뮬레이션 언어이다. dynamo는 대체로 통계경제 모델과 같은 큰 규모의 경제 시스템을 시뮬레이션 하기 위해 사용되어 왔다. 생물학 물리학 사회학과 같은 기타 다른 분야에서도 이용할 수 있다.'
        },
        {//
            q : "SLAM의 상위 버전으로 대기행렬 시스템 설계에 create노드 await노드 resource노드 free노드 collect노드 등의 그래픽 노드를 제공하는 언어는?",
            q1 : '' ,
            a : ["DYNAMO","GASP","AweSim","GPSS"],
            r : 3,
            img:'',
            summary:'awesim에 대한 설명임'
        },
        {//
            q : "다음 시뮬레이션 언어 중 ASI 회사에서 개발되어 manufacturing에 적합한 언어로 물류진단, 공장설비 진단 등에 응용되며 3차원 그래픽 에니메이션의 기능을 갖고 있는 언어는?",
            q1 : '' ,
            a : ["DYNAMO","AutoMod Ⅱ","AWESIM","GPSS"],
            r : 2,
            img:'',
            summary:'automod Ⅱ 는 생산시설 설계 및 평가를 위하여 ASI(auto simulations inc.) 에서 개발되었음. 복잡한 물류시스템의 상호작용을 실험함으로써 생산시설 변경이 실제로 이루어지기 전에 예상하지 못한 문제점을 확인하거나 최선의 해결방은 마련 등으로 설계점의 향상을 기할 수 있게 한다.'
        },
        {// 6.4 범용 고급언어와 시뮬레이션 언어 비교
            q : "다음은 시뮬레이션 언어에 대한 설명이다 틀린 것은?",
            q1 : '' ,
            a : ["시뮬레이션 모델을 설계하기 위한 일반화된 구조를 제시한다.","시뮬레이션 모델을 다시 컴퓨터 프로그램으로 바꾸는 신속한 방법을 제시한다.","시뮬레이션 모델의 변경이 용이하고 이와 같은 변경이 기계어 프로그램으로 즉시 적용될 수 있게 한다.","산출되는 출력 보고서의 형태를 자유롭게 작성할 수 있다."],
            r : 4,
            img:'',
            summary:'범용언어는 자유롭게 출력 보고서의 형태를 바 꿀 수 있지만. 시뮬레이션 언어는 정해진 양식으로만 출력된다. 그러나 훨씬 많은 정보가 출력된다.'
        },
        {//
            q : "시뮬레이션 언어의 장점은?",
            q1 : '' ,
            a : ["대부분의 사용자들이 잘 알고 있다.","프로그램 수행시간이 적다","프로그램밍 시간을 감소시킨다.","복잡한 수치계산 등 많은 융통성을 제공한다."],
            r : 3,
            img:'',
            summary:'시뮬레이션 언어는 일반화된 모델링 구조를 제공하므로 프로그래밍 시간이 적게 걸리고 오류 검출도 쉽다.'
        },
        {//
            q : "다음중 범용 고급언어로 시뮬레이션 할때 장점이 아닌 것은?",
            q1 : '' ,
            a : ["대부분의 사용자들이 알고 있다.","fortran 이나 basic 등은 거의 모든 컴퓨터에서 이용이 가능하다.","시뮬레이션 언어로 작성된 프로그램보다 수행시간이 적다,","프로그래밍 하는데 소요되는 시간이 적다."],
            r : 4,
            img:'',
            summary:'범용언어는 프로그래밍 하는데 소요되는 시간이 시뮬레이션 언어보다 많이 걸린다.'
        },
        {//
            q : "다음중 범용언어의 장점은?",
            q1 : '' ,
            a : ["시뮬레이션 모델 설계에 일반화된 구조를 제공한다.","사용자가 사용하기 쉽고 융통성이 많다","모델링과 프로그래밍 시간이 적게 걸린다","출력결과를 다양한 그래픽과 애니메이션으로 표현한다."],
            r : 2,
            img:'',
            summary:'fortran , basic, pascal, c 드으이 범용언어는 대부분 컴퓨터에서 사용하기 쉽다.  그러나 시뮬레이션 언어는 특별히 설치해야하며 그래픽 처리나 에니메이션 등을 위해서 요구하는 시스템 사양도 높은 편이다.'
        },
        {//
            q : "다음중 범용언어로 시뮬레이션 할때 장점이 아닌 것은?",
            q1 : '' ,
            a : ["대부분의 사용자들이 알고 있다.","C, c++ , java 등 거의 모든 컴퓨터에서 이용이 가능하다.","시뮬레이션 언어로 작성된 프로그램보다 수행시간이 적다.","프로그래밍 하는데 소요되는 시간이 적다."],
            r : 4,
            img:'',
            summary:'범용언어는 프로그래밍하는 데 소요되는 시간이 시뮬레이션 언어보다 많이 걸린다.'
        },
        {//
            q : "시뮬레이션 언어의 장점이 아닌 것은?",
            q1 : '' ,
            a : ["프로그래밍 시간을 감소시킨다.","작성된 프로그램을 다시 수정하기 쉽다.","복잡한 수치계산 등 많은 융통성을 제공한다.","오류검출이 쉽다."],
            r : 3,
            img:'',
            summary:'복잡한 수치계산 등 언어에 따라 제공되지 않는 기능을 사용하기 어렵다. 반면에 범용언어는 무엇이든 프로그래밍만 하면 되므로 오히려 많은 융통성을 제공한다.'
        },
        {//
            q : "다음은 범용언어와 시뮬레이션 언어에 대한 설명이다 틀린 것은?",
            q1 : '' ,
            a : ["시뮬레이션 언어는 모델을 설계하기 위한 일반화된 구조를 제시한다.","시뮬레이션 언어는 프로그래밍 시간이 적고 출력 보고서의 형태도 자유롭게 작성할 수 있다.","시뮬레이션 언어는 모델 설계 및 변경이 용이하고 이와 같은 변경이 기계어 프로그램으로 즉시 적용될 수 있게 한다.","범용언어는 C, PASCAL, JAVA, BASIC 등으로 사용자가 사용하기 쉽고 융통성이 많다. 또한 거의 모든 컴퓨터에서 이용이 가능하다."],
            r : 2,
            img:'',
            summary:'범용언어는 자유롭게 출력 보고서의 형태도 변경이 가능한데 시뮬레이션 언어는 정해진 양식으로만 출력된다. 그러나 훨신 많은 정보가 출력된다.'
        },
        {//7장 난수의 발생
            q : "U[0 , 1)의 난수를 발생시키는 데 사용되는 분포는?",
            q1 : '' ,
            a : ["일양분포","이항분포","정규분포","지수분포"],
            r : 1,
            img:'',
            summary:'U[0,1)은 0과 1사이의 범위에서 일양분포의 성격을 갖는 일양 확률변수들이다.'
        },
        {//
            q : "컴퓨터를 사용하여 난수를 발생시키는 경우 갖추어야 할 점이 아닌 것은?",
            q1 : '' ,
            a : ["일양분포를 만족해야 한다","임의적이어야 한다","상관관계가 높아야 한다","반복발생이 가능해야 한다./"],
            r : 3,
            img:'',
            summary:'상관관계가 없어야 한다.'
        },
        {//
            q : "컴퓨터를 사용하여 난수를 발생시키는 경우 갖추어야 할 점이 아닌 것은?",
            q1 : '' ,
            a : ["반복발생이 불가능해야 한다.","상관관계가 없어야 한다","난수의 발생속도가 빨라야 한다.","[0,1) 범위에서 일양분포를 만족해야 한다."],
            r : 1,
            img:'',
            summary:'같은 난수들을 언제든지 발생시킬 수 있어야 한다. 그래야 난수의 성질을 정정할 수 있다.'
        },
        {//
            q : "컴퓨터를 사용하여 난수를 발생시키는 경우 갖추어야 할 점이 아닌 것은?",
            q1 : '' ,
            a : ["반복발생이 가능해야 한다.","상관관계가 있어야 한다.","난수의 발생속도가 빨라야 한다.","[0,1) 범위에서 일양분포를 만족해야 한다."],
            r : 2,
            img:'',
            summary:'상관관계가 없어야 한다.'
        },
        {//
            q : "중앙이승법을 사용하여 X0=1009일때 X1을 구하면?",
            q1 : '' ,
            a : ["180","1018","8081","1018081"],
            r : 1,
            img:'',
            summary:'제곱한 후에 중앙값을 취한다 = 1009 * 1009 = 01018081 = 중앙의 값 0180  = 180'
        },
        {//
            q : "중앙 이승법을 사용하여 X0 = 1001 (2진법)일때 X1을 구하면?",
            q1 : '' ,
            a : ["10","100","1010","10001"],
            r : 2,
            img:'',
            summary:'제곱한 후에 중앙값을 취한다   1001 * 1001 = 1010001  = 중앙값 0100 = 100 중앙 자릿수 결정 : X0가 4자리이니 제곱결과에서 중앙의 4자리를 취함  중앙 자리 추출은 정중앙의 숫자를 택하는것임' 
        },
        {//
            q : "중앙이승법을 사용하여 x0 = 1010 (2진법)일때 X1을 구하면?",
            q1 : '' ,
            a : ["1001","1101","1010","1011"],
            r : 1,
            img:'',
            summary:'1010 * 1010 = 1100100 = 1001'
        },
        {// 합동법
            q : "계수가 m인 승산식 합동법에서 최대주기는?",
            q1 : '' ,
            a : ["m","m - 1","m + 1","m/4"],
            r : 2,
            img:'',
            summary:'승산식 합동법은 c = 0 인 경우로서 xi = aXi -1 (mod m)이다. 승산식 합동법의 방법은 c가 없으므로 계산이 더 빠르다는 장점이 있지만 c=0으로 최대주기를 가질수 없다. 단  m과 a의 값을 적당하게 취하면 최대주기 p = m -1 을 가질 수 있다.'
        },
        {//
            q : "다음 난수발생식에 대한 설명중 옳지 않은 것은?",
            q1 : '' ,
            a : ["컴퓨터에 의하여 임의적인 난수를 발생 시킬 수 있다.","xi가 결정적으로 구해진다는 문제가 있다","구해진 난수 Ui가 유리수 값만을 취한다","m의 값을 크게 할수록 좋다"],
            r : 1,
            img:'시뮬레이션45.JPG',
            summary:'구해진 Xi는 임의적이 아니다. 그러나 네가지 변수를 적절하게 선택함으로서 발생되는 Ui가 임의의 일양분포를 하는 것처럼 보이게 할 수 있다. 합등법은 대수적인 방법으로 두가지 문제점이 제기될 수 있다.'
        },
        {//
            q : "이 방법의 이름은?",
            q1 : '' ,
            a : ["중앙이승법","shift 연산법","승산식 합동법","혼합식 합동법"],
            r : 4,
            img:'시뮬레이션46.JPG',
            summary:'Xi-aXi-1 + c (mod m) 형태로 c가 0이 아니므로 혼합식 합동법이다.'
        },
        {//
            q : "X0= 1일때 X1을 구하면?",
            q1 : '' ,
            a : ["3","5","6","8"],
            r : 4,
            img:'',
            summary:'5*1 + 3 = 8 mod 8  = 8'
        },
        {//
            q : "계속해서 X2를 구하면?",
            q1 : '' ,
            a : ["6","10","11","13"],
            r : 3,
            img:'',
            summary:'x2 = 5 * 8 + 3 = 43 mod 16 = 11  (mod m)은 m으로 나눈 나머지 값을 쓴다는 말임'
        },
        {//
            q : "계속해서 X3를 구하면?",
            q1 : '' ,
            a : ["6","10","11","13"],
            r : 2,
            img:'',
            summary:'5*11 + 3 = 58 mod 16  (58/16 나누게되면 3 으로 나눌수있고 10이 남게됨)'
        },
        {//
            q : "X0 = 7 일때 X1을 구하면?",
            q1 : '' ,
            a : ["3","5","6","8"],
            r : 3,
            img:'시뮬레이션47.JPG',
            summary:'x1 =  5 * (x0 = 7 ) + 3 = 38 mod 16 (나눠보면 2로 나눌수있음 16*2 = 32  38-32 = 6) =  6   '
        },
        {//
            q : "계속해서 x2를 구하면?",
            q1 : '' ,
            a : ["1","3","8","13"],
            r : 1,
            img:'',
            summary:'계산과정은 x0 =7    x1 = 5 * 7 + 3 = 38 mod 16 = 6  x2 = 5* 6 +3 =33 mod 16 = 1'
        },
        {//
            q : "이 식은 최대주기를 갖는다 . 최대주기는?",
            q1 : '' ,
            a : ["13","14","15","16"],
            r : 4,
            img:'',
            summary:'xi =aXi -1 +c (mod m)에서 최대주기란 p(주기) = m 인 경우이다 따라서 최대주기는 m= 16이다.'
        },
        {//
            q : "이 방법의 이름은?",
            q1 : '' ,
            a : ["중앙이승법","shift 연산법","승산식 합동법","혼합식 합동법"],
            r : 4,
            img:'시뮬레이션48.JPG',
            summary:'xi = aXi-1 +c (mod m) 형태로 c가 0이 아니므로 혼합식 합동법이다. c가 0이면 곱셉식 합동법이라 부른다.'
        },
        {//
            q : "X0 = 1을 대입하여 X1을 구하면?",
            q1 : '' ,
            a : ["0","5","8","11"],
            r : 3,
            img:'',
            summary:'x1 = 3* 1 + 5 = 8 mod 11 (11로 나눌수 없는 값이라 8이 남는다)'
        },
        {//
            q : "주기는 ",
            q1 : '' ,
            a : ["3","5","7","11"],
            r : 2,
            img:'시뮬레이션49.JPG',
            summary:'1, 8, 7,4,6,1로 5번만에 반복하므로 주기는 5이다.'
        },
        {//
            q : "X0 =5일때 X1을 구하면?",
            q1 : '' ,
            a : ["3","5","6","9"],
            r : 1,
            img:'시뮬레이션50.JPG',
            summary:'x0 = 5   x1 = 2 * 5 +3 =13 mod 10 (1로 나누어짐 3이 남음) = 3'
        },
        {//
            q : "계속해서 X2를 구하면?",
            q1 : '' ,
            a : ["3","5","6","9"],
            r : 4,
            img:'',
            summary:'x0 = 5   x1 = 2 * 5 +3 =13 mod 10 (1로 나누어짐 3이 남음) = 3 x2 = 2*3 +3 =9 mod 10 (10으로 나눌수 없음 9가 남음)'
        },
        {//
            q : "주기는?",
            q1 : '' ,
            a : ["3","4","5","6"],
            r : 4,
            img:'시뮬레이션51.JPG',
            summary:'5,3,9,1,5로 반복된다 주기는 4다.'
        },
        {//
            q : ".",
            q1 : '' ,
            a : ["a=5","a-1=4","c=5","m=16"],
            r : 3,
            img:'시뮬레이션52.JPG',
            summary:'c=3이다 문제에 써있다..'
        },
        {//
            q : ".",
            q1 : '' ,
            a : ["a=5","a-1 =4","c=3","m=15"],
            r : 4,
            img:'시뮬레이션53.JPG',
            summary:'m =16이라 문제에 써있다. mod m'
        },
        {//
            q : "컴퓨터가 4비트 워드인 경우 overflow를 이용해서 난수를 발생시키는 과정이다. 계산결과가 111000이라면 구해진 난수는?",
            q1 : '' ,
            a : ["111","100","110","1100"],
            r : 4,
            img:'',
            summary:'4비트이므로 11100 에서 앞에 1 <- 삭제 / 1100'
        },
        {//
            q : "컴퓨터가 4비트 워드인경우 overflow를 이용해서 난수를 발생시키는 과정이다 계산결과가 110101(2진수)라면 구해진 난수는",
            q1 : '' ,
            a : ["101","110","1010","1101"],
            r : 1,
            img:'',
            summary:'4비트 워드이므로 110101에서 4비트를 제외한 앞의 두자리는 overflow로 없어진다. 따라서 0101이 된다.'
        },
        {//
            q : "컴퓨터가 4비트 워드인경우 overflow를 이용해서 난수를 발생시키는 과정이다 계산결과가 101010(2진수)라면 구해진 난수는",
            q1 : '' ,
            a : ["101","0101","1010","10101"],
            r : 3,
            img:'',
            summary:'4비트 워드이므로 101010에서 4비트를 제외한 앞의 두자리는 overflow로 사라짐  10<- 삭제/1010'
        },
        {// 난수의 검정
            q : "구간별 기대값인 n/k 의 값은?",
            q1 : '' ,
            a : ["20","30","50","60"],
            r : 1,
            img:'시뮬레이션54.JPG',
            summary:'2000개의 발생된 난수가 정확하게 일양분포를 한다면 100개의 구간으로 나누었을때 각 구간에 속하는 난수의 개수, 즉 기대값은 2000/100 = 20이다.'
        },
        {//
            q : "Oi 가 뜻하는 것은?",
            q1 : '' ,
            a : ["기대값","신뢰구간","자유도","관측값"],
            r : 4,
            img:'',
            summary:'Oi는 실제 난수를 발생시켰을때 그 구간 안에 들어가는 난수의 개수이다. 기대값은 20이지만 실제 난수를 발생시켰을때 그 구간안에 속하는 난수의 개수는 정확히 20개가 되지는 않는다.'
        },
        {//
            q : "2차원 연속형 검정을 하려고 한다 같은 수의 난수에 대하여 100(10 *10) 개의 2차원 구간을 선정하였다 이때 n/k는?",
            q1 : '' ,
            a : ["10","15","20","30"],
            r : 1,
            img:'',
            summary:'2000개의 발생된 난수가 2차원 좌표(X좌표 y좌표)로 표현되면 난수 2개가 하나의 좌표가 되므로 모두 1000개의 2차원좌표가 된다. 따라서 100개의 2차원 구간으로 나누었을때 각 구간에 속하는 난수의기대값은 1000/100 = 10이다.'
        },
        {//
            q : "자유도는?",
            q1 : '' ,
            a : ["99","100","101","102"],
            r : 1,
            img:'시뮬레이션55.JPG',
            summary:'통계량은 자유도 k-1인 x2 분포임으로 . 자유도는 k-1 = 100-1 = 99이다.'
        },
        {//
            q : "구간별 기대값인 n/k 의 값은",
            q1 : '' ,
            a : ["20","30","40","50"],
            r : 3,
            img:'',
            summary:'4000개의 발생된 난수가 정확하게 일양분포를 한다면 100개의 구간으로 나누었을때 각 구간에 속하는 난수의 개수, 즉 기대값은 4000/100 = 40이다.'
        },
        {//
            q : "Oi가 뜻하는 것은?",
            q1 : '' ,
            a : ["기대값","신뢰구간","자유도","관측값"],
            r : 4,
            img:'',
            summary:'Oi는 실제 난수를 발생시켰을 때 그 구간안에 들어가는 난수의 개수이다. 기대값은 40이지만 실제 난수를 발생시켰을때 그 구간안에 속하는 난수의개수는 정확히 40개가 되지 않는다.'
        },
        {//
            q : "계속해서 2차원 연속형 검정을 하려고 한다. 같은 수의 난수 4000개에 대하여 2차원의 x, y 난수를 만들고 100(10 * 10) 개의 2차원 구간을 선정하였다 이때의 n/k는?",
            q1 : '' ,
            a : ["10","15","20","30"],
            r : 3,
            img:'',
            summary:'4000개의 발생된 난수가 2차원 좌표 로 표현되면 난수 2개가 하나의 좌표가 되므로 모두 2000개의 2차원 좌표가 된다. 따라서 100개의 2차원 구간으로 나눌경우  난수의 기대값은 2000/100 = 20이다.'
        },
        {//
            q : "X2 검정에 관한 사항이다.",
            q1 : '' ,
            a : ["20","30","40","50"],
            r : 2,
            img:'시뮬레이션56.JPG',
            summary:'3000개의 발생된 난수가 정확하게 일양분포를 한다면 100개의 구간으로 나누었을때 각 구간에 속하는 난수의 개수 즉 기대값은 3000/100  =30이다.'
        },
        {//
            q : "구간별 기대값인 n/k의 값은?",
            q1 : '' ,
            a : ["20","30","40","50"],
            r : 4,
            img:'시뮬레이션57.JPG',
            summary:'5000개의 발생된 난수가 정확하게 일양분포를 한다면 100개의 구간으로 나누었을때 각 구간에 속하는 난수의 개수, 즉 기대값은 5000/100 =50이다.'
        },
        {//
            q : "계속해서 2차원의 연속형 검정을 하려고 한다. 같은 수의 난수(5000개)에 대하여 2차원의 (x,y) 난수를 만들고 100(10 * 10) 개의 2차원 구간을 선정하였다 이때의 n/k는?",
            q1 : '' ,
            a : ["15","20","25","30"],
            r : 3,
            img:'',
            summary:'5000개의 발생된 난수가 2차원 좌표로 표현되면 난수가 2개가 하나의 좌표가 되므로 2500개의 2차원 좌표가 된다. 따라서 100개의 2차원 구간으로 나우었을때 각 구간에 속하는 난수의 기대값은 2500/100 = 25이다.'
        },
        {//
            q : "난수외 검정에서 독립성을 검정하는 것은?",
            q1 : '' ,
            a : ["x2 검정","연속형 검정","Runs검정","Kolmogorov-Smimov 검정"],
            r : 3,
            img:'',
            summary:'Runs 검정은 균등이 아닌 독립가정에 대한 직접적인 검정이다.'
        },
        {// 8장 확률변수의 발생
            q : "확률변수를 발생시키는 방법이 아닌 것은?",
            q1 : '' ,
            a : ["역변환법","합성법","채택-기각법","합동법"],
            r : 4,
            img:'',
            summary:'합동법은 난수 발생법이다.'
        },
        {//
            q : "m-Eriang 분포의 특징을 이용하면 어느 방법으로 확률변수를 발생시키는 것이 적당한가?",
            q1 : '' ,
            a : ["역변환법","합성법","결합법","채택 - 기각법"],
            r : 3,
            img:'',
            summary:'m-Erlang 확률변수는 m개 지수분포의 합이기 때문에 결합법을 이용할 수 있는 확률변수의 예이다. 그러나 이 방법으로는 m의 값이 큰 경우. 확률변수 X를 발생시키는데 많은 시간이 소요되어 발생속도가 느려진다. 따라서 m-Erlang분포가 감마분포의 특수한 경우라는 점을 이용하면 좀더 나은 방법을 쓸 수 있다.'
        },
        {//
            q : "확률변수가 X = Y1 + Y2 + .... + Ym 으로 주어질때 사용하는 확률변수 발생법은?",
            q1 : '' ,
            a : ["역변환법","합성법","결합법","채택 - 기각법"],
            r : 3,
            img:'',
            summary:'결합법은 X가 확률변수들의 합으로 나타내는 경우이다.'
        },
        {//
            q : "다음은 확률변수 발생방법에 대한 설명이다 어느 방법을 설명하는 것인가?",
            q1 : '' ,
            a : ["역변환법","합성법","결합법","채택- 기각법"],
            r : 2,
            img:'시뮬레이션58.JPG',
            summary:'합성법은 분포함수 F가 다른 분포함수를 F1,F2...의 조합으로 표시될 수 있는 경우에 사용된다.'
        },
        {//
            q : "다음은 일양확률변수 U[1/4, 1) 을 발생시키는 과정이다. 이 방법의 이름은?",
            q1 : '' ,
            a : ["역변환법","합성법","결합법","채택- 기각법"],
            r : 4,
            img:'시뮬레이션59.JPG',
            summary:'채택 - 기각법  :  일정한 조건을 정해서 만족하면 채택하고 아니면 기각하는 방식으로 확률변수를 발생시킴. 예를들면 [1/4, 1)의 범위를 갖는 일양확률변수를 채택 기각법으로 ....'
        },
        {//
            q : "다음중 대기행렬 문제에서 고객의 발생확률 (시간당 15명)을 정하는 방법과관련이 있는 것은?",
            q1 : '' ,
            a : ["역변환법","합성법","채택-기각법","합동법"],
            r : 3,
            img:'',
            summary:'채택기각봅은 일정한 조건을 만족하면 채택하고 아니면 기각하는 방식으로 확률변수를 발생시킨다 . 예를들면 고객의도착확률이 15/60 = 1/4 이다.....'
        },
        {//
            q : "다음은 지수확률변수를 발생시키는 과정이다 이방법의 이름은?",
            q1 : '' ,
            a : ["역변환법","합성법","결합법","채택 - 기각법"],
            r : 1,
            img:'시뮬레이션60.JPG',
            summary:'역함수를 사용하고 있다.'
        },
        {//
            q : "확률변수 X가 다음의 식으로 나타내는 분포는?",
            q1 : '' ,
            a : ["일양분포","m-Erlang 분포","베타분포","감마분포"],
            r : 2,
            img:'시뮬레이션61.JPG',
            summary:'m-Erlang 분포 : 평균이 베타인 m-Erlang 변수 x는 다음의 식으로 나타낸다 . X =Y1+Y2+...+Ym  '
        },
    ]
    const algotest :Testtype[] =[
        {//
            q : "알고리즘이 만족해야할 조건에 대한 설명으로 적절하지 않은 것은?",
            q1 : '' ,
            a : ["한정된 수의 단계 후에는 반드시 종료해야 한다.","모든 명령은 컴퓨터에서 실행 가능해야 한다.","각 명령은 모호하지 않아야 한다.","0개 이상의 입력과 출력이 각각 있어야 한다."],
            r : 4,
            img:'',
            summary:`문제해결이라는 이론적 측면에서 알고리즘이 반드시 만족해야할 조건 : 
            입출력 -> 0개이상의 외부 입력과 하나 이상의 출력이 있어야함, 
            명확성 -> 각 명령은 모호하지 않고 단순 명확해야함
            유한성 -> 한정된 수의 단계를 거친 후에는 반드시 종료해야 한다
            유효성 -> 모든 명령은 컴퓨터에서 수행할 수 있어야 한다
            실용적 관점에서 요구되는 조건 -> 효율성`
        },
        {//
            q : "현실적인 시간 내에 원하는 결과를 얻어야 한다는 측면에서 알고리즘이 갖추어야할 조건은?",
            q1 : '' ,
            a : ["함축성","효율성","무한성","긴급성"],
            r : 2,
            img:'',
            summary:'실용적 관점에서 요구되는 조건 -> 효율성'
        },
        {//1.2 알고리즘의 설계
            q : "다음과 같은 전략을 사용하는 알고리즘 설계기법은?",
            q1 : '일련의 선택 과정을 거쳐 해를 찾을 때 전후 단계의 선택과는 상관없이 단계마다 정해진 기준에 따라 가장 최선이라고 여겨지는 국부적인 최적해를 선택해서 전체적인 최적해를 구한다.' ,
            a : ["분할정복 방법","욕심쟁이방법","상각분석 방법","동적 프로그래밍 방법"],
            r : 2,
            img:'',
            summary:'주어진 설명은 욕심쟁이 방법에 대한 것이며, 이는 문제의 해결에서 국부적인 최적해가 항상 전체적인 최적해를 만들지 못한다는 제약이 따르지만. 욕심쟁이 방법을 적용할 수 있는 경우에는 아주 간단히 효율적인 알고리즘을 만들 수 있는 강력한 설계기법이다.'
        },
        {//
            q : "분할정복 방법에 대한 설명으로 적절한 것은?",
            q1 : '' ,
            a : ["상향적인 문제 해결방법이다.","최적화 문제 해결에 주로 사용된다","분할된 작은 문제는 서로 독립적이다","작은 문제의 해를 구해 테이블에 저장하고 이를 이용해서 문제를 해결한다"],
            r : 3,
            img:'',
            summary:`1. 동적프로그래밍 방법에 해당하는 설명이며, 분할정복 방법은 하향적 문제 해결방법임
            2. 욕심쟁이 방법과 동적 프로그래밍 방법은 최솟값 또는 최대값을 구하는 최적화 문제 해결에 주로 사용된다.
            3. 분할된 작은 문제는 서로 독립적이므로 각 문제를 다시 순환적으로 분할하고 결과를 통합하는 것이 가능하다 
            4. 동적 프로그래밍 방법에 해당하는 설명이다.`
        },
        {//
            q : "욕심쟁이 방법이 효율적으로 적용될 수 있는 것은?",
            q1 : '' ,
            a : ["거스름돈 문제","이진 탐색","플로이드 알고리즘","모든 쌍 최단경로 문제"],
            r : 1,
            img:'',
            summary:`대표적인 알고리즘 설계기법이 적용된 문제/ 알고리즘은 다음과 같음
            - 욕심쟁이 방법 -> 거스름돈 문제, 배낭 문제, 최소 신장트리 문제 (-> 크루스칼 알고리즘, 프림 알고리즘), 단일 출발점 최단경로 문제(-> 데이크스트라 알고리즘)
            - 분할정복 방법 -> 이진탐색, 퀵정렬, 합병정렬
            - 동적 프로그래밍 방법 -> 모든쌍 최단 경로 문제 (-> 플로이드 알고리즘)`
        },
        {//6
            q : "다음과 같은 조건의 배낭 문제를 욕심쟁이 방법으로 해결하려고 한다. 이때 얻을 수 있는 최대 이익은 얼마인가? (단 물체를 쪼갤수 있다.)",
            q1 : '' ,
            a : ["47","49","50","58"],
            r : 3,
            img:'./algowork.JPG',
            summary:'단위무게당 이익 = 18/3 20/5 9/3 20/4 = 6 4 3 5    배낭에 물체를 채우는 순서 = 물체1 ->물체4 -> 물체 2 -> 물체3 -> 물체1 을 최대한 넣고 다시 물체4를 최대한 넣으면 배낭의 용량은 3이 남는다. 이때 물체 2를 통째로 넣을 수 없으므로 물체2의 무게 5를 남은 배낭의 용량3에 맞춰 물체를 쪼개서 3/5 만큼 배낭에 넣으면 배낭이 꽉차고 더이상 물체를 넣을 수 없다.'
        },
        {//7
            q : "배열 A[ ] = [10 , 15, 20, 25, 30, 35, 40, 45, 50] 에 대한 이진 탐색과정에서 가장 적은 횟수의 비교가 필요한 데이터는 ",
            q1 : '' ,
            a : ["10","15", "25","30"],
            r : 4,
            img:'',
            summary:'주어진 배열의 중간값 - 30 ->한번 비교'
        },
        {//1.3 알고리즘 분석
            q : "다음 설명 중에서 적절한 것은?",
            q1 : '' ,
            a : ["시간복잡도는 특정한 값으로 고정된 입력 크기를 기준으로 계산한다.","입력 데이터의 모든 상태를 고려한 평균 수행시간을 성능 평가의 척도로 사용한다.","시간 복잡도는 알고리즘에서 단위 연산이 수행되는 횟수의 합으로 정의한다,.","공간 복잡도는 알고리즘 수행에 필요한 주기억장치와 보조기억장치의 용량의 합으로 표현한다."],
            r : 3,
            img:'',
            summary:'알고리즘의 분석은 일반적으로 수행시간을 나타내는 시간 복잡도를 이용한다. 시간 복잡도는 알고리즘의 단위 역산의 수행 횟수를 합으로 정의하며 이는 입력 크기의 함수로 표현하고 일반적으로 최악의 수행시간을 사용한다. 한편 공간복잡도는 알고리즘 수행에 필요한 메모리(주기억장치)의 양으로, 컴파일 시간에 결정되는 정적 공간과 실행중에 결정되는 동적 공간의 합으로 정의된다.'
        },
        {//1.4 접근성능
            q : "점근성능에 대한 설명으로 적절한 것은?",
            q1 : '' ,
            a : ["입력데이터의 상태가 최악인 경우를 가정한 알고리즘의 성능을 의미한다.","알고리즘의 수행시간을 가장 정확히 표현하는 방법이다.","수행시간의 다항식 함수에서 계수와 최고 차수의 항을 이용해서 표현한다.","입력 크기의 증가에 따른 수행시간이 증가하는 경향을 파악하기 쉽다."],
            r : 4,
            img:'',
            summary:'접근성능은 입력크기가 무한히 크다고 가정한 경우의 성능으로 수행시간의 다항식 함수에서 계수 없이 최고차항만들 이용해서 단순히 표현하는 방법이다. 최고차항만을 이용하기 때문에 알고리즘의 정확한 성능표현이 아닌 어림값에 의한 표현이지만 입력 크기가 증가함에 따른 알고리즘 수행시간이 어떻게 증가하는지의 추세를 쉽게 파악할 수 있고 이를 통해 알고리즘의 성능 우열의 비교가 용이하다.'
        },
        {//10
            q : "다음은 접슨성능 표기법에 대한 정의이다. 밑줄친 (a)에 알맞은 수식은?",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 3,
            img:'./algowork0.JPG',
            summary:'빅오 포기법에서 g(n)은 f(n)의 접근적 상한이다, 따라서 f(n)이 아무리 커지더라도 c*g(n)보다는 더 커질수 없으므로 f(n) <= c*g(n)이 된다. 이는 어떤 상태의 입력이 제공되어 알고리즘의 수행시간 f(n)이 아무리 오래 걸려도 상한 (g(n)보다 더 커질수 없음을 나타낸다.'
        },
        {//
            q : "일반적으로 알고리즘의 수행시간이 (O(nlog n)이다 라는 표현이 의미하는 것은?",
            q1 : '' ,
            a : ["최악의 수행시간이 O(nlog n)이다","최선의 수행시간이 O(nlog n)이다","평균 수행시간이 O(nlog n)이다.","최악 및 최선 모두 O(nlog n)이다."],
            r : 1,
            img:'',
            summary:'빅오 표기법은 접근적 상한, 즉 알고리즘의 촤악의 수행시간에 해당한다. 이와 반대로 오메가 표기법은 ㅇ알고리즘의 최선의 수행시간을 나타낸다.'
        },
        {//12
            q : "접근성능의 표기법 중에서 알고리즘의 최선의 수행시간과 최악의 수행시간이 같아서 보다 정확한 성능을 표현할 수 있는 것은? (단, 함수 f와 g는 각각 양의 정수를 갖는 함수이며, 입력 크기는 n이다)",
            q1 : '' ,
            a : ["f(n) = O(g(n))","f(n) = Ω(g(n))","f(n) = θ(g(n))","f(n) = Φ(g(n))"],
            r : 3,
            img:'',
            summary:`점근적 표기법(g(n) =n^3인 경우)
            *f(n) = O(g(n)) -> 점근적 상한 -> 최악의 수행시간
            *f(n) = Ω(g(n)) -> 점근적 하한 -> 최선의 수행시간
            *f(n) = θ(g(n)) -> 점근적 상하한 -> 최선과 최악의 수행시간`
        },
        {//
            q : "다음ㅈ중 Ω-표기를 나타내는 것은? (단 함수 f와 g는 각각 양의 정수를 갖는 함수이다. 어떤 양의 상수 c,c1,c2,n0 이 존재하며, 입력 크기는 n이다)",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 4,
            img:'./algowork01.JPG',
            summary:'2번은 점근적 상하한, 3번은 빅오 표기법 점근적상한, 4번은 오메가 표기법 점근적 하한임'
        },
        {//14
            q : "알고리즘의 성능을 나타내는 빅오 함수 중에서 가장 효율적인 것은?",
            q1 : '' ,
            a : ["O(n log n)","O(log n)","O(n^2)","O(2^n)"],
            r : 2,
            img:'',
            summary:'빅오 함수의 크기 관계는 다음과 같이 나타낼 수 있다. 함수들이 오른쪽에 위치 할수록 부등호가 크다는 것은 수행시간이 더 많이 걸린다는 의미이고 결국 왼쪽에 위치하는 것일수록 더 효율적인 함수임을 나타낸다.  O(1) < O(log n) < O(n) < O(nlog n) < O(n^2) < O (2^n)'
        },
        {//15
            q : "입력크기 n일때 주어진 2개의 프로그램 a와 b의 시간복잡도를 나타내는 것을 고르시오",
            q1 : 'a를 고르시오' ,
            a : ["1","2","3","4"],
            r : 4,
            img:'./algowork02.JPG',
            summary:'알고리즘의 시간 복잡도를 구하려면 수행시간 f(n)을 구한 후 f(n)=O(g(n))을 만족하는 최소의 g(n)을 찾으면 된다. 하지만 실용적인 관점에서는 알고리즘에 나타난 루프(반복문)의 반복 횟수를 조사하여 시간 복잡도를 취하면 된다. 프로그램 (a)에서는 바깥 루프 (i)는 입력크기 n에 비례하고 안쪽 루프 (f)도 n에 비례하는 이중 루프이므로 시간 복잡도는 O(n^2)이 된다. '
        },
        {//15
            q : "입력크기 n일때 주어진 2개의 프로그램 a와 b의 시간복잡도를 나타내는 것을 고르시오",
            q1 : 'b를 고르시오' ,
            a : ["1","2","3","4"],
            r : 2,
            img:'./algowork02.JPG',
            summary:'프로그램 (b)는 중첩되지 않은 2개의 루프가 존재하며, 각 루프는 입력 크기 n에 비례한다 따라서 시간복잡도는 O(n)이 된다.'
        },
        {//16
            q : "주어진 점화식의 폐쇄형을 기준으로 비교할 때 가장 비효율적인 것은?",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 1,
            img:'./algowork03.JPG',
            summary:''
        },
        {//
            q : "입력크기가 n일때 주어진 프로그램의 수행시간에 해당하는 점화식은?",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 3,
            img:'./algowork04.JPG',
            summary:'주어진 프로그램은 배열의 중앙값을 출력하고, 절반 크기의 왼쪽 부분배열을 사용해서 다시 순환호출한다. 즉 주어진 프로그램은 한번 순환 호출할 때마다 입력 크기 n이 절반씩 줄어드는 형태이다 따라서 입력쿠기 n에 대한 주어진 프로그램의 수행시간 T(n)은 입력크기 n/2인 배열에 대한 순환호출에 따른 수행시간 T(n/2)과 일정한 개수의 명령을 수행하는데 걸리는 상수 시간 O(1)의 합으로 표현되어 3에 해당한다.'
        },
        {//2장 정렬
            q : "정렬 알고리즘이 제자리 라는 것에 대한 설명으로 올바른 것은?",
            q1 : '' ,
            a : ["입력 배열 이외의 추가적으로 필요한 저장 공간이 상수 개를 넘지 않는다","동일한 값을 갖는 데이터들의 정렬 전의 상대적인 순서가 정렬 후에도 그대로 유지된다.","입력값의 범위가 입력 데이터의 개수에 비례한다","데이터의 값이 주어진 범위 내에서 확률적으로 균등하게 분포한다."],
            r : 1,
            img:'',
            summary:'2번은 안정적 정렬의 설명에 해당함, 3과 4번은 각각 계수 정렬과 버킷 정렬이 O(n)의 수행시간으로 유용하게 사용되기 위한 조건에 해당한다.'
        },
        {//
            q : "다음 중 정렬 방식이 나머지 셋과 다른 하나는?",
            q1 : '' ,
            a : ["힙 정렬","퀵 정렬","계수 정렬","버블 정렬"],
            r : 3,
            img:'',
            summary:'정렬 알고리즘은 정렬 방식에 따라 비교 기반의 정렬 알고리즘과 그렇지 않은 정렬 알고리즘으로 구분할 수 있다. 교재에서 다루는 알고리즘 중에서 7개의 정렬(선택, 버블, 삽입, 셸, 퀵, 합병, 힙)은 비교 기반의 정렬 알고리즘이며 나머지 3개에 해당하는 계수정렬 기수정렬 그리고 버킷 정렬은 비교 기반이 아닌 데이터 분포 정보를 활용하는 정렬 알고리즘이다.'
        },
        {//3
            q : "입력크기 n인 배열에 대해서 다음과 같은 방식으로 정렬을 수행하는 알고리즘에 해당하는 설명은?",
            q1 : '' ,
            a : ["안정적인 정렬 알고리즘이다.","버블 정렬의 처리과정을 나타낸다","최악의 수행시간은 O(nlog n)이다","언제나 동일한 시간복잡도를 갖는다."],
            r : 4,
            img:'./algowork05.JPG',
            summary:'주어진 처리과정은 배열에서 가장 작은 값부터 차례대로 선택해서 나열하는 선택정렬에 해당한다. 선택정렬의 미정렬 부분에서 최솟값을 찾는 과정 A는 데이터의 입력 상태와는 무관하므로 언제나 동일한 수행시간 O(n^2)를 갖는다. 또한 선택정렬은 안정적이지 않으며 제자리 정렬 알고리즘이다.'
        },
        {//
            q : "다음 그림은 주어진 입력 배열에 대해서 오름차순으로 정렬하는 과정을 단개별로 나타낸 것이다. 이때 적용된 정렬 알고리즘은?",
            q1 : '' ,
            a : ["버블정렬","선택정렬","삽입정렬","셸정렬"],
            r : 2,
            img:'./algowork06.JPG',
            summary:'각 단계마다 미정렬된 부분에서 가장 작은 값을 찾아서, 정렬 부분의 첫번째 데이터와 위치 교환을 반복하는 방식의 정렬 알고리즘이다.'
        },
        {//5
            q : "다음 알고리즘에 대한 설명으로 올바른 것은?",
            q1 : '' ,
            a : ["모든 데이터는 많아야 두번의 위치교환이 발생한다.","시간 복잡도는 O(n log n)이다.","제자리 정렬 알고리즘이 아니다","같은 값을 갖는 데이터에 대한 정렬 전후의 상대적인 순서가 그대로 유지된다"],
            r : 4,
            img:'./algowork07.JPG',
            summary:'주어진 알고리즘은 가장 기본적인 형태의 버블 정렬이다. 버블 정렬은 O(n^2), 제자리정렬 안정적인 정렬 알고리즘이다 보기 1은 선택정렬에 해당하는 설명이다.'
        },
        {//6
            q : "주어진 데이터에 대해 버블 정렬을 사용하여 오름차순으로 정렬하려고 한다. 첫번째 단계의 처리과정을 거친 후의 데이터의 순서를 올바르게 나열한 것은?",
            q1 : '25  40  20  10  30  45  15  35' ,
            a : ["25  40  10  20  45  30  35  15","25  20  10  30  40  15  35  45","25  20  40  10  15  30  35  45","25  10  15  20  30  35  40  45"],
            r : 2,
            img:'',
            summary:'주어진 그림은 왼쪽에서부터 인접한 두 데이터를 비교/교환하는 버블정렬의 첫번째 단계의 처리과정을 나타낸 것이다. 만약 오른쪽에서 왼쪽으로 진행하는 방식의 버블정렬이라면 첫번째 단계를 거친 후에는 가장 작은 값 10이 맨 왼쪽에 위치하게된다. 주어진 보기에는 맨 왼쪽에 10인것이 존재하지 않으므로 왼쪽에서 오른쪽으로 진행하는 방식을 적용해야 한다.'
        },
        {//
            q : "주어진 버블정렬 알고리즘으로 입력배열 A[] =[60, 20, 30, 40, 50]정렬할때 밑줄친 if문에서 수행되는 데이터 간의 총 비교횟수는? (단 오름차순으로 정렬한다)",
            q1 : '' ,
            a : ["5","7","9","11"],
            r : 2,
            img:'./algowork08.JPG',
            summary:''
        },
        {//8
            q : "삽입정렬을 통해 오름차순으로 정렬할 때 가장 빠른 성능을 보일 수 있는 입력 데이터의 상태는?",
            q1 : '' ,
            a : ["80  70  60  50  40  30  20  10","10  20  30  40  50  60  70  80","80  70  60  50  10  20  30  40","10  20  30  40 80  70  60  50"],
            r : 2,
            img:'',
            summary:'삽입 정렬은 입력 데이터가 제 순서대로 정렬된 상태로 주어지면 최선의 수행시간 O(n)을 갖고 역순으로 정렬된 데이터에 대해서는 최악의 수행시간 O(n^2)를 갖는다. 데이터기 이미 순서대로 정렬되어 있다면 첫번째 데이터를 제외한 나머지 모든 데이터는 삽입할 위치를 찾기 위해 바로 앞의 데이터와 오직 한번씩만 비교하면 된다 . 따라서 전체적으로는 n-1 번의 비교만 수행한 후 정렬을 완료한다.'
        },
        {//
            q : "주어진 5개의 데이터에 대해서 삽입 정렬을 적용하여 오름차순으로 정렬할 때 필요한 총 비교횟수는?",
            q1 : '50 40 30 20 10' ,
            a : ["4",'5','10','20'],
            r : 3,
            img:'',
            summary:'삽입정렬에서 입력크기인 n인 데이터가 역순으로 정렬된 상태로 주어지면 총 n(n-1)/2 번의 비교가 필요한 최악의 경우로 O(n^2)이 된다.'
        },
        {//10
            q : "셸정렬에 대한 설명으로 올바른 것은?",
            q1 : '' ,
            a : ["최악의 경우 O(nlog n)의 수행시간을 보장한다","제자리 정렬 알고리즘이 아니다","각 부분배열에서 인접한 두 데이터 간의 거리는 항상 일정하다","선택정렬의 단점을 보완한 정렬 알고리즘이다"],
            r : 3,
            img:'',
            summary:'1.간격의 크기를 정하는 순열에 따라 성능의 차이가 발생하며, 최악의 수행시간은 O(n^2)이다  2.셸정렬은 안정적이지 않은 제자리 정렬 알고리즘이다 4.셸정렬은 삽입정렬의 단점 (-현재 삽입하고자 하는 데이터가 삽입될 제위치에 많이 벗어나 있어도 한번에 한 자리씩만 이동해서 제자리를 찾아갈 수밖에 없다-를 보완한 것이다.'
        },
        {//11
            q : "셸정렬에서 2^i-1 (i=1,2,....) 형태의 순열을 사용해 입력크기 16인 배열을 정렬할때 첫번째 단계에서 부분배열의 갯수로 가장 적당한 것은?",
            q1 : '' ,
            a : ["1","2","4","8"],
            r : 4,
            img:'',
            summary:'입력크기 n보다 작으면서 가장 큰 순열값부터 역순으로 사용해서 부분배열의 개수를 지정한다, 2^i-1은 1 2 4 8 16 의 형태를 보이는 순열이고 첫번째로 사용할 순열의 값은 8이되며 따라서 입력크기 16인 경우 주어진 배열을 8개의 부분배열로 나누어 삽입 정렬하고 다시 4개의 부분배열 2개의 부분배열 그리고 1개의 부분배열을 대상으로 삽입정렬을 수행하면 최종결과를 얻을 수 있다.'
        },
        {//
            q : "",
            q1 : '' ,
            a : [""],
            r : 0,
            img:'',
            summary:''
        },
        {//
            q : "",
            q1 : '' ,
            a : [""],
            r : 0,
            img:'',
            summary:''
        },
        {//
            q : "",
            q1 : '' ,
            a : [""],
            r : 0,
            img:'',
            summary:''
        },
        {//
            q : "",
            q1 : '' ,
            a : [""],
            r : 0,
            img:'',
            summary:''
        },
        {//
            q : "",
            q1 : '' ,
            a : [""],
            r : 0,
            img:'',
            summary:''
        },
        {//
            q : "",
            q1 : '' ,
            a : [""],
            r : 0,
            img:'',
            summary:''
        },
        {//
            q : "",
            q1 : '' ,
            a : [""],
            r : 0,
            img:'',
            summary:''
        },
        {//
            q : "",
            q1 : '' ,
            a : [""],
            r : 0,
            img:'',
            summary:''
        },
        {//
            q : "",
            q1 : '' ,
            a : [""],
            r : 0,
            img:'',
            summary:''
        },
        {//
            q : "",
            q1 : '' ,
            a : [""],
            r : 0,
            img:'',
            summary:''
        },
        {//
            q : "",
            q1 : '' ,
            a : [""],
            r : 0,
            img:'',
            summary:''
        },
        {//
            q : "",
            q1 : '' ,
            a : [""],
            r : 0,
            img:'',
            summary:''
        },
        {//
            q : "",
            q1 : '' ,
            a : [""],
            r : 0,
            img:'',
            summary:''
        },
        {//
            q : "",
            q1 : '' ,
            a : [""],
            r : 0,
            img:'',
            summary:''
        },
        {//
            q : "",
            q1 : '' ,
            a : [""],
            r : 0,
            img:'',
            summary:''
        },
        {//
            q : "",
            q1 : '' ,
            a : [""],
            r : 0,
            img:'',
            summary:''
        },
        {//
            q : "",
            q1 : '' ,
            a : [""],
            r : 0,
            img:'',
            summary:''
        },
        {//
            q : "",
            q1 : '' ,
            a : [""],
            r : 0,
            img:'',
            summary:''
        },
    ]
    let [subject,setsubject]= React.useState(test2017jsp) 
    function namecheck(){
     switch(data){
        case 'testjspwork' : 
        setsubject(testjspwork)
        break;
        case 'test2017jsp' : 
        setsubject(test2017jsp)
        break;
        case 'test2018jsp' : 
        setsubject(test2018jsp)
        break;
        case 'test2019jsp' : 
        setsubject(test2019jsp)
        break;
        case 'testdbpp' :
            setsubject(testdbpp)
        break;
        case 'test2016db' :
            setsubject(test2016db)
        break;
        case 'test2017db' :
            setsubject(test2017db)
        break;
        case 'test2018db' :
            setsubject(test2018db)
        break;
        case 'test2019db' :
            setsubject(test2019db)
        break;
        case 'test2019cs' :
            setsubject(test2019cs)
        break;
        case 'test2018cs' :
            setsubject(test2018cs)
        break;
        case 'test2017cs' :
            setsubject(test2017cs)
        break;
        case 'testcswork' :
            setsubject(testcswork)
        break;
        case 'test2017unix' :
            setsubject(test2017unix)
        break;
        case 'test2018unix' :
            setsubject(test2018unix)
        break;
        case 'test2019unix' :
            setsubject(test2019unix)
        break;
        case 'testunixwork' :
            setsubject(testunixwork)
        break;
        case 'testsimul2017' :
            setsubject(testsimul2017)
        break;
        case 'testsimul2018' :
            setsubject(testsimul2018)
        break;
        case 'testsimul2019' :
            setsubject(testsimul2019)
        break;
        case 'testsimulwork' :
            setsubject(testsimulwork)
        break;
        case 'algotest' :
            setsubject(algotest)
        break;
     }   
    }   

    React.useEffect(()=>{
    namecheck()
    // setcheckvalue(Array(25).fill(null))
    },[])

    let [checkvalue, setcheckvalue] = React.useState(Array(testsimulwork.length).fill(null)) //정답 저장할곳
    function checkresult (idx : number, value : number){
            const newSelectedAnswers = [...checkvalue];
            newSelectedAnswers[idx] = value; // 선택한 값을 저장
            setcheckvalue(newSelectedAnswers);
         
    }
    function resultcheck(idx:number,t:Testtype){
        if(checkvalue[idx]==t.r){
            window.alert('정답입니다.')
        }else if(!checkvalue[idx]){
            window.alert('정답을 선택하세요.')
        }else{
            window.alert('오답입니다.')
        } 
        }
 
    return(
        <div className={testdata.fullwrap}>
            <div className={testdata.fullcut}>
            {subject.map((a,idx)=> {return <div className={testdata.wrap1}> 
            <h2>{a.q}</h2>
            <p>{a.q1 && a.q1 }</p>
            {a.img && <img src={`/${a.img}`} /> }
            <div className={testdata.select1}>
            {  a.a.map((el,index)=>(
                <div className={testdata.radiobtn}><input type="radio" value={index+1} name={String(idx)} onChange={()=>{
                    checkresult(idx,index+1)
                }} /> {el.length <10 ? <p>{el}</p> : <p className={testdata.divide}>{el}</p> }</div>
            )
            )}
            </div>
            <div className={testdata.btn}>
                <button onClick={()=>{
               resultcheck(idx,a)
            }}> 정답 </button>
            {a.summary && <details className={testdata.correct} >
                <summary>   
                    해설보기 
                    </summary> 
                        {a.summary}                                        
                    </details>}
            </div>
            </div>
            })}
            </div>
        

            
         
        </div>
    )
}