import testdata from './data.module.scss'
import { Testtype, Testlist } from "../../model"
import React, { useRef } from 'react';
import { useParams } from 'react-router-dom';
export default function Datainner (){
    const { data } = useParams();
    console.log(data,'data')
   
    const test2017jsp : Testtype[] = [
        {
            q : "다음이 설명하는 http요청 방식은 무엇인가?",
            q1 : "원하는 방식으로 인코딩된 데이터를 요청 메시지의 몸체에 포함하여 전송하면서 자원을 요청하는 경우 사용됨",
            a : ["GET","HEAD","POST","FTP"],
            r : 3,
            img:'',
            summary:''
        },
        {
            q : "Eclipse를 이용한 웹 프로젝트의 배포가 의미하는 것은?",
            q1 : "",
            a : ["웹 프로젝트 폴더를 압춝 파일로 만드는 것이다.","개발한 웹 프로젝트를 웹 컨테이너에 내보내는 것이다.","웹 컨테이너를 서버로 등록시키는 것이다.","버퍼의 내용을 일차적으로 클라이언트에 보내는 것이다."],
            r : 2,
            img:'',
              summary:''
        },
        {
            q : "jSP 페이지에서 사용할 메소드나 변수를 선언하기 위한 태그는 다음 중 어느 것인가?",
            q1 : "",
            a : ["<% ... %>","<%!... %>", "<%@ ... %>", " <%# ... %>"],
            r : 2,
            img:'',
              summary:''
        },
        {
            q : "서블릿 클래스에서 doGet() 메서드의 인자는 무엇인가?",
            q1 : "",
            a : ["request 1개", "response 1개", " request와 response", "인자가 없음"],
            r : 3,
            img:'',  
            summary:''
        },
        {
            q : "다음은 버퍼가 차면 내용을 클라이언트로 보내고 버퍼를 비우라는 의미를 가진다. 빈칸에 들어갈 단어는 무엇인가?",
            q1 : '<%@ page ____ = "true" %> ' ,
            a : ["flush","autoFlush","buffer","autoBuffer"],
            r : 2,
            img:'',
              summary:''
        },
        {
            q : "다음 중 JSP의 내장 객체가 아닌 것은?",
            q1 : '' ,
            a : ["request","response","out","cookie"],
            r : 4,
            img:'',
              summary:''
        },
        {
            q : "including.jsp 페이지를 요청했을 때, 클라이언트의 브라우저에서 표시되는 결과는 무엇인가?",
            q1 : '' ,
            a : ["included.jsp : 1000"," including.jsp : 20 \n including.jsp","including.jsp : 20 \n included.jsp : 1000 \n including.jsp : 20", "including.jsp : 20 \n included.jsp : 1000 \n including.jsp : 1000"],
            r : 3,
            img:'jsp1.jpg',
              summary:''
        },
        {
            q : "including.jsp와 included.jsp 페이지 사이에서 공유될 수 없는 영역은 무엇인가?",
            q1 : '' ,
            a : ["page","requese","session","application"],
            r : 1,
            img:'jsp1.jpg',
              summary:''
        },
        {
            q : "jsp 페이지의 모듈화를 위해 사용하는 방법이라고 할 수 없는 것은?",
            q1 : '' ,
            a : ["page지시어","include 지시어","include 액션태그 ", "prelude와 coda"],
            r : 1,
            img:'',  summary:''
        },
        {
            q : "<jsp:forward .../> 액션의 처리를 바르게 설명한 것은?",
            q1 : '' ,
            a : ["실행 결과의 맨 앞이나 맨 뒤에 자동으로 코드를 포함시킨다.","속성으로 지정된 페이지의 실행 결과를 태그가 위치한 부분에 삽입시킨다.","<jsp:include> 액션의 서브 요소로만 사용된다.","페이지의 실행이 종료되고 새로운 페이지로의 이동이 일어난다"],
            r : 4,
            img:'',
              summary:''
        },
        {
            q : "쿠키의 유효 시간에 관한 설명으로 올바른 것은?",
            q1 : '' ,
            a : ["클라이언트 컴퓨터에서 쿠키가 유지되는 기간이다.","쿠키의 유효시간이 음수라면 영구히 보관된다","클라이언트의 추가 요청이 없어도 쿠키가 보존되는 기간이다."," 출력버퍼에서 쿠키 값을 변경할 수 있는 최대 시간이다."],
            r : 1,
            img:'',
              summary:''
        },
        {
            q : "다음 코드의 의미를 바르게 설명한 것은?",
            q1 : '<% Cookie cookie= new Cookie("name","value"); \n response.addCookie(cookie); %>' ,
            a : ["쿠키를 만들어 요청 메시지의 헤더에 추가한다"," 쿠키를 만들어 응답 메시지의 헤더에 추가한다","쿠키를 만들어 응답 메시지의 몸체에 추가한다.","클라이언트가 보낸 요청 메시지로부터 쿠키 값을 읽는다."],
            r : 2,
            img:'',
              summary:''
        },
        {
            q : "세션을 사용하여 로그인/ 로그아웃을 처리하는 jsp 페이지를 구현하려고 한다. 다음중 로그인 처리에 필요한 작업은 무엇인가?",
            q1 : '' ,
            a : ["request 영역에 session 객체를 저장한다.","session 객체에 타임아웃 시간을 수정한다.","session 객체에 사용자 확인을 위한 속성을 추가한다.","session 객체를 삭제한다."],
            r : 3,
            img:''
            ,  summary:''
        },
        {
            q : "다음중 세션이 종료되는 상황이 아닌 것은?",
            q1 : '' ,
            a : ["클라이언트가 웹 브라우저를 종료한다.","세션의 유효시간 동안 클라이언트의 추가 요청이 없었다.","JSP페이지에서 session.invaildate() 를 실행한다.","jsp 페이지에서 session 객체에 저장된 모든 속성을 삭제하였다."],
            r : 4,
            img:''
            ,  summary:''
        },
        {
            q : "위에서 사용된 자바빈 객체에 관한 설명으로 잘못된 것은?",
            q1 : '' ,
            a : ["member.MemberInfo는 클래스의 이름에 해당한다.","meminfo라는 이름의 객체가 존재하지 않으면 자바빈 객체를 생성한다.","객체가 가진 속성 name과 age에 값을 지정하고 있다.","객체의 사용 범위가 page이므로 해당 페이지에서만 사용할 수 있다."],
            r : 4,
            img:'jsp2.jpg'
            ,  summary:''
        },
        {
            q : "자바빈 객체의 이름을 출력하기 위해 밑줄 친 부분에 들어갈 적당한 내용은>?",
            q1 : '' ,
            a : ["<jsp:getProperty name='meminfo' property='name' />","<jsp:getParameter id='meminfo' property='name' />","<jsp:setProperty name='meminfo' property='name' />","<out.print(meminfo.getName()); >"],
            r : 1,
            img:'jsp2.jpg'
            ,  summary:''
        },
        {
            q : "표현언어(EL)의 사용에 관한 설명이다. 잘못된 것은?",
            q1 : '' ,
            a : ["표현식을 대신하여 자주 사용된다","태그의 속성값을 지정할 때 표현 언어 수식을 사용한다","표현 언어의 내장 객체와 jsp의 내장객체는 다른 것이다.","스크립트 요소의 내부에서 사용해야 한다."],
            r : 4,
            img:''
            ,  summary:''
        },
        {
            q : "<%= request.getParameter('name') %> 과 같은 의미를 가지는 표현 언어 수식을 내장 객체 param을 사용하여 표현하면 무엇인가?",
            q1 : '' ,
            a : ["$( param.name )","$( param[name] )","$( param.name )","$( param[name] )"],
            r : 1,
            img:''
            ,  summary:''
        },
        {
            q : "코어 라이브러리를 사용하려면 지시어를 추가해야 한다. 밑줄 친 ㄱ에 들어가야할 내용은",
            q1 : '' ,
            a : ["<%@ import", "<%= page", "<%@ taglib","<%# taglib"],
            r : 3,
            img:'jsp3.JPG'
            ,  summary:''
        },
        {
            q : "밑줄친 ㄴ에는 흐름제어를 위한 태그가 들어가야 한다 적당한 것은 무엇인가?.",
            q1 : '' ,
            a : ["c:choose","c:forEach","x:import","x:forTokens"],
            r : 2,
            img:'jsp3.JPG'
            ,  summary:''
        },
        {
            q : "다음중 MYSQL과 연동하는 JDBC프로그래밍 작업을 위한 것은 무엇인가?",
            q1 : '' ,
            a : ["Oracle 사이트에서 php-mysql패키지를 다운받아 설치함","Eclipse 사이트에서 Tomcat을 다운받아 설치함","MySQL사이트에서 Connector/J를 다운받아 설치함","MYSQL 사이트에서 MYSQL Shell을 다운받아 설치함"],
            r : 3,
            img:''
            ,  summary:''
        },
        {
            q : "MVC 패턴을 적용하여 컨트롤러를 구현할 때 커맨드 패턴을 적용할 수 있다. 이때 커맨드와 관련된 정보를 별도의 설정파일로 만든다면 어떤 장점이 있는가?",
            q1 : '' ,
            a : ["새로운 커맨드를 추가하면 설정파일을 다시 읽어야 한다","새로운 커맨드를 추가할 경우 소스코드를 수정해야 한다","새로운 커맨드를 추가되도 설정파일을 수정할 필요가 없다","새로운 커맨드를 추가되도 소스코드를 수정할 필요가 없다"],
            r : 4,
            img:''
            ,  summary:''
        },
        {
            q : "다음은 회원정보를 저장을 위한 자바빈 클래스이다. 속성 id의 getter 메서드와 setter 메서드를 올바르게 작성한 것은?",
            q1 : '' ,
            a : ["public String getId() {return id;} public void setId(String id){ id = id;}" ,"publci void getId(String id) {this.id = id; }  public String setId() { return id; }"," public String getId() { return this; }  public void setId(String id) {this.id = id;}", "public String getId() { return id;}  public void setId(String id) { this.id = id; }"],
            r : 4,
            img:'jsp4.JPG'
            ,  summary:''
        },
        {
            q : "세션 영역에 회원 아이디를 'ID'라는 이름의  속성으로 저장하려 한다. 밑출 친 ㄱ에 들어가야 할 내용은?",
            q1 : '' ,
            a : ["session.getAttribute","session.setAttribute","cookie.getAttribute","cookie.setAttribute"],
            r : 2,
            img:'jsp5.JPG'
            ,  summary:''
        },
        {
            q : "로그인 처리가 끝난 후 다음 페이지로 이동하기 위해 밑줄 친 ㄴ에 들어가야 할 내용은?",
            q1 : '' ,
            a : ["request.forward","request.sendRedirect","response.forward","response.sendRedirect"],
            r : 4,
            img:'jsp5.JPG'
            ,  summary:''
        },

    ]
    
    const test2017db :Testtype[] =[
        {//36
            q : "아래의 문장을 수식으로 표현한 것으로 알맞은 것은?",
            q1 : '' ,
            a : ["R = P(D), (R: 결과, D : 자료, P : 처리)","I = P(R) , (I : 정보, R : 결과, P : 처리)","P = R(D), (R : 결과, D:자료, P : 처리)", "I =P(D) , (I : 정보, D: 자료, P : 처리)"],
            r : 4,
            img:'자료구조2017.JPG'
            ,  summary:''
        },
        {//37
            q : "현실 세계에서 관찰이나 측정을 통해 수집된 값이나 사실을 무엇이라 하는가?",
            q1 : '' ,
            a : ["자료","정보","자료구조","추상화"],
            r : 1,
            img:''
            ,  summary:''
        },
        {
            q : "다음 설명 중 틀린 것은 무엇인가?",
            q1 : '' ,
            a : ["배열은 인덱스와 원소값의 쌍으로 구성된다.","배열의 순서는 원소값이 저장되는 물리적인 위치와 아주 밀접한 상관이 있다.","배열의 인덱스값을 이용해서 원소값에 직접 접근한다.","배열의 각 원소값의 의미적인 순서는 인덱스의 순서와 일치한다"],
            r : 4,
            img:''
            ,  summary:''
        },
        {//39
            q :  "다음 설명 중 틀린 것은 무엇인가?",
            q1 : '' ,
            a : ["스택은 자료의 삽입과 삭제가 같은 변수를 통해 제어된다.","스택은 객체와 객체가 저장되는 순서를 기억하는 방법에 관한 추상 자료형이다.","스택의 크기는 가변적이다.","후위 표기식은 연산자를 피연산자의 뒤에 표기하는 방법이다"],
            r : 3,
            img:''
            ,  summary:''
        },
        {//40
            q : "다음 큐에 대한 설명으로 틀린 것은 무엇인가?",
            q1 : '' ,
            a : ["원형 큐의 입구(rear 변수)와 출구(front 변수)를 연결하여 데이터 공간을 연속적으로 사용하기 위해 제안되었다.","큐는 서로 다른 부분에서 삽입과 삭제가 바생하는 fifo 특성을 갖는 순서리스트이다.","큐가 가득 차는 경우는 삽입되는 부분의 rear 변수와 삭제되는 부분의 front 변수를 이용하여 찾아낸다.","삽입되는 부분의 rear 변수가 마지막을 가리키면, 큐에 포함된 원소의 갯수는 큐의 크기와 같고 큐가 가득 찬 경우이다"],
            r : 4,
            img:''
            ,  summary:'원형 큐에서 rear 변수가 마지막을 가리킨다고 해서 큐가 가득 찼다는 보장은 없습니다. 큐가 가득 차려면 rear와 front의 위치 관계에 따라 판단해야 하며, rear가 front와 인접해 있을 때 큐가 가득 찬 상태입니다. 큐의 마지막 자리에 있다고 해서 반드시 가득 찬 것은 아니다.'
        },
        {// 41
            q : "단순 연결리스트의 사용되지 않는 마지막 노드의 링크 부분을 활용하기 위해 제안된 리스트는 무엇인가?",
            q1 : '' ,
            a : ["원형 연결 리스트","이중 연결 리스트"," 복합 연결 리스트","순서 연결 리스트"],
            r : 1,
            img:''
            ,  summary:''
        },
        {//42
            q : "다음 이진 트리의 후위순회 결과는 무엇인가?",
            q1 : '' ,
            a : ["ABCD","CABD","DBAC","BCDA"],
            r : 4,
            img:'자료구조201701.JPG'
            ,  summary:`후위 순회(Postorder traversal)는 왼쪽 자식 → 오른쪽 자식 → 루트의 순서로 노드를 방문합니다. 
            주어진 트리에서 후위 순회를 적용해보겠습니다 왼쪽 서브트리: B
오른쪽 서브트리: C의 오른쪽 자식은 D
C의 왼쪽 자식은 없으므로, D를 먼저 방문하고 C를 방문합니다.
루트: A
따라서 후위 순회 결과는 B → D → C → A가 됩니다.
"B->C->D->A"라고 생각했지만, 실제로는 BDCA가 후위 순회 결과입니다`
        },
        {//43
            q : "다음 설명 중 틀린 것은 무엇인가?",
            q1 : '' ,
            a : ["트리는 논리적 계층을 표현하는 자료구조이다.","트리에서 루트는 부모가 없는 노드이다.","트리에서 각 노드의 차수는 진출차수이다."," 이진트리는 모든 노드의 차수가 2인 트리이다."],
            r : 4,
            img:''
            ,  summary:''
        },
        { //44
            q : "널 링크를 이용하여 이진 트리 순회를 편리하고 빠르게 향상시킨 트리는 무엇인가",
            q1 : '' ,
            a : ["경사 이진트리","스레드 이진트리","포화 이진트리","균형 이진트리"],
            r : 2,
            img:''
            ,  summary:''
        },
        { //45
            q : "다음 전위 순회 스레드 트리의 전위 순회에서 빈칸 [가] 에 알맞은 것은 무엇인가?",
            q1 : '' ,
            a : ["p = p->left"," p = p->right;","p = p->left->right;","p = p->right -> left"
            ],
            r : 1,
            img:'자료구조201702.JPG'
            ,  summary:''
        },
        {//47
            q : "선택트리에 대한 설명으로 틀린 것은 무엇인가?",
            q1 : '' ,
            a : ["선택 트리에서는 승자트리와 패자트리가 있다.","패자트리는 루트 노드 위에 최상위 0번 노드를 갖는다.","승자트리는 루트 노드 위에 최상위 0번 노드를 가지며, 각 노드가 두 자식노드보다 더 작은 값을 갖는다","선택트리를 사용하면 정렬을 위한 합병 횟수를 줄일 수 있다."],
            r : 3,
            img:''
            ,  summary:''
        },
        {//48
            q : "자주 탐색하는 키를 가진 노드를 루트에 가깝게 위치하는 트리는 무엇인가?",
            q1 : '' ,
            a : ["Splay 트리","BS트리","BB트리","AVL 트리"],
            r : 1,
            img:''
            ,  summary:`1. Splay 트리 (Splay Tree)
**자기조정 이진 검색 트리(Self-adjusting Binary Search Tree)**입니다.
트리에서 최근에 접근한 노드를 트리의 루트로 이동시킵니다.
이 과정을 Splaying이라고 하며, 빈번하게 접근하는 데이터에 빠르게 접근할 수 있도록 최적화되어 있습니다.
최악의 경우에도 시간 복잡도는 O(n)이지만, 평균적으로 **O(log n)**의 성능을 유지합니다.
삽입, 삭제, 탐색 연산이 모두 splay 과정을 통해 동적으로 트리를 재구성합니다.
2. BS 트리 (Binary Search Tree, BST)
**이진 검색 트리(Binary Search Tree)**는 각 노드의 왼쪽 자식은 부모보다 작고, 오른쪽 자식은 부모보다 큰 특성을 가집니다.
탐색, 삽입, 삭제 연산의 평균 시간 복잡도는 **O(log n)**이지만, 트리가 편향되면 최악의 경우 **O(n)**이 됩니다.
구조가 단순하여 구현하기 쉽지만, 균형이 잘 맞지 않으면 성능이 떨어질 수 있습니다.
3. BB 트리 (Balanced Binary Tree)
균형 이진 트리는 모든 하위 트리의 높이 차이가 일정 범위 내에 있도록 유지되는 트리입니다.
대표적인 예로는 AVL 트리, 레드-블랙 트리 등이 있습니다.
트리의 균형을 유지하기 위해 **삽입, 삭제 연산 시 트리의 재구성(회전)**이 필요합니다.
트리가 균형을 이루기 때문에 탐색, 삽입, 삭제 연산은 **O(log n)**의 시간 복잡도를 보장합니다.
4. AVL 트리 (Adelson-Velsky and Landis Tree)
이진 검색 트리의 일종으로, 자기 균형 이진 검색 트리입니다.
각 노드의 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이가 1 이하로 유지되도록 트리를 관리합니다.
삽입, 삭제 시 트리가 불균형해질 수 있는데, 이를 회전(Rotation) 연산을 통해 균형을 맞춥니다.
항상 균형을 유지하기 때문에 탐색, 삽입, 삭제 연산의 시간 복잡도는 **O(log n)**입니다.`
        },
        { //49
            q : "차수가 m인 B트리의 조건으로 틀린 것은 무엇인가?",
            q1 : '' ,
            a : ["루트와 단발 노드를 제외한 트리의 각 노드는 최소 [m/2]개의 서브트리를 갖는다","트리의 모든 단말 노드는 같은 레벨에 있다","트리의 루트는 퇴소한 2개의 서브트리를 갖는다"," 잎 노드를 순차적으로 연결하는 포인터 집합이 있다"],
            r : 4,
            img:''
            ,  summary:''
        },
        { //50
            q : "다음과 같은 트리는 무엇인가",
            q1 : '' ,
            a : ["이진 트리","1-2 트리","2-3 트리","2-3-4 트리"],
            r : 3,
            img:'자료구조201703.JPG'
            ,  summary:''
        },
        {//51
            q : "그래프에 대한 설명으로 틀린 것은 무엇인가?",
            q1 : '' ,
            a : ["두 정점이 사이클로 연결되었을때, 두 정점이 인접하다고 정의한다.","사이클이 없는 그래프를 트리 혹은 두사이를 그래프라 한다","한 정점에서 출발하여 자신으로 연결하는 간선을 루프라고 한다","시작점과 끝점이 같은 경로를 사이클이라고 한다"],
            r : 1,
            img:''
            ,  summary:''
        },
        { //52
            q : "그래프 G의 모든 정점과 간선의 일부를 포함하는 트리는 무엇인가?",
            q1 : '' ,
            a : ["m원 트리","균형 트리","신장 트리","이진탐색트리"],
            r : 3,
            img:''
            ,  summary:''
        },
        { //53
            q : "다음중 m원 탐색트리에 대한 설명으로 틀린것은 무엇인가? {p0,p1,.....pn은 서브트리에 대한 포인터이고 k0, ....,kn-1은 키값이다. 또한 n<= m-1 이 성립한다)",
            q1 : '' ,
            a : ["노드 vi의 키를 ki라 할때, vi의 왼쪽 서브트리에 있는 모든 노드의 키값은 vi의 키값보다 작다.","i=0,...,n-2 인 i 에 대해 ki < ki+1 를 만족한다 ","i=0,...,n-1인 i에 대해 pi가 가리키는 서브트리의 모든 킷값은 ki의 킷값보다 작다","pn이 가리키는 서브트리의 모든 키값은 kn-1의 킷값보다 크다."],
            r : 1,
            img:''
            ,  summary:''
        },
        { //54
            q : "다음중 B트리에 대한 설명으로 틀린 것은?",
            q1 : '' ,
            a : ["루트와 단말 노드를 제외한 트리의 각 노드는 최소 [m/2]개의 서브트리를 갖는다.","트리의 루트는 최소한 2개의 서브트리를 갖는다","트리의 모든 단말노드는 같은 레벨에 있다","루트가 가장 작은 값을 갖고 부모는 자식보다 작은 값을 갖는다" ],
            r : 4,
            img:''
            ,  summary:''
        },
        {//55
            q : "다수의 간선을 선택하고 그래프의 모든 정점들로 구성된 숲에서 시작하여 최소 비용 신장 트리를 결정하는 방법은 무엇일까?",
            q1 : '' ,
            a : ["Prim 방법","DFS 방법","Kruscal 방법","BFS 방법"],
            r : 3,
            img:''
            ,  summary:`Prim 방법: 하나의 정점에서 시작하여 최소 신장 트리를 만드는 알고리즘.
DFS 방법: 깊이 우선 탐색, 스택이나 재귀를 이용해 그래프를 탐색.
Kruskal 방법: 간선의 가중치를 기준으로 최소 신장 트리를 만드는 알고리즘.
BFS 방법: 너비 우선 탐색, 큐를 이용해 레벨별로 탐색.`
        },
        {//56
            q : "다음은 스택의 연산들이다, 6을 수행한 결과는 무엇인가?",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 4,
            img:'자료구조201704.JPG'
            ,  summary:''
        },
        {//57
            q : "다음은 G1에 대한 인접리스트를 표현한 것이다. G1에 대한 그래프로 알맞은 것은?",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 1,
            img:'자료구조201705.JPG'
            ,  summary:''
        },
        {//58
            q : "다음은 깊이 우선 탐색(DFS) 알고리즘의 의사코드이며 해당 코드는 순환 호출을 이용하는 경우이다. 이때 [그림1]의 v7 노드에 방문하기 위해선 몇번의 7 코드가 실행되는가?",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 3,
            img:'자료구조201706.JPG'
            ,  summary:''
        },
        {
            q : "다음은 큐를 이용한 너비 우선 탐색(BFS) 알고리즘의 의사코드이다. 아래의 코드에서 빈 칸 ㄱ, ㄴ에 들어갈 알맞은 코드는 무엇인가?",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 2,
            img:'자료구조201707.JPG'
            ,  summary:''
        },
        {
            q : "위의 [그림1]을 너비 우선 탐색(BFS) 알고리즘으로 탐색할 때의 노드 방문순서로 옳은 결과는 무엇인가?",
            q1 : '' ,
            a : ["v1,v2,v4,v5,v3,v6,v7","v1,v2,v3,v6,v5,v4,v7","v1,v2,v3,v4,v5,v6,v7","v1,v2,v4,v7,v3,v5,v6"],
            r : 3,
            img:'자료구조201708.JPG'
            ,  summary:''
        },
        
    ]
    const test2018db :Testtype[] =[
        {//36
            q : "I=P(D)의 해석으로 옳은것은?",
            q1 : '' ,
            a : ["정보는 자료를 처리해서 얻어진 결과다","정보는 결과를 처리해서 얻어진 자료이다","자료는 결과를 처리해서 얻어진 정보다","자료는 정보를 처리해서 얻어진 결과다"],
            r : 1,
            img:''
            ,  summary:''
        },
        {//37
            q : "자료구조의 유형 중 미리 정의된 자료구조인 것은 무엇인가",
            q1 : '' ,
            a : ["배열","스택","큐","트리"],
            r : 1,
            img:''
            ,  summary:''
        },
        {//38
            q : "다음 수식을 전위 표기식으로 바르게 나타낸 것은?",
            q1 : '' ,
            a : ["++AB*CD","ABCD++*","++*ABCD","AB+B+C*"],
            r : 1,
            img:'자료구조2018.JPG'
            ,  summary:''
        },
        {//39
            q : "다음 일반 트리를 이진트리로 변환한 것으로 옳은 것은?",
            q1 : '' ,
            a :  ["1","2","3","4"],
            r : 1,
            img:'자료구조201801.JPG'
            ,  summary:''
        },
        {//40
            q : "알고리즘의 조건에 포함되지 않는 것은?",
            q1 : '' ,
            a : ["출력","입력","절대성","유한성"],
            r : 3,
            img:''
            ,  summary:''
        },
        {//41
            q : "인덱스와 원소값(<index, value>)의 쌍으로 구성된 집합이며 정의된 각 인덱스는 그 인덱스와 관련된 값으로 정의되는 자료구조는 무엇인가?",
            q1 : '' ,
            a : ["리스트","스택","배열","큐"],
            r : 3,
            img:''
            ,  summary:''
        },
        {//42
            q : "다음과 같은 행렬이 행우선 방식으로 저장된다면, [3,4]의 다음에 저장되는 행렬의 원소는 무엇인가?",
            q1 : '' ,
            a : ["[3,5]","[3,3]","[4,4]","[4,3]"],
            r : 1,
            img:'자료구조201802.JPG'
            ,  summary:''
        },
        {//43
            q : "다음은 스택에 대한 연산이다. 교재에 기술된 스택의 추상자료형을 따른다면, 8 연산을 수행한 후의 스택의 모습은 무엇인가?",
            q1 : '' ,
            a :  ["1","2","3","4"],
            r : 1,
            img:'자료구조201803.JPG'
            ,  summary:''
        },
        {//44
            q : "큐의 운용과 유사하게 운영되는 것이 아닌 것은 무엇인가",
            q1 : '' ,
            a : ["문서 출력을 위해 프린터기를 이용할 때, 여러개의 문서를 출력해도 먼저 인쇄버튼을 누른 문서부터 차례로 출력된다.","은행에서 번호표를 뽑고 창구에 가기를 기다린다","택시 승강장에서 택시를 기다린다","웹브라우저에서 방금전 방문했던 사이트 기록 저장 후 이전페이지로 돌아가기를 클릭한다"],
            r : 4,
            img:''
            ,  summary:''
        },
        {//45
            q : "다음은 큐에대한 연산이다 교재에 기술된 큐의 추상자료형을 따른다면 8 연산을 수행한 후의 스택 모습은 무엇인가?",
            q1 : '' ,
            a :  ["1","2","3","4"],
            r : 3,
            img:'자료구조201804.JPG'
            ,  summary:'그림이 잘못되었다 맨 밑에칸에 D가 있어야하는데  위치가 2번째 칸으로 되어있어 틀림 정답은 없는상태임'
        },
        {// 46
            q : "단순 연결리스트의 사용되지 않는 마지막 노드의 링크 부분을 활용하기 위해 제안된 리스트는 무엇인가?",
            q1 : '' ,
            a : ["이중 연결 리스트","원형 연결 리스트","회전 연결 리스트","중복 연결 리스트"],
            r : 2,
            img:''
            ,  summary:''
        },
        {// 47
            q : "사용하지 않는 포인터를 이용하여 이진 트리 순회를 편리하고 빠르게 향상시킨 트리는 무엇인가",
            q1 : '' ,
            a : ["탐색 이진트리","스레드 이진트리"," 포화이진트리","완전 이진트리"],
            r : 2,
            img:''
            ,  summary:''
        },
        {//48
            q : "각 노드가 두개의 자식노드 보다 더 큰 값(패자)을 가지며 최종 승자는 0번 노드에 저장하는 트리는 무엇인가?",
            q1 : '' ,
            a : ["선택 트리","패자트리","승자트리"," AVL트리"],
            r : 2,
            img:''
            ,  summary:`1. 선택 트리 (Selection Tree)
선택 트리는 여러 정렬된 리스트에서 최소값을 빠르게 선택하기 위해 사용되는 트리 구조입니다.
다수의 정렬된 입력에서 가장 작은 값을 선택하는 작업을 효율적으로 처리합니다.
이 트리는 일반적으로 최소값을 찾고, 그 값을 빼내면서 새로운 최소값을 트리에 삽입하는 과정을 반복합니다.
**K-방향 병합(K-way merging)**에서 주로 사용됩니다.
2. 패자 트리 (Loser Tree)
패자 트리는 선택 트리의 일종으로, K개의 정렬된 리스트에서 최소값을 선택하는 트리입니다.
각 노드는 패배자(비교에서 작은 값을 가진 노드)를 저장합니다.
트리의 루트에는 승자(가장 작은 값)가 위치하지 않으며, 승자가 아닌 값이 트리 내부 노드에 저장되는 방식입니다.
최소값을 찾는 연산과 다음 최소값을 구하는 연산이 효율적으로 처리됩니다.
3. 승자 트리 (Winner Tree)
승자 트리는 패자 트리와 반대로, K개의 정렬된 리스트에서 **승자(최소값)**를 저장하는 트리입니다.
트리의 루트에는 항상 가장 작은 값이 저장됩니다.
승자 트리는 각 노드가 두 자식 중 큰 값을 저장하고, 루트에는 전체 트리에서 가장 작은 값이 위치합니다.
트리를 갱신할 때, 루트에서 리프까지 경로만 갱신하면 되므로 효율적입니다.
4. AVL 트리 (Adelson-Velsky and Landis Tree)
AVL 트리는 **자기 균형 이진 검색 트리(Self-balancing Binary Search Tree)**입니다.
각 노드에서 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이가 1 이하로 유지됩니다.
삽입이나 삭제 시 트리의 균형이 깨지면 회전(Rotation) 연산을 통해 균형을 맞춥니다.
탐색, 삽입, 삭제 연산의 시간 복잡도가 항상 **O(log n)**을 보장합니다.
트리의 균형을 유지하기 위해 추가적인 작업이 필요하지만, 항상 빠른 탐색 속도를 제공합니다.`
        },
        {//49
            q : "트리에 속한 잎 노드의 개수를 무엇이라 하는가?",
            q1 : '' ,
            a : ["트리의 깊이","트리의 높이","트리의 무게","트리의 경로"],
            r : 3,
            img:''
            ,  summary:''
        },
        {//50
            q : "노드 vi의 왼쪽 서브트리 높이와 vi의 오른쪽 서브트리 높이가 최대 1만큼 차이난다는 조건을 만족하는 트리는 무엇인가?",
            q1 : '' ,
            a : ["Splay트리"," BS트리","BB트리","AVL트리"],
            r : 4,
            img:''
            ,  summary:''
        },
        {//51
            q : "그래프에 대한 설명으로 옳은 것은 무엇인가?",
            q1 : '' ,
            a : ["사이클이 없는 그래프를 트리라고 한다","두 정점이 사이클로 연결되었을 때 , 두 정점이 인접한다고 정의한다"," 시작점과 끝점이 같은 경로를 루프라고 한다.","한 정점에서 출발하여 자신으로 연결하는 간선을 사이클이라고 한다."],
            r : 1,
            img:''
            ,  summary:''
        },
        {//52
            q : "다음과 같은 트리는 무엇인가?",
            q1 : '' ,
            a : ["이진 트리","1-2 트리","2-3 트리","2-3-4 트리"],
            r : 4,
            img:'자료구조201805.JPG'
            ,  summary:`이진 트리: 각 노드는 최대 2개의 자식을 가짐.
1-2 트리: 각 노드는 1개 또는 2개의 자식을 가짐.
2-3 트리: 각 노드는 2개 또는 3개의 자식을 가짐. 모든 리프 노드의 깊이가 같음.
2-3-4 트리: 각 노드는 2개, 3개, 또는 4개의 자식을 가짐. 삽입, 삭제 시 트리가 균형을 유지함.`
        },
        {//53
            q : "다음중 B트리에 대한 설명으로 옳은 것은 무엇인가?",
            q1 : '' ,
            a : ["트리의 루트는 최소한 3개의 서브트리를 갖는다","트리의 모든 잎 노드는 같은 레벨에 있다.","루트가 가장 작은 값을 갖고 부모는 자식보다 작은 값을 갖는다","루트와 잎 노드를 제외한 트리의 각 녿느느 최소 [m/3]개의 서브트리를 갖는다."],
            r : 2,
            img:''
            ,  summary:''
        },
        {// 54
            q : "남은 간선중에서 무조건 최소 비용인 간선을 선택한 후 사이클을 형성하지 않으면 그 간선을 선택하는 최소 비용 신장트리 결정방법은 무엇인가?",
            q1 : '' ,
            a : ["Prim방법","DFS 방법","Kruscal 방법","BFS 방법"],
            r : 3,
            img:''
            ,  summary:`Prim 방법: 시작 정점에서 시작해 최소 가중치 간선을 선택해 최소 신장 트리를 만드는 탐욕 알고리즘.
DFS 방법: 깊이 우선 탐색으로 스택이나 재귀 호출을 사용해 그래프의 끝까지 탐색하는 방법.
Kruskal 방법: 모든 간선 중 최소 가중치를 차례로 선택해 최소 신장 트리를 만드는 탐욕 알고리즘.
BFS 방법: 너비 우선 탐색으로 큐를 사용해 가까운 노드부터 탐색하는 방법, 최단 경로 탐색에 유용.`
        },
        {// 55
            q : "두 정점쌍이 간선을 여러개 가질 수 있는 그래프를 무엇이라고 하는가?",
            q1 : '' ,
            a : ["중복 그래프"," 무방향 그래프","다중 그래프","단순 그래프"],
            r : 3,
            img:''
            ,  summary:''
        },
        {// 56
            q : "다음 프로그램은 교재에서 정의된 이중 연결 리스트에 새 노드를 삽입하는 연산이다. 프로그램의 흐름상 다음 빈칸 ㄱ 에 들어갈 알맞은 코드는 무엇인가?",
            q1 : '' ,
            a : ["NewNode -> Rlink -> Link = NewNode","prevNode -> Link ->Rlink = NewNode","prevNode -> Rlink -> Link = NewNode","NewNode -> Rlink -> Link = prevNode"],
            r : 1,
            img:'자료구조201806.JPG'
            ,  summary:''
        },
        {// 57
            q : "다음 표에서 (가),(나)의 순서대로 가장 적합한 내용은 무엇인가?",
            q1 : '' ,
            a : ["프로그램. 알고리즘","자료구조, 알고리즘","슈도 코드, 프로그램","알고리즘, 프로그램"],
            r : 4,
            img:'자료구조201807.JPG'
            ,  summary:''
        },
        {// 58
            q : "다음은 깊이 우선탐색(DFS)알고리즘의 의사코드이며 해당 코드는 순환 호출을 이용하는 경우이다. 다음 알고리즘에서 ㄱ 과 ㄴ 에 들어갈 알맞은 명령어는 무엇인가?",
            q1 : '' ,
            a : ["ㄱ : VISITED[v] =0; ㄴ: if(!q_empty())","ㄱ : VISITED[v] = 0;  ㄴ : if(VISITED[w])","ㄱ : VISITED[v] = 1  ㄴ: if(!VISITED[w])","ㄱ : VISITED[v] = 1   ㄴ : if(!VISITED[v])"],
            r : 3,
            img:'자료구조201808.JPG'
            ,  summary:''
        },
        {//
            q : "다음 배열을 이용해 스택을 구현하고 스택에 데이터를 삽입하는 과정을 나타내는 코드이다 [가]에 들어갈 코드로 가장 알맞은 것은 무엇인가?",
            q1 : '' ,
            a : ["top == -1","top >= STACK_SIZE - 1"," top >= STRACK_SIZE","top <= STACK_SIZE"],
            r : 2,
            img:'자료구조201809.JPG'
            ,  summary:''
        },
        {// 
            q : "다음 프로그램은 최소 힙에서 데이터를 삽입하는 프로그램이다. 아래 그림은 최소 힙에 새 노드를 삽입하기 위해 마지막 노드에 새노드인 7이 위치한 모습이다. 새 노드인 7이 삽입한 후 완전한 최소 힙이 되도록 하려면 [가] 부분이 몇번 이루어져야 하는가?",
            q1 : '' ,
            a : ["0","1","2","3"],
            r : 3,
            img:'자료구조201810.JPG'
            ,  summary:`최소 힙에서 데이터를 삽입하는 과정
데이터 추가: 먼저 데이터를 힙의 마지막 자리에 추가합니다. 힙은 완전 이진 트리이므로, 트리의 가장 오른쪽 리프 노드 자리에 데이터를 삽입합니다.

부모와 비교: 삽입한 데이터가 부모 노드보다 작은지 확인합니다. 만약 삽입된 노드의 값이 부모 노드보다 작으면, 두 값을 교환합니다.

재귀적 비교: 교환 후, 부모 노드와의 관계를 다시 확인하고, 더 이상 부모 노드보다 작지 않을 때까지 위로 올라가며 비교를 반복합니다.

최종 정렬 완료: 부모보다 작은 값이 없거나 루트에 도달하면 힙이 완성됩니다.`
        },
    ]
    const test2019db :Testtype[] =[
        {//36
            q : "다음의[가]에 들어갈 내용으로 알맞은 것은?",
            q1 : '' ,
            a : ["알고리즘","정보","추상화","데이터"],
            r : 3,
            img:'자료구조2019.JPG'
            ,  summary:''
        },
        {//37
            q : "배열에 대한 내용으로 알맞지 않은 것은 무엇인가?",
            q1 : '' ,
            a : ["배열은 인덱스와 원소값의 쌍으로 구성된 집합이다.","원소들 마다 기억 공간의 크기가 다르다"," 원소들이 모두 같은 자료형을 가진다"," 인덱스 값으로 직접 접근이 가능하다"],
            r : 2,
            img:''
            ,  summary:''
        },
        {//38
            q : "스택을 이용하여 A+B*C연산을 후위표기식으로 변환할 경우 스택의 그림 순서로 알맞은 것은 무엇인가?",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 1,
            img:'자료구조201901.JPG'
            ,  summary:''
        },
        {//
            q : "원형큐에 대한 설명으로 알맞은 것은 무엇인가?",
            q1 : '' ,
            a : ["메모리 공간을 50%만 사용하게 되어 비효율적이다.","큐가 만원 상태인 경우 원소의 개수가 n-1개이다","front 값으로만 큐의 만원 상태를 판단한다","나머지 계산하는 mod 연산자를 사용하여 rear 값을 관리하게 한다."],
            r : 2,
            img:''
            ,  summary:` 정답이 2개 2,4번
            1. "메모리 공간을 50%만 사용하게 되어 비효율적이다."
오답: 원형 큐는 메모리 공간을 효율적으로 사용하기 위한 자료구조입니다. 선형 큐에서는 메모리 공간이 제한되면, 삭제된 공간을 다시 사용할 수 없는 문제가 있지만, 원형 큐는 이러한 문제를 해결합니다. 따라서 메모리를 비효율적으로 사용하지 않습니다.
2. "큐가 만원 상태인 경우 원소의 개수가 n-1개이다."
정답: 원형 큐에서는 큐가 가득 차면 rear와 front가 같아지는 상황을 피하기 위해, 실제로 큐의 크기가 n인 경우, n-1개의 원소를 저장하고 하나의 공간을 비워 둡니다. 이 공간이 없으면 큐가 빈 상태와 가득 찬 상태를 구별할 수 없기 때문에 공간을 하나 남겨둡니다.
3. "front 값으로만 큐의 만원 상태를 판단한다."
오답: 큐가 가득 찬 상태는 front와 rear의 상대적 위치로 판단됩니다. 즉, front 값만으로는 큐가 가득 찬 상태를 알 수 없습니다. 일반적으로 front가 rear 바로 뒤에 위치할 때 큐가 가득 찼다고 판단합니다.
4. "나머지 계산하는 mod 연산자를 사용하여 rear 값을 관리하게 한다."
정답: 원형 큐에서는 인덱스가 끝에 도달했을 때 다시 처음으로 돌아가도록 mod 연산을 사용합니다. rear와 front는 mod 연산을 사용하여 배열의 크기를 넘지 않도록 관리됩니다. 이 방식으로 원형 구조를 구현할 수 있습니다.`
        },
         {//40
            q : " 다음은 연결 리스트 프로그램의 일부이다. 현재 헤드 노드만 존재하며, x값은 100이라고 가정하고 NewNode의 주소값은 5000 이라고 가정할 때, 결과 상태를 그림으로 표현한 것으로 알맞은 것은 무엇인가?",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 2,
            img:'자료구조201902.JPG'
            ,  summary:''
        },
         {//
            q : "다음 연산들을 수행할 경우 4번 연산의 결과는 무엇인가?",
            q1 : '' ,
            a :  ["1","2","3","4"],
            r : 1,
            img:'자료구조201903.JPG'
            ,  summary:''
        },
         {//42
            q : "다음 그림과 같이 높이가 k인 이진 트리가 레빌 0부터 레벨 k-2까지 다 채우고 마지막 레벨 k-1에서는 왼쪽부터 오른쪽으로 노드들이 차례로 채워진 이진트리를 무엇이라고 하는가?",
            q1 : '' ,
            a :  ["1","2","3","4"],
            r : 2,
            img:'자료구조201904.JPG'
            ,  summary:''
        },
         {//
            q : "다음 스레드 트리는 어떤 방문순서로 순회하는 것을 나타낸 것인가?",
            q1 : '' ,
            a :  ["1","2","3","4"],
            r : 3,
            img:'자료구조201905.JPG'
            ,  summary:''
        },
         {//44
            q : "대기 리스트에서 항상 우선순위가 높은 사람이 먼저 서비스를 받는 구조는 무엇인가",
            q1 : '' ,
            a : ["우선순위 스택","우선순위 큐","우선순위 리스트","우선순위 배열"],
            r : 2,
            img:''
            ,  summary:''
        },
         {//
            q : "트리의 각 내부 노드가 두 자식 노드 값의 승자를 자신의 값으로 하며, 각 노드는 두 자식 노드보다 더 작은 값을 갖는 선택트리는 무엇인가?",
            q1 : '' ,
            a : ["승자 트리","패자트리","힙트리"," 스레드 트리"],
            r : 1,
            img:''
            ,  summary:''
        },
         {//46
            q : "높이가 균형 잡힌 높이 균형 트리로 다음과 같은 조건을 만족 할 때 그 트리의 높이가 균형 잡혔다고 하는 트리는 무엇인가?",
            q1 : '' ,
            a : ["AVL트리","선택트리","3원탐색트리","스레드 트리"],
            r : 1,
            img:'자료구조201906.JPG'
            ,  summary:`1. AVL 트리
높이 균형 이진 탐색 트리로, 각 노드에서 왼쪽과 오른쪽 서브트리의 높이 차이가 1 이하로 유지됩니다.
삽입과 삭제 시 **균형 조정(회전)**이 필요하여, 탐색, 삽입, 삭제의 시간 복잡도는 **O(log N)**입니다.
2. 선택 트리 (Winner Tree)
K-way 병합 정렬에서 사용되며, 각 내부 노드는 두 자식 노드의 값 중 더 작은 값을 선택합니다.
루트에 최종 승자가 위치하며, 가장 작은 값을 효율적으로 찾을 수 있습니다.
3. 3원 탐색 트리 (Ternary Search Tree)
각 노드가 세 개의 자식을 가지는 탐색 트리로, 문자열 탐색에서 유용하게 사용됩니다.
가운데 자식이 키 값과 같고, 왼쪽 자식은 작은 값, 오른쪽 자식은 큰 값을 가집니다.
4. 스레드 트리 (Threaded Tree)
이진 트리에서 비어 있는 포인터를 이용해 노드 간 중위 순회를 쉽게 할 수 있도록 연결한 트리입니다.
일반적인 트리보다 공간 효율성을 높여 트리 순회를 빠르게 수행합니다.`
        },
         {//47
            q : "현실 세계에서 관찰이나 측정을 통해서 수집된 값이나 사실을 무엇이라 하는가",
            q1 : '' ,
            a : ["자료","정보","추상데이터","추상데이터 형"],
            r : 1,
            img:''
            ,  summary:''
        },
         {// 
            q : "다음 희소행렬을 배열로 표현할 경우, 희소행렬 배열 표기로 표현할 경우에 첫 번째 행에 저장되는 값은 무엇인가?",
            q1 : '' ,
            a : ["1,2,20","0,1,20","8,9,10","9,8,10"],
            r : 3,
            img:'자료구조201907.JPG'
            ,  summary:`주어진 행렬은 대부분의 요소가 0인 **희소 행렬(Sparse Matrix)**입니다. 희소 행렬을 효율적으로 표현하기 위해 일반적으로 3중 배열 형태로 저장합니다. 이 방식에서는 비어 있지 않은(non-zero) 값만 저장하여 메모리 사용을 최소화합니다.

3중 배열 표현법 (Triplet Representation)
희소 행렬을 배열로 표현할 때, 각 비어 있지 않은 값의 행 번호(row), 열 번호(column), **값(value)**을 저장합니다. 즉, 이 3개의 요소로 하나의 비어 있지 않은 요소를 나타냅니다. 첫 번째 행에는 전체 행렬의 정보가 포함되며, 다음과 같은 값들을 저장합니다:

총 행의 수 (행렬의 행 개수)
총 열의 수 (행렬의 열 개수)
비어 있지 않은 값의 개수 (행렬 내에서 0이 아닌 값의 개수) 위 문제에서는 총 10개임`
        },
         {//49
            q : "다음과 같은 행렬이 열우선 방식으로 저장된다면, [5,3]의 다음에 저장되는 행려의 원소는 무엇인가?",
            q1 : '' ,
            a : ["[3,5]","[5,4]","[4,4]","[6,3]"],
            r : 4,
            img:'자료구조201908.JPG'
            ,  summary:''
        },
         {//50
            q : "다음은 큐에 대한 연산이다, 교재에 기술된 큐의 추상자료형을 따른다면 6 연산을 수행한 후의 큐의 모습은 무엇인가",
            q1 : '' ,
            a : ["1","2","3","4"],
            r : 2,
            img:'자료구조201909.JPG'
            ,  summary:''
        },
         {//
            q : "단순연결 리스트의 각 노드에서 선행 노드 검색의 문제점을 해결하기 위해 제안된 리스트는 무엇인가?",
            q1 : '' ,
            a : ["이중 연결 리스트","원형연결리스트","회전 연결 리스트","중복 연결리스트"],
            r : 1,
            img:''
            ,  summary:`1. 이중 연결 리스트 (Doubly Linked List)
각 노드가 앞쪽 노드와 뒤쪽 노드에 대한 포인터를 가집니다.
양방향으로 노드를 탐색할 수 있어 삽입, 삭제 시 효율적입니다.
2. 원형 연결 리스트 (Circular Linked List)
마지막 노드가 첫 번째 노드를 가리키는 연결 리스트로, 리스트의 끝에서 다시 처음으로 돌아갑니다.
연속적인 순회가 필요한 경우 유용합니다.
3. 회전 연결 리스트 (Rotating Linked List)
특정 노드를 기준으로 리스트를 회전시켜 첫 노드로 설정한 연결 리스트입니다.
데이터의 회전 처리 및 관리에 사용됩니다.
4. 중복 연결 리스트 (Multi-linked List)
하나의 노드가 여러 리스트에 중복으로 연결된 구조를 가집니다.
여러 경로를 통해 동일한 노드에 접근할 수 있으며, 복잡한 데이터 구조에 사용됩니다.`
        },
         {//52
            q : "리스트를 배열로 구현했을 경우에 대한 설명으로 틀린 것은 무엇인가?",
            q1 : '' ,
            a : ["삽입에 따른 원소의 이동이 발생한다","포인터를 이용한 구현보다 메모리를 절약할 수 있다","삭제에 따른 원소의 이동을 줄일 수 있다.","논리적 순서와 물리적 순서(메모리에 적재된 원소의 순서)가 동일하다"],
            r : 3,
            img:''
            ,  summary:`1. 삽입에 따른 원소의 이동이 발생한다
맞습니다. 배열에서 중간에 원소를 삽입하면, 해당 위치 이후의 모든 원소를 한 칸씩 뒤로 이동시켜야 합니다. 예를 들어, 배열 [1, 2, 3, 4] 에서 두 번째 위치에 5를 삽입하면 [1, 5, 2, 3, 4]가 되며, 2, 3, 4가 한 칸씩 이동합니다.

2. 포인터를 이용한 구현보다 메모리를 절약할 수 있다
맞습니다. 배열은 연속된 메모리 공간에 저장되기 때문에 추가적인 메모리 오버헤드가 없습니다. 반면, 포인터를 이용한 연결 리스트는 각 노드가 데이터와 함께 다음 노드의 주소(포인터)를 저장해야 하므로 메모리 사용이 더 늘어날 수 있습니다.

3. 삭제에 따른 원소의 이동을 줄일 수 있다
틀렸습니다. 배열에서 원소를 삭제하면, 해당 위치 이후의 모든 원소를 한 칸씩 앞으로 이동시켜야 합니다. 예를 들어, 배열 [1, 2, 3, 4] 에서 두 번째 원소 2를 삭제하면 [1, 3, 4]가 되며, 3과 4가 한 칸씩 이동합니다. 따라서 삭제에 따른 원소의 이동을 줄일 수 없습니다.

4. 논리적 순서와 물리적 순서(메모리에 적재된 원소의 순서)가 동일하다
맞습니다. 배열은 연속된 메모리 위치에 저장되므로, 배열의 논리적 순서와 메모리에 저장된 물리적 순서가 동일합니다. 예를 들어, 배열 [1, 2, 3, 4] 에서 1이 메모리의 첫 번째 위치에, 2가 두 번째 위치에, 이렇게 순서대로 저장됩니다.`
        },
         {//
            q : "포인터를 이용한 리스트의 구현에서 노드 삽입에 관한 설명으로 옳은 것은 무엇인가?",
            q1 : '' ,
            a : ["가-나-다","다-나-가","나-가-다","나-다-가"],
            r : 1,
            img:'자료구조201910.JPG'
            ,  summary:''
        },
         {//54
            q : "연결리스트 그림에 대한 설명으로 틀린 것은 무엇인가?",
            q1 : '' ,
            a : ["C언어로 구현한다면 포인터 변수로 구현된다.","ㄴ에는 데이터 필드에 해당한다.","head는 링크 필드만 갖는다.","마지막 노드의 포인터는 head에 대한 주소값을 갖는다."],
            r : 4,
            img:'자료구조201911.JPG'
            ,  summary:''
        },
         {//55
            q : "이진트리에 대한 설명으로 틀린 것은 무엇인가?",
            q1 : '' ,
            a : ["모든 노드의 차수가 2 이하인 트리이다.","컴퓨터 내부에서 구현하기도 쉽고, 메모리의 소모가 다른 트리에 비해서 효율적이다.","모든 노드가 2개의 자식 노드를 가진다.","일반성을 잃지 않고 '오른쪽','왼쪽'이라는 방향 개념을 부여할 수 도 있다."],
            r : 3,
            img:''
            ,  summary:''
        },
         {//
            q : "아래의 문장을 수식으로 표현한 것으로 알맞은 것은 무엇인가? (R : 결과, D :  자료, P:처리)",
            q1 : '' ,
            a : ["R = P(D)","P = I(R)","R= D(P)","I= P(D)"],
            r : 4,
            img:'자료구조201912.JPG'
            ,  summary:`1강 수업 6분 화면에서 i=p(d)라고 명시하고 있다.`
        },
         {//57
            q : "아래의 그림을 너비 우선 탐색(BFS)알고리즘으로 탐색할 때의 노드 방문 순서로 옳은 결과는 무엇인가? (시작점 v1)",
            q1 : '' ,
            a : ["v1,v2,v4,v5,v3,v6,v7","v1,v2,v3,v6,v5,v4,v7","v1,v3,v2,v6,v5,v4,v7","v1,v3,v2,v4,v6,v5,v7"],
            r : 3,
            img:'자료구조201913.JPG'
            ,  summary:''
        },
         {// 58
            q : "다음중 B트리에 대한 설명으로 옳은 것은 무엇인가",
            q1 : '' ,
            a : ["루트와 단말 노드를 제외한 트리의 각 노드는 최소 [2/m]개의 서브 트리를 갖는다","트리의 루트는 최소한 3개의 서브트리를 갖는다","트리의 모든 노드는 같은 레벨에 있다","루트가 가장 작은 값을 갖고 부모는 자식보다 작은 값을 갖는다."],
            r : 1,
            img:''
            ,  summary:`B-트리(B-tree)는 균형 잡힌 검색 트리로, 대용량 데이터를 디스크에 효율적으로 저장하고 검색할 때 사용되는 자료구조입니다. 주로 데이터베이스나 파일 시스템에서 활용되며, 이진 탐색 트리의 확장 버전입니다. B-트리의 주요 특징은 다음과 같습니다:

균형 유지: 트리의 모든 리프 노드가 같은 깊이를 가지며, 삽입과 삭제가 이루어져도 트리의 균형이 유지됩니다. 이는 트리의 깊이를 최소화하여 검색 속도를 일정하게 유지하게 해줍니다.

다중 자식 노드: B-트리의 각 노드는 두 개 이상의 자식을 가질 수 있습니다. 즉, 각 노드는 여러 키와 자식을 가지며, 이를 통해 트리의 높이를 줄여 효율적인 검색이 가능해집니다.

디스크 입출력 최소화: B-트리는 노드 하나에 여러 데이터를 저장해 한 번에 많은 양의 데이터를 읽고 쓰도록 설계되었습니다. 이로 인해 대용량 데이터 처리에 적합합니다.

삽입/삭제 효율성: B-트리는 삽입과 삭제 연산이 자동으로 트리의 균형을 유지하면서 수행됩니다. 노드 분할과 병합을 통해 항상 균형 잡힌 상태를 유지합니다.

높이 제어: 노드의 자식 수를 제어하는 매개변수(차수)가 있어서, 트리의 높이를 제한하고 검색, 삽입, 삭제 성능을 보장합니다.`
        },
         {//
            q : "그래프 G의 모든 정점과 간선의 일부를 포함하는 트리는 무엇인가?",
            q1 : '' ,
            a : ["완전 이진트리","B트리","신장트리","포화이진트리"],
            r : 3,
            img:''
            ,  summary:`완전 이진 트리: 마지막 레벨을 제외하고 모든 레벨이 꽉 차 있으며, 마지막 레벨은 왼쪽부터 순차적으로 채워진 이진 트리.
B-트리: 다중 자식을 가지는 균형 잡힌 검색 트리로, 데이터베이스와 파일 시스템에서 대용량 데이터 처리를 효율화함.
신장 트리 (Spanning Tree): 그래프의 모든 정점을 포함하면서 사이클이 없는 최소 연결 그래프.
포화 이진 트리: 모든 레벨이 꽉 차서 모든 내부 노드가 두 자식을 가지는 이진 트리.`
        },
         {//60
            q : "그래프에 대한 설명으로 옳은 것은 무엇인가?",
            q1 : '' ,
            a : ["두 정점이 사이클로 연결되었을 때, 두 정점이 인접한다고 정의한다"," 사이클이 없는 그래프를 가중 그래프라 한다"," 한 정점에서 출발하여 자신으로 연결하는 간선을 사이클이라고 한다.","다중 그래프는 두 정점을 잇는 간선이 여러개인 그래프이다."],
            r : 4,
            img:''
            ,  summary:''
        },
    ]
    const test2019cs :Testtype[] =[
        {//
            q : "다음 컴퓨터 명령어를 구성하는 연산코드 필드(OP codefield)에 대한 설명으로 가장 적절한 것은?",
            q1 : '' ,
            a : ["기억장치 주소 혹은 처리장치 레지스터를 선택하기 위한 필드이다.","명령어의 주소지정 방식을 지정하는 필드이다.","중앙처리장치에서 수행할 연산을 지정하는 필드이다","인터럽트 요청을 위한 제어필드이다."],
            r : 3,
            img:''
            ,  summary:''
        },
        {// 2
            q : "다음 컴퓨터 명령어에 관한 설명으로 적절한 것은?",
            q1 : '' ,
            a : ["2-주소 컴퓨터 명령어이다","데이터 전송을 위한 컴퓨터 명령어이다","컴퓨터의 내부구조로 볼 때 누산기를 이용하는 컴퓨터 명령어이다"," 컴퓨터의 내부구조로 볼 때 다중 레지스터를 이용하는 컴퓨터 명령어이다."],
            r : 3,
            img:'컴퓨터구조2019.JPG'
            ,  summary:''
        },
        {//3 
            q : "위의 프로그램은 다음 중 어느 수식을 계산하는 것인가?",
            q1 : '' ,
            a : ["X= ( A + B ) * C","X = ( A - B ) * C","X = ( A + B ) / C","X = ( A - B ) + C"],
            r : 2,
            img:'컴퓨터구조201901.JPG'
            ,  summary:''
        },
        {//
            q : "프로그램에서 (a)의 괄호안에 들어갈 식으로 알맞은 것은?",
            q1 : '' ,
            a : ["AC <- AC * M[X]" , "AC <-M[A]","AC<-M[X]","M[X] <- AC"],
            r : 2,
             img:'컴퓨터구조201901.JPG'
            ,  summary:''
        },
        {//
            q : "위의 프로그램과 관계가 깊은 명령어 형식은?",
            q1 : '' ,
            a : ["3-주소 명령어","2-주소 명령어","1-주소 명령어","0-주소 명령어"],
            r : 3,
            img:'컴퓨터구조201901.JPG'
            ,  summary:`1. 3-주소 명령어 (Three-address instruction)
설명: 3-주소 명령어는 연산에 필요한 두 개의 피연산자와 결과를 저장할 목적지 주소를 모두 명시하는 명령어입니다.
형식: ADD R1, R2, R3
R1에 R2와 R3를 더한 결과를 저장.
장점: 연산에 필요한 데이터와 결과를 각각의 레지스터나 메모리에 명확히 지정할 수 있어 코드가 간결해짐.
단점: 명령어가 길어질 수 있으며, 더 많은 레지스터나 메모리 주소가 필요함.
2. 2-주소 명령어 (Two-address instruction)
설명: 2-주소 명령어는 피연산자 중 하나가 결과를 저장할 대상과 같은 주소를 사용합니다. 즉, 하나의 피연산자는 연산 후 덮어씌워집니다.
형식: ADD R1, R2
R1에 R2를 더하고 결과를 R1에 저장.
장점: 명령어 길이가 짧고, 주소 공간을 절약할 수 있음.
단점: 결과가 피연산자 중 하나를 덮어씌우기 때문에 추가적인 메모리 이동 명령이 필요할 수 있음.
3. 1-주소 명령어 (One-address instruction)
설명: 1-주소 명령어는 주로 누산기(Accumulator)를 사용하여 연산을 수행합니다. 피연산자 하나는 명시하고, 다른 하나는 누산기에 암묵적으로 존재합니다.
형식: ADD R1
누산기에 저장된 값에 R1을 더하고 결과를 누산기에 저장.
장점: 명령어가 매우 간단하고 짧음.
단점: 누산기를 계속 사용해야 하므로 유연성이 떨어짐.
4. 0-주소 명령어 (Zero-address instruction)
설명: 0-주소 명령어는 주로 스택 기반 구조에서 사용됩니다. 피연산자는 스택에서 암묵적으로 가져오고, 연산 결과도 스택에 저장됩니다.
형식: ADD
스택의 두 최상위 값을 더하고 그 결과를 스택에 저장.
장점: 명령어가 매우 짧고 간단하며 주소를 명시할 필요가 없음.
단점: 스택 기반 연산에 의존해야 하며, 다른 방식보다 속도가 느릴 수 있음.`
        },
        {// 6 
            q : "다음 중 컴퓨터 명령어와 컴퓨터의 내부구조와의 관계가 적절하게 연결된 것은?",
            q1 : '' ,
            a : ["0-주소 명령 : 다중 레지스터를 이용한 구조","1-주소 명령 : 단일 누산기를 이용한 구조","2-주소 명령 : 스택을 이용한 구조","3-주소 명령 : 프로그램 카운터를 이용한 구조"],
            r : 2,
                img:''
            ,  summary:''
        },
        {//
            q : "직접 주소지정방식과 간접 주소지정방식을 이용한다면 각각의 유효주소는?",
            q1 : '' ,
            a : ["500,400","500,818","818,456","818,900"],
            r : 2,
                img:'컴퓨터구조201902.JPG'
            ,  summary:`1. 직접 주소 지정 방식 (Direct Addressing Mode)
설명: 명령어에 피연산자의 실제 메모리 주소가 직접 포함되어 있는 방식입니다. 즉, 명령어에 명시된 주소에서 데이터를 가져와 연산에 사용합니다.
특징:
피연산자가 저장된 메모리 주소가 명령어에 명시되어 있음.
상대적으로 간단하고 이해하기 쉬움.
장점: 명령어가 간결하고 연산 속도가 빠름(주소 해석이 바로 가능).
단점: 주소 공간이 한정되어 있을 때 유연성이 떨어질 수 있음.
예시: MOV A, 1000 (메모리 주소 1000에 있는 데이터를 레지스터 A로 이동)
2. 간접 주소 지정 방식 (Indirect Addressing Mode)
설명: 명령어에 포함된 주소는 실제 데이터가 있는 메모리 주소를 가리키는 포인터 역할을 합니다. 즉, 명령어에서 제공하는 주소로 이동한 후 그 주소에 저장된 값이 실제 데이터의 위치가 됩니다.
특징:
명령어에 포함된 주소는 포인터 역할을 하며, 이 포인터가 가리키는 주소에서 실제 데이터를 가져옴.
다단계 간접 참조도 가능함.
장점: 메모리 주소 공간을 효율적으로 사용하고, 유연성이 높음(포인터를 이용한 간접 참조).
단점: 주소 해석 과정이 추가되므로 연산 속도가 느릴 수 있음.
예시: MOV A, (1000) (메모리 주소 1000에 저장된 주소에서 데이터를 가져와 레지스터 A로 이동)`
        },
        {//8
            q : "간접 주소지정방식과 상대 주소지정방식을 이용한다면 각각 어떤 값이 AC에 적재될 것인가?",
            q1 : '' ,
            a : [""],
            r : 2,
                img:'컴퓨터구조201902.JPG'
            ,  summary:` 간접주소지정방식은 주소 필드에 유효주소가 저장되어 있는 기억장치주소를 기억시키는 방식이므로 유효주소는 500번지에 저장되어있다
                500번지에 저장된 818번지가 유효주소가 된다. 따라서 818번지에 저장되어있는 456이 AC에 적재된다
                상대주소 지정방식에서 유효주소는 주소 필드 + PC의 내용이며  PC는 다음 명령어를 수행하기 위해 258로 증가되었으므로 500+ 258 = 758 번지가 유효주소가 되며
                758번지에 저장된 700이 AC에 적재된다.
`
        },
        {//
            q : "인덱스된 주소지정방식과 레지스터 주소지정방식을 이용한다면 각각 어떤 값이 AC에 적재될 것인가?",
            q1 : '' ,
            a : ["458,400","500,818","800,818","900,800"],
            r : 1,
             img:'컴퓨터구조201902.JPG'
            ,  summary:`인덱스된 주소지정방식의 유효주소는 명령어 주소의 부분 + 인덱스 레지스터의 
            내용이므로 (문제에서 레지스터를 사용할경우 R1을 사용하라고 했으므로 ) 
            유효주소는 500 + 400 = 900번지이며, 레지스터 간접주소지정방식의 유효주소는 
            지정된 레지스터에 있는 주소이므로 R1에 있는 400번지가 유효주소이다.
            레지스터 주소지정방식 (Register Addressing Mode)
       레지스터 주소지정방식은 명령어에서 피연산자의 실제 데이터가 레지스터에 직접 저장된 경우입니다.
        이 경우, R1에 저장된 값 400이 바로 피연산자로 사용되며, 메모리를 참조하지 않고 R1의 값이 그대로 AC에 적재됩니다.
따라서 레지스터 주소지정방식에서는 AC에 400이 적재됩니다
            `
        },
        {//10
            q : "아래 그림은 상태 레지스터의 구조를 나타낸 것이다. 그림에서 (가)에 들어갈 상태비트로서 적절한 것은?",
            q1 : '' ,
            a : ["부호 비트","제로 비트","캐리 비트","오버플로우 비트"],
            r : 4,
                img:'컴퓨터구조201903.JPG'
            ,  summary:''
        },
        {//
            q : "다음 중 내부 버스에 대한 설명으로 적절한 것은?",
            q1 : '' ,
            a : ["중앙처리장치와 레지스터간의 데이터 전송을 위한 공통 선로의 결합이다.","멀티플렉서와 ALU를 이용해서 구성할 수 있다.","레지스터와 ALU를 이용해서 구성할 수 있다","중앙처리장치 내부에서 정보를 전달 할 수 있는 경로이다."],
            r : 4,
                img:''
            ,  summary:''
        },
        {//12 ----
            q : "다음 마이크로 연산에 관한 설명으로 적절한 것은?",
            q1 : '' ,
            a : ["T1 + T2 은 산술 마이크로 연산이다.","R0에는 R1 - R2의 결과가 저장된다.","모두 세가지 마이크로 연산이 수행된다.","R3에는 R4와 R5의 논리 곱 연산 결과가 저장된다."],
            r : 2,
                img:'컴퓨터구조201904.JPG'
            ,  summary:''
        },
        {//13
            q : "중앙처리장치에서 내부 버스를 구성하는 방법은 멀티플렉서와 ㄱ 를 이용한다. 여기서 앞의 괄호 안의 ㄱ 에 해당되는 장치는 위의 그림에서 어디인가?",
            q1 : '' ,
            a : ["가","나","다","라"],
            r : 1,
                img:'컴퓨터구조201905.JPG'
            ,  summary:''
        },
        {//14
            q : "위 그림에서 나에 대한 설명으로 적절한 것은?",
            q1 : '' ,
            a : ["출발레지스터의 내용을 ALU로 보내는데 필요하다","도착 레지스터를 결정하는데 필요하다","상태비트를 보관하는데 필요하다","ALU의 결과를 비트 단위의 이동을 위해 필요하다"],
            r : 3,
                img:'컴퓨터구조201905.JPG'
            ,  summary:''
        },
        {//15
            q : "위 그림에서 레지스터 세트에 15개의 레지스터가 있고, 다 는 21개의 연산, 라 는 7개의 연산을 수행한다고 가정했을 때 제어 단어는 몇비트가 되겠는가?",
            q1 : '' ,
            a : ["20","22","23","24"],
            r : 1,
                img:'컴퓨터구조201905.JPG'
            ,  summary:''
        },
        {//16
            q : "다음 중 처리장치에 있는 각 구성요소의 선택신호를 설명하는 것으로 잘못된 것은?",
            q1 : '' ,
            a : ["처리장치에서 수행되는 마이크로연산을 선택하는 신호","처리장치의 각 구성요소를 제어","선택신호로서 특정 마이크로연산을 선택","처리장치를 구동하는 클럭 신호"],
            r : 4,
                img:''
            ,  summary:''
        },
        {//17
            q : "다음 그림은 제어단어의 각 필드를 나타내고 있다. 각 필드에 관한 설명 중으로 적절한 것은?",
            q1 : '' ,
            a : ["A와 B는 출발레지스터를 선택하는 필드이다.","B는 상태 레지스터의 상태값을 선택하는 필드이다.","F는 쉬프터에서 수행되는 연산의 하나를 선택하는 필드이다.","H는 도착 레지스터를 선택하는 필드이다."],
            r : 1,
                img:'컴퓨터구조201906.JPG'
            ,  summary:''
        },
        {//18
            q : "그림에서 다 에 관련된 내용으로 적절한 것은?",
            q1 : '' ,
            a : ["처리장치로서 입력 16비트는 제어단어이다.","인코더로서 입력 16비트를 상태비트로 인코딩한다.","쉬프터로서 입력 16비트는 쉬프트 연산의 종류를 결정한다.","산술논리연산장치로서 입력 16비트는 산술논리연산의 종류를 결정한다."],
            r : 1,
                img:'컴퓨터구조201907.JPG'
            ,  summary:''
        },
        {//19
            q : "그림에서 만일 MUX1에서 가 로 입력되는 데이터가 6비트이고 다른것은 변동이 없다면 나는 어떻게 바뀌는가?",
            q1 : '' ,
            a : ["64 * 26","128 * 27", "256 * 27", "256 * 28"],
            r : 1,
                img:'컴퓨터구조201907.JPG'
            ,  summary:''
        },
        {//20
            q : "그림에서 가 에 들어갈 내용으로 적절한 것은?",
            q1 : '' ,
            a : ["처리장치","제어장치","제어주소 레지스터","산술논리연산장치"],
            r : 3,
                img:'컴퓨터구조201907.JPG'
            ,  summary:''
        },
        {//21
            q : "다음과 같은 연산을 수행하려 할 때 그림에서 제어기억장치의 27개 비트에 대한 설명으로 잘못된 것은?",
            q1 : '' ,
            a : ["1 ~ 16번 비트는 마이크로연산 R5 <- R6 + R3 를 수행한다.","17번 비트는 (0)2 이어야 한다.","18~ 20번 비트는 캐리의 상태에 따라 결정된다.","21번 ~ 27번 비트는 조건문 if(C=0)을 수행한다."],
            r : 4,
                img:'컴퓨터구조201908.JPG'
            ,  summary:''
        },
        {//
            q : "다음의 CPU에 있는 특수 레지스터 중에서 데이터를 기억하는 레지스터는?",
            q1 : '' ,
            a : ["IR(Instruction Register)","SP(Stack Pointer)","PC(Program Counter)","AC(Accumulator)"],
            r : 4,
                img:''
            ,  summary:''
        },
        {//
            q : "다음 중 중앙처리장치에서 명령어의 연산 코드 (OP code)가 보관되는데 사용되는 레지스터는?",
            q1 : '' ,
            a : ["PC","AC","IR","SP"],
            r : 3,
                img:''
            ,  summary:`IR 명령어 레지스터, SP스택포인터 PC프로그램카운터 `
        },
        {//24
            q : "다음 중 명령어 수행 사이클에 해당되지 않는 것은?",
            q1 : '' ,
            a : ["인출 사이클","저장 사이클","인터럽트 사이클","실행 사이클"],
            r : 2,
                img:''
            ,  summary:''
        },
        {//
            q : "다음과 같은 일련의 마이크로 연산은 무엇을 수행하는 것인가?",
            q1 : '' ,
            a : ["LOAD 명령어","STORE 명령어","AND 명령어","ADD 명령어"],
            r : 1,
                img:'컴퓨터구조201909.JPG'
            ,  summary:''
        },
        {//26
            q : "다음 중 CPU에 있는 레지스터에 대한 설명으로 잘못된 것은?",
            q1 : '' ,
            a : ["레지스터는 데이터의 임시 저장소로서 컴퓨터의 기억장치 중에서 엑세스 속도가 가장 빠르다","명령어 레지스터(IR)는 현재 수행되는 명령어를 갖고 있다.","프로그램 카운터(PC)는 다음에 수행되어질 명령어가 들어있는 주소를 갖고 있다.","스택 포인투(SP)는 특수 레지스터로서 스택에 있는 데이터를 갖고 있다."],
            r : 4,
                img:''
            ,  summary:''
        },
        {//
            q : "다음 설명에서 괄호 안에 들어갈 용어로 알맞은 것은?",
            q1 : '' ,
            a : ["가 : 스택포인터 나: 프로그램 카운터","가 : 프로그램 카운터 나 : 제어주소 레지스터","가 : 프로그램 카운터   나 : 명령어 레지스터","가 : 명령어 버퍼 레지스터   나 :  누산기"],
            r : 3,
                img:'컴퓨터구조201910.JPG'
            ,  summary:''
        },
        {//28
            q : "다음중 기억장치의 성능평가에 사용되는 요인으로서 기억장치에서 데이터를 판독하거나 기록하는 데 걸리는 시간을 나타내는 것은?",
            q1 : '' ,
            a : ["access time","cycle time","transfer time","hit time"],
            r : 1,
                img:''
            ,  summary:''
        },
        {//
            q : "다음 중 기억장치와 그 특성을 연결한 것으로 적절한 것은?",
            q1 : '' ,
            a : ["연관 기억장치  - memory 공간 확대"," 가상기억장치  - memory access 속도증가"," 캐시 기억장치  - memory access 속도증가","복수 모듈 기억장치  - memory 공간 확대"],
            r : 3,
                img:''
            ,  summary:''
        },
        {//30
            q : "위에서 기억장치 접근의 지역성(locallty)를 충분히 이용하는 기억장치를 두개 고르면?",
            q1 : '' ,
            a : ["A,B","B,C","C,D","A,D"],
            r : 2,
                img:'컴퓨터구조201911.JPG'
            ,  summary:''
        },
        {//
            q : "위에서 연관기억장치를 설명하고 있는 것은?",
            q1 : '' ,
            a : ["A","B","C","D"],
            r : 1,
                img:'컴퓨터구조201911.JPG'
            ,  summary:''
        },
        {//32
            q : "위에서 B에대한 설명으로 적합한 기억장치는?",
            q1 : '' ,
            a : ["복수모듈 기억장치","캐시 기억장치","가상 기억장치","보조 기억장치"],
            r : 3,
                img:''
            ,  summary:''
        },
        {//
            q : "중앙처리장치의 개입 없이 직접 주기억장치로 접근하여 데이터의 입출력을 수행하기 위해 주기억장치와 입출력장치 사이에 위치하는 장치를 무엇이라 하는가?",
            q1 : '' ,
            a : ["캐시","DMA","연관 메모리","가상 메모리"],
            r : 2,
                img:''
            ,  summary:''
        },
        {//34
            q : "버스 중재에 있어서 중재기에 가까운 순으로 우선순위가 주어지는 방법은?",
            q1 : '' ,
            a : ["중앙집중식 병렬중재 방법","우선순위 인코더 방법","폴링 중재방법","데이지 체인 중재 방법"],
            r : 4,
                img:''
            ,  summary:''
        },
        {//
            q : "다음 중 병렬처리기를 처리기의 상호연결망 구조에 따라 분류한 것으로 옳은 것은?",
            q1 : '' ,
            a : ["SISD, SIMD, MISD, MIMD" ,"다중장치 처리기, 파이프라인 처리기","버스, 크로스바, 트리, 입방체","공유 기억장치 시스템, 메시지 전달 시스템"],
            r : 3,
                img:''
            ,  summary:''
        },
    ]
    let [subject,setsubject]= React.useState(test2017jsp) 
    function namecheck(){
     switch(data){
        case 'test2017jsp' : 
        setsubject(test2017jsp)
        break;
        case 'test2017db' :
            setsubject(test2017db)
        break;
        case 'test2018db' :
            setsubject(test2018db)
        break;
        case 'test2019db' :
            setsubject(test2019db)
        break;
     }   
    }   

    React.useEffect(()=>{
    namecheck()
    // setcheckvalue(Array(25).fill(null))
    },[])

    let [checkvalue, setcheckvalue] = React.useState(Array(25).fill(null)) //정답 저장할곳
    function checkresult (idx : number, value : number){
            const newSelectedAnswers = [...checkvalue];
            newSelectedAnswers[idx] = value; // 선택한 값을 저장
            setcheckvalue(newSelectedAnswers);
         
    }
    function resultcheck(idx:number,t:Testtype){
        if(checkvalue[idx]==t.r){
            window.alert('정답입니다.')
        }else if(!checkvalue[idx]){
            window.alert('정답을 선택하세요.')
        }else{
            window.alert('오답입니다.')
        } 
        }
 
    return(
        <div className={testdata.fullwrap}>
            <div className={testdata.fullcut}>
            {subject.map((a,idx)=> {return <div className={testdata.wrap1}> 
            <h2>{a.q}</h2>
            <p>{a.q1 && a.q1 }</p>
            {a.img && <img src={`/${a.img}`} /> }
            <div className={testdata.select1}>
            {  a.a.map((el,index)=>(
                <div className={testdata.radiobtn}><input type="radio" value={index+1} name={String(idx)} onChange={()=>{
                    checkresult(idx,index+1)
                }} /> {el.length <10 ? <p>{el}</p> : <p className={testdata.divide}>{el}</p> }</div>
            )
            )}
            </div>
            <div className={testdata.btn}>
                <button onClick={()=>{
               resultcheck(idx,a)
            }}> 정답 </button>
            {a.summary && <details className={testdata.correct} >
                <summary>   
                    해설보기 
                    </summary> 
                        {a.summary}                                        
                    </details>}
            </div>
            </div>
            })}
            </div>
        

            
         
        </div>
    )
}